<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<title>STELLAR DANMAKU</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    background: #000;
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: 'Courier New', monospace;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    position: fixed;
    top: 0; left: 0;
  }
  body {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  canvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    touch-action: none;
  }
  #loading-screen {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: #0a0a15;
    z-index: 20;
    color: #fff;
  }
  #loading-screen h2 {
    font-size: 18px;
    color: #7b68ee;
    margin-bottom: 20px;
    letter-spacing: 4px;
  }
  .load-bar-outer {
    width: 200px; height: 6px;
    border: 1px solid #7b68ee;
    border-radius: 3px;
    overflow: hidden;
  }
  .load-bar-inner {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #7b68ee, #00ffff);
    transition: width 0.1s;
  }
  #load-text {
    margin-top: 10px;
    font-size: 11px;
    color: #555;
  }
  #title-screen {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0,0,0,0.85);
    z-index: 10;
    color: #fff;
    text-align: center;
    padding: 20px;
  }
  #title-screen h1 {
    font-size: clamp(28px, 8vw, 48px);
    background: linear-gradient(45deg, #ff6ec7, #7b68ee, #00ffff, #ff6ec7);
    background-size: 300% 300%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: gradientShift 3s ease infinite;
    margin-bottom: 10px;
  }
  #title-screen .subtitle {
    font-size: clamp(10px, 3vw, 14px);
    color: #7b68ee;
    margin-bottom: 30px;
    letter-spacing: 4px;
  }
  #title-screen .prompt {
    font-size: clamp(14px, 4vw, 18px);
    color: #00ffff;
    animation: blink 1.2s ease-in-out infinite;
  }
  #title-screen .controls {
    margin-top: 25px;
    font-size: clamp(10px, 2.8vw, 12px);
    color: #888;
    line-height: 2;
  }
  #title-screen .controls span { color: #ff6ec7; }
  .mobile-hint { display: none; color: #ff6ec7; margin-top: 15px; font-size: clamp(10px, 2.8vw, 12px); }
  @keyframes gradientShift {
    0%,100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
  }
  @keyframes blink {
    0%,100% { opacity: 1; }
    50% { opacity: 0.2; }
  }
  #game-over {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0,0,0,0.8);
    z-index: 10;
    color: #fff;
    text-align: center;
    padding: 20px;
  }
  #game-over h1 { font-size: clamp(28px, 8vw, 42px); color: #ff4444; margin-bottom: 20px; }
  #game-over .score { font-size: clamp(16px, 5vw, 24px); color: #ff6ec7; margin-bottom: 10px; }
  #game-over .prompt { font-size: clamp(14px, 4vw, 16px); color: #00ffff; animation: blink 1.2s ease-in-out infinite; margin-top: 20px; }
  #touch-controls {
    display: none;
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 5;
    pointer-events: none;
  }
  #touch-controls.active { display: block; }
  .touch-btn {
    position: absolute;
    pointer-events: auto;
    touch-action: none;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    color: rgba(255,255,255,0.6);
    border: 2px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.05);
    -webkit-tap-highlight-color: transparent;
  }
  .touch-btn.pressed {
    background: rgba(255,255,255,0.15);
    border-color: rgba(255,255,255,0.5);
  }
  #btn-bomb {
    right: 20px;
    bottom: 100px;
    width: 56px;
    height: 56px;
    font-size: 14px;
    border-color: rgba(68,255,68,0.4);
    color: rgba(68,255,68,0.7);
  }
  #btn-focus {
    right: 85px;
    bottom: 100px;
    width: 56px;
    height: 56px;
    font-size: 11px;
    border-color: rgba(255,110,199,0.4);
    color: rgba(255,110,199,0.7);
  }
  #drag-zone {
    position: absolute;
    left: 0; top: 0;
    width: 100%; height: 100%;
    pointer-events: auto;
  }
  #auto-fire-indicator {
    position: absolute;
    top: 40px;
    right: 15px;
    font-size: 10px;
    color: rgba(0,255,255,0.5);
    pointer-events: none;
    display: none;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="loading-screen">
  <h2>LOADING</h2>
  <div class="load-bar-outer"><div class="load-bar-inner" id="load-bar"></div></div>
  <div id="load-text">Preparing assets...</div>
</div>

<div id="touch-controls">
  <div id="drag-zone"></div>
  <div class="touch-btn" id="btn-focus">FOCUS</div>
  <div class="touch-btn" id="btn-bomb">BOMB</div>
  <div id="auto-fire-indicator">AUTO-FIRE ON</div>
</div>

<div id="title-screen">
  <h1>STELLAR DANMAKU</h1>
  <div class="subtitle">G A L A G A &nbsp; x &nbsp; T O U H O U</div>
  <div class="prompt">[ TAP OR PRESS ENTER ]</div>
  <div class="controls desktop-controls">
    <span>WASD / ARROWS</span> — Move<br>
    <span>SPACE / Z</span> — Shoot<br>
    <span>SHIFT</span> — Focus (slow + tighter hitbox)<br>
    <span>X</span> — Bomb (clears bullets)
  </div>
  <div class="mobile-hint">
    Drag anywhere to move<br>
    Auto-fire is ON<br>
    FOCUS = slow + precise | BOMB = clear screen
  </div>
</div>

<div id="game-over">
  <h1>GAME OVER</h1>
  <div class="score" id="final-score"></div>
  <div class="score" id="final-wave"></div>
  <div class="prompt">[ TAP OR PRESS ENTER TO RETRY ]</div>
</div>

<script>
// ============================================================
//  STELLAR DANMAKU — A Galaga x Touhou Bullet Hell Shooter
//  Enhanced with sprite art + canvas effects
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = 480, H = 720;
canvas.width = W;
canvas.height = H;

// Offscreen canvas for bloom post-processing
const bloomCanvas = document.createElement('canvas');
bloomCanvas.width = W; bloomCanvas.height = H;
const bloomCtx = bloomCanvas.getContext('2d');

// ---- MOBILE DETECTION ----
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ||
  ('ontouchstart' in window && window.innerWidth < 1024);

if (isMobile) {
  document.querySelector('.desktop-controls').style.display = 'none';
  document.querySelector('.mobile-hint').style.display = 'block';
}

// Prevent all default touch behaviors on iOS + handle drag at document level
// (drag-zone element approach was unreliable on iOS Safari)
document.addEventListener('touchstart', e => {
  e.preventDefault();
  if (gameState !== 'playing') return;
  for (const t of e.changedTouches) {
    if (touch.btnIds.has(t.identifier)) continue;
    if (touch.dragId === null) {
      touch.dragId = t.identifier;
      touch.active = true;
      touch.lastX = t.clientX;
      touch.lastY = t.clientY;
      touch.dx = 0;
      touch.dy = 0;
    }
  }
}, { passive: false });
document.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === touch.dragId) {
      touch.dx += screenToGame(t.clientX - touch.lastX);
      touch.dy += screenToGame(t.clientY - touch.lastY);
      touch.lastX = t.clientX;
      touch.lastY = t.clientY;
    }
  }
}, { passive: false });
document.addEventListener('touchend', e => {
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === touch.dragId) {
      touch.dragId = null;
      touch.active = false;
      touch.dx = 0;
      touch.dy = 0;
    }
  }
}, { passive: false });
document.addEventListener('touchcancel', e => {
  for (const t of e.changedTouches) {
    if (t.identifier === touch.dragId) {
      touch.dragId = null;
      touch.active = false;
      touch.dx = 0;
      touch.dy = 0;
    }
  }
});
document.addEventListener('gesturestart', e => e.preventDefault(), { passive: false });
document.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
document.addEventListener('gestureend', e => e.preventDefault(), { passive: false });

// Scale canvas to fit viewport
function resize() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const scale = Math.min(vw / W, vh / H);
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
  canvas._scale = scale;
  canvas._offsetX = (vw - W * scale) / 2;
  canvas._offsetY = (vh - H * scale) / 2;
}
resize();
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', () => setTimeout(resize, 100));

// ============================================================
//  ASSET LOADING
// ============================================================
const FOOZLE = 'assets/foozle_ship/Foozle_2DS0011_Void_MainShip';

const ASSET_PATHS = {
  // Player ship (Foozle)
  playerBase:  `${FOOZLE}/Main Ship/Main Ship - Bases/PNGs/Main Ship - Base - Full health.png`,
  playerDmg1:  `${FOOZLE}/Main Ship/Main Ship - Bases/PNGs/Main Ship - Base - Slight damage.png`,
  playerDmg2:  `${FOOZLE}/Main Ship/Main Ship - Bases/PNGs/Main Ship - Base - Damaged.png`,
  playerDmg3:  `${FOOZLE}/Main Ship/Main Ship - Bases/PNGs/Main Ship - Base - Very damaged.png`,
  engineIdle:  `${FOOZLE}/Main Ship/Main Ship - Engine Effects/PNGs/Main Ship - Engines - Supercharged Engine - Idle.png`,
  enginePower: `${FOOZLE}/Main Ship/Main Ship - Engine Effects/PNGs/Main Ship - Engines - Supercharged Engine - Powering.png`,
  shieldFront: `${FOOZLE}/Main Ship/Main Ship - Shields/PNGs/Main Ship - Shields - Front Shield.png`,
  shieldRound: `${FOOZLE}/Main Ship/Main Ship - Shields/PNGs/Main Ship - Shields - Round Shield.png`,
  weaponAuto:  `${FOOZLE}/Main Ship/Main Ship - Weapons/PNGs/Main Ship - Weapons - Auto Cannon.png`,
  projBullet:  `${FOOZLE}/Main ship weapons/PNGs/Main ship weapon - Projectile - Auto cannon bullet.png`,
  projBigGun:  `${FOOZLE}/Main ship weapons/PNGs/Main ship weapon - Projectile - Big Space Gun.png`,

  // Enemies (Kenney)
  enemyGrunt:   'assets/kenney/PNG/Enemies/enemyRed1.png',
  enemySpinner: 'assets/kenney/PNG/Enemies/enemyBlue2.png',
  enemyTank:    'assets/kenney/PNG/Enemies/enemyGreen3.png',
  enemySniper:  'assets/kenney/PNG/Enemies/enemyBlack4.png',
  enemySwooper: 'assets/kenney/PNG/Enemies/enemyRed5.png',

  // Boss sprites (Kenney, will be drawn larger)
  boss1: 'assets/kenney/PNG/Enemies/enemyRed3.png',
  boss2: 'assets/kenney/PNG/Enemies/enemyBlue4.png',
  boss3: 'assets/kenney/PNG/Enemies/enemyBlack5.png',

  // Miniboss sprites (Grok-generated)
  miniboss4: 'assets/miniboss/jellyfish.jpg',
  miniboss5: 'assets/miniboss/scarab.jpg',
  serpentSheet: 'assets/miniboss/serpent-sprites-v2.png',
  miniboss7: 'assets/miniboss/sentinel.jpg',
  miniboss8: 'assets/miniboss/hydra.jpg',
  hydraBodySheet: 'assets/miniboss/hydra-body.jpg',
  hydraHeadsSheet: 'assets/miniboss/hydra-heads.jpg',
  hydraSegsSheet: 'assets/miniboss/hydra-segments.jpg',
  hydraBodyV2: 'assets/miniboss/hydra-body-v2.jpg',
  hydraHeadRedImg: 'assets/miniboss/hydra-head-red.jpg',
  hydraHeadBlueImg: 'assets/miniboss/hydra-head-blue.jpg',
  hydraHeadPurpleImg: 'assets/miniboss/hydra-head-purple.jpg',

  // Player lasers (Kenney)
  laserBlue1:  'assets/kenney/PNG/Lasers/laserBlue01.png',
  laserBlue2:  'assets/kenney/PNG/Lasers/laserBlue06.png',
  laserGreen1: 'assets/kenney/PNG/Lasers/laserGreen11.png',
  laserRed1:   'assets/kenney/PNG/Lasers/laserRed01.png',

  // Power-ups (Kenney)
  pupPower: 'assets/kenney/PNG/Power-ups/powerupRed.png',
  pupScore: 'assets/kenney/PNG/Power-ups/powerupBlue_star.png',
  pupBomb:  'assets/kenney/PNG/Power-ups/powerupGreen.png',

  // Background
  bgTile: 'assets/kenney/Backgrounds/darkPurple.png',

  // Meteors (decorative)
  meteorTiny1:  'assets/kenney/PNG/Meteors/meteorGrey_tiny1.png',
  meteorTiny2:  'assets/kenney/PNG/Meteors/meteorGrey_tiny2.png',
  meteorSmall1: 'assets/kenney/PNG/Meteors/meteorBrown_small1.png',

  // Fire effects for explosions (subset)
  fire00: 'assets/kenney/PNG/Effects/fire00.png',
  fire04: 'assets/kenney/PNG/Effects/fire04.png',
  fire08: 'assets/kenney/PNG/Effects/fire08.png',
  fire12: 'assets/kenney/PNG/Effects/fire12.png',
  fire16: 'assets/kenney/PNG/Effects/fire16.png',

  // Stars
  star1: 'assets/kenney/PNG/Effects/star1.png',
  star2: 'assets/kenney/PNG/Effects/star2.png',
  star3: 'assets/kenney/PNG/Effects/star3.png',

  // Shields
  shield1: 'assets/kenney/PNG/Effects/shield1.png',
  shield2: 'assets/kenney/PNG/Effects/shield2.png',

  // Kenney player ships (Tempest & Bastion)
  ship2Base: 'assets/kenney/PNG/playerShip2_red.png',
  ship2Dmg1: 'assets/kenney/PNG/Damage/playerShip2_damage1.png',
  ship2Dmg2: 'assets/kenney/PNG/Damage/playerShip2_damage2.png',
  ship2Dmg3: 'assets/kenney/PNG/Damage/playerShip2_damage3.png',
  ship3Base: 'assets/kenney/PNG/playerShip3_green.png',
  ship3Dmg1: 'assets/kenney/PNG/Damage/playerShip3_damage1.png',
  ship3Dmg2: 'assets/kenney/PNG/Damage/playerShip3_damage2.png',
  ship3Dmg3: 'assets/kenney/PNG/Damage/playerShip3_damage3.png',

  // Foozle invincibility shield (for Bastion bubble bomb)
  shieldInvinc: `${FOOZLE}/Main Ship/Main Ship - Shields/PNGs/Main Ship - Shields - Invincibility Shield.png`,
};

const img = {};  // loaded Image objects
let assetsLoaded = false;

function encodePath(p) {
  return p.split('/').map(s => encodeURIComponent(s)).join('/');
}

function loadAllAssets() {
  const keys = Object.keys(ASSET_PATHS);
  let loaded = 0;
  const total = keys.length;
  const bar = document.getElementById('load-bar');
  const txt = document.getElementById('load-text');

  return new Promise((resolve) => {
    keys.forEach(key => {
      const image = new Image();
      image.onload = () => {
        img[key] = image;
        loaded++;
        bar.style.width = (loaded / total * 100) + '%';
        txt.textContent = `${loaded}/${total}`;
        if (loaded >= total) resolve();
      };
      image.onerror = () => {
        // Still count it, draw fallback shapes
        loaded++;
        bar.style.width = (loaded / total * 100) + '%';
        txt.textContent = `${loaded}/${total}`;
        if (loaded >= total) resolve();
      };
      image.src = encodePath(ASSET_PATHS[key]);
    });
  });
}

// Luminance key a canvas: transparent below threshold, soft ramp for mid-tones, edge fade
function lumKeyCanvas(c, cx, edgeFade = true, lumLow = 45, lumHigh = 130) {
  const w = c.width, h = c.height;
  const id = cx.getImageData(0, 0, w, h);
  const d = id.data;
  const midX = w / 2, midY = h / 2;
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const i = (y * w + x) * 4;
      const lum = d[i] * 0.299 + d[i + 1] * 0.587 + d[i + 2] * 0.114;
      let alpha = 255;
      if (lum < lumLow) alpha = 0;
      else if (lum < lumHigh) alpha = Math.floor(((lum - lumLow) / (lumHigh - lumLow)) * 255);
      if (edgeFade) {
        const dx = (x - midX) / midX;
        const dy = (y - midY) / midY;
        const edgeDist = Math.sqrt(dx * dx + dy * dy);
        if (edgeDist > 0.6) {
          alpha = Math.floor(alpha * Math.max(0, 1 - (edgeDist - 0.6) / 0.4));
        }
      }
      d[i + 3] = alpha;
    }
  }
  cx.putImageData(id, 0, 0);
}

// Preprocess miniboss sprites: luminance key removes dark backgrounds
function preprocessMinibossSprites() {
  const minibossKeys = ['miniboss4', 'miniboss5', 'miniboss7', 'miniboss8'];
  for (const key of minibossKeys) {
    const src = img[key];
    if (!src) continue;
    const w = src.naturalWidth || src.width;
    const h = src.naturalHeight || src.height;
    const c = document.createElement('canvas');
    const cx = c.getContext('2d');
    c.width = w; c.height = h;
    cx.drawImage(src, 0, 0);
    lumKeyCanvas(c, cx, true);
    img[key] = c;
  }

  // Process serpent spritesheet: split into head, body, tail frames, auto-crop
  const sheet = img['serpentSheet'];
  if (sheet) {
    const sw = sheet.naturalWidth || sheet.width;
    const sh = sheet.naturalHeight || sheet.height;
    const frameW = Math.floor(sw / 3);
    const names = ['serpentHead', 'serpentBody', 'serpentTail'];
    for (let f = 0; f < 3; f++) {
      // First pass: luminance key the full frame
      const tmp = document.createElement('canvas');
      const tmpCx = tmp.getContext('2d');
      tmp.width = frameW; tmp.height = sh;
      tmpCx.drawImage(sheet, f * frameW, 0, frameW, sh, 0, 0, frameW, sh);
      lumKeyCanvas(tmp, tmpCx, false, 20, 60);
      // Auto-crop to bounding box of non-transparent pixels
      const id = tmpCx.getImageData(0, 0, frameW, sh);
      const d = id.data;
      let minX = frameW, minY = sh, maxX = 0, maxY = 0;
      for (let y = 0; y < sh; y++) {
        for (let x = 0; x < frameW; x++) {
          if (d[(y * frameW + x) * 4 + 3] > 10) {
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
        }
      }
      // Add small padding
      const pad = 4;
      minX = Math.max(0, minX - pad); minY = Math.max(0, minY - pad);
      maxX = Math.min(frameW - 1, maxX + pad); maxY = Math.min(sh - 1, maxY + pad);
      const cropW = maxX - minX + 1, cropH = maxY - minY + 1;
      const c = document.createElement('canvas');
      const cx = c.getContext('2d');
      c.width = cropW; c.height = cropH;
      cx.drawImage(tmp, minX, minY, cropW, cropH, 0, 0, cropW, cropH);
      img[names[f]] = c;
    }
  }

  // --- Helper: elliptical edge fade + luminance floor + brightness boost ---
  // lumFloor: pixels below this luminance become fully transparent.
  // fadeStart: elliptical edge fade begins at this radius (0=center, 1=edge).
  // brightnessBoost: multiply surviving pixel RGB by this factor (for additive blend).
  function grokEdgeFade(c, cx, fadeStart, lumFloor, brightnessBoost) {
    const w = c.width, h = c.height;
    const id = cx.getImageData(0, 0, w, h);
    const d = id.data;
    const midX = w / 2, midY = h / 2;
    const boost = brightnessBoost || 1;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y * w + x) * 4;
        const lum = d[i] * 0.299 + d[i + 1] * 0.587 + d[i + 2] * 0.114;
        if (lum < lumFloor) { d[i + 3] = 0; continue; }
        // Brightness boost: amplify surviving pixel colors for additive blend
        if (boost > 1) {
          d[i]     = Math.min(255, Math.floor(d[i] * boost));
          d[i + 1] = Math.min(255, Math.floor(d[i + 1] * boost));
          d[i + 2] = Math.min(255, Math.floor(d[i + 2] * boost));
        }
        // Elliptical edge fade (linear falloff for smoother transition)
        const dx = (x - midX) / midX;
        const dy = (y - midY) / midY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > fadeStart) {
          const fade = Math.max(0, 1 - (dist - fadeStart) / (1.0 - fadeStart));
          d[i + 3] = Math.floor(d[i + 3] * fade);
        }
      }
    }
    cx.putImageData(id, 0, 0);
  }

  // --- Helper: crop an image and apply grokEdgeFade ---
  // squareCrop: if true, crop to square using shorter dimension, centered on upper portion
  // verticalBias: 0=center, negative=shift crop upward (e.g. -0.15 to focus on face)
  function processHydraImage(srcImg, destKey, cropPct, fadeStart, lumFloor, brightnessBoost, squareCrop, verticalBias) {
    if (!srcImg) return;
    const ow = srcImg.naturalWidth || srcImg.width;
    const oh = srcImg.naturalHeight || srcImg.height;
    let cropX, cropY, cw, ch;
    if (squareCrop) {
      // Crop to square based on shorter dimension, with vertical bias
      const size = Math.floor(Math.min(ow, oh) * cropPct);
      cw = size; ch = size;
      cropX = Math.floor((ow - size) / 2);
      cropY = Math.floor((oh - size) / 2 + oh * (verticalBias || 0));
      cropY = Math.max(0, Math.min(oh - size, cropY));
    } else {
      const margin = (1 - cropPct) / 2;
      cropX = Math.floor(ow * margin);
      cropY = Math.floor(oh * margin);
      cw = Math.floor(ow * cropPct);
      ch = Math.floor(oh * cropPct);
    }
    const c = document.createElement('canvas');
    const cx = c.getContext('2d');
    c.width = cw; c.height = ch;
    cx.drawImage(srcImg, cropX, cropY, cw, ch, 0, 0, cw, ch);
    grokEdgeFade(c, cx, fadeStart, lumFloor, brightnessBoost);
    img[destKey] = c;
  }

  // Process Hydra v2 individual images (bright-on-black, source-over compositing)
  // Body: center crop, wide fade, strong boost for opaque creature detail
  processHydraImage(img['hydraBodyV2'],      'hydraBody',       0.88, 0.65, 8, 2.5);
  // Heads: square-crop with upward bias to capture face, wide fade, strong boost
  processHydraImage(img['hydraHeadRedImg'],   'hydraHeadRed',   0.95, 0.55, 8, 2.2, true, -0.12);
  processHydraImage(img['hydraHeadBlueImg'],  'hydraHeadBlue',  0.95, 0.55, 8, 2.2, true, -0.12);
  processHydraImage(img['hydraHeadPurpleImg'],'hydraHeadPurple', 0.95, 0.55, 8, 2.2, true, -0.10);

  // Legacy fallback: process old spritesheets if v2 images didn't load
  if (!img['hydraBody']) {
    const hydraBody = img['hydraBodySheet'];
    if (hydraBody) {
      const ow = hydraBody.naturalWidth || hydraBody.width;
      const oh = hydraBody.naturalHeight || hydraBody.height;
      const cropX = Math.floor(ow * 0.125);
      const cropY = Math.floor(oh * 0.1);
      const cw = Math.floor(ow * 0.75);
      const ch = Math.floor(oh * 0.8);
      const c = document.createElement('canvas');
      const cx = c.getContext('2d');
      c.width = cw; c.height = ch;
      cx.drawImage(hydraBody, cropX, cropY, cw, ch, 0, 0, cw, ch);
      grokEdgeFade(c, cx, 0.45, 22, 3.0);
      img['hydraBody'] = c;
    }
  }

  if (!img['hydraHeadRed']) {
    const hydraHeads = img['hydraHeadsSheet'];
    if (hydraHeads) {
      const sw = hydraHeads.naturalWidth || hydraHeads.width;
      const sh = hydraHeads.naturalHeight || hydraHeads.height;
      const frameW = Math.floor(sw / 3);
      const sqSize = frameW;
      const centerY = Math.floor(sh * 0.42);
      const cropTop = Math.max(0, centerY - Math.floor(sqSize / 2));
      const headNames = ['hydraHeadRed', 'hydraHeadBlue', 'hydraHeadPurple'];
      for (let f = 0; f < 3; f++) {
        const c = document.createElement('canvas');
        const cx = c.getContext('2d');
        c.width = sqSize; c.height = sqSize;
        cx.drawImage(hydraHeads, f * frameW, cropTop, frameW, sqSize, 0, 0, sqSize, sqSize);
        grokEdgeFade(c, cx, 0.35, 30, 2.0);
        img[headNames[f]] = c;
      }
    }
  }

  // Process Hydra segments from old spritesheet (no v2 replacement)
  const hydraSegs = img['hydraSegsSheet'];
  if (hydraSegs) {
    const sw = hydraSegs.naturalWidth || hydraSegs.width;
    const sh = hydraSegs.naturalHeight || hydraSegs.height;
    const frameW = Math.floor(sw / 3);
    const plateTop = Math.floor(sh * 0.18);
    const plateH = Math.floor(sh * 0.13);
    const segNames = ['hydraSegRed', 'hydraSegBlue', 'hydraSegPurple'];
    for (let f = 0; f < 3; f++) {
      const c = document.createElement('canvas');
      const cx = c.getContext('2d');
      c.width = frameW; c.height = plateH;
      cx.drawImage(hydraSegs, f * frameW, plateTop, frameW, plateH, 0, 0, frameW, plateH);
      grokEdgeFade(c, cx, 0.3, 30, 2.0);
      img[segNames[f]] = c;
    }
  }
}

// ---- GENERATE HYDRA SPRITES (programmatic pixel art) ----
function generateHydraSprites() {
  // Skip programmatic body/head/seg generation if AI-generated sprites loaded
  // (v2 individual images or legacy Grok spritesheets), but always generate
  // the glob sprite (no AI version exists)
  const hasGrokSprites = img['hydraBody'] && img['hydraHeadRed'] && img['hydraHeadBlue'] && img['hydraHeadPurple'] && img['hydraSegRed'];

  if (!hasGrokSprites) {
  // --- Fallback: programmatic body mass sprite ---
  const bodyW = 320, bodyH = 200;
  const bodyC = document.createElement('canvas');
  bodyC.width = bodyW; bodyC.height = bodyH;
  const bc = bodyC.getContext('2d');
  const bMidX = bodyW / 2, bMidY = bodyH / 2;

  // Base mass — irregular dark shape built from overlapping ellipses
  bc.globalCompositeOperation = 'source-over';
  const masses = [
    { x: bMidX, y: bMidY + 10, rx: 140, ry: 80, c1: '#1a0a2e', c2: '#0d0518' },
    { x: bMidX - 50, y: bMidY - 10, rx: 90, ry: 60, c1: '#221040', c2: '#110822' },
    { x: bMidX + 50, y: bMidY - 10, rx: 90, ry: 60, c1: '#221040', c2: '#110822' },
    { x: bMidX, y: bMidY + 30, rx: 110, ry: 50, c1: '#180830', c2: '#0a0416' },
    { x: bMidX - 30, y: bMidY + 40, rx: 60, ry: 35, c1: '#2a1248', c2: '#0d0518' },
    { x: bMidX + 30, y: bMidY + 40, rx: 60, ry: 35, c1: '#2a1248', c2: '#0d0518' },
  ];
  for (const m of masses) {
    const g = bc.createRadialGradient(m.x, m.y, 0, m.x, m.y, m.rx);
    g.addColorStop(0, m.c1);
    g.addColorStop(0.7, m.c2);
    g.addColorStop(1, 'rgba(10,4,20,0)');
    bc.fillStyle = g;
    bc.beginPath(); bc.ellipse(m.x, m.y, m.rx, m.ry, 0, 0, Math.PI * 2); bc.fill();
  }

  // Armored plate highlights — layered ridges
  bc.globalCompositeOperation = 'lighter';
  const ridges = [
    { x: bMidX, y: bMidY - 20, rx: 120, ry: 30 },
    { x: bMidX - 40, y: bMidY + 5, rx: 70, ry: 20 },
    { x: bMidX + 40, y: bMidY + 5, rx: 70, ry: 20 },
    { x: bMidX, y: bMidY + 35, rx: 80, ry: 15 },
  ];
  for (const r of ridges) {
    const g = bc.createRadialGradient(r.x, r.y - 5, 0, r.x, r.y, r.rx);
    g.addColorStop(0, 'rgba(80, 40, 120, 0.15)');
    g.addColorStop(0.5, 'rgba(60, 30, 100, 0.06)');
    g.addColorStop(1, 'rgba(40, 20, 80, 0)');
    bc.fillStyle = g;
    bc.beginPath(); bc.ellipse(r.x, r.y, r.rx, r.ry, 0, 0, Math.PI * 2); bc.fill();
  }

  // Veins — branching lines from anchor points
  bc.globalCompositeOperation = 'lighter';
  const anchors = [
    { x: bMidX - 55, y: bMidY + 55, color: 'rgba(255,68,68,0.12)' },
    { x: bMidX, y: bMidY + 65, color: 'rgba(68,136,255,0.12)' },
    { x: bMidX + 55, y: bMidY + 55, color: 'rgba(204,68,255,0.12)' },
  ];
  for (const a of anchors) {
    for (let v = 0; v < 8; v++) {
      const angle = (v / 8) * Math.PI * 2 + (a.x > bMidX ? 0.3 : a.x < bMidX ? -0.3 : 0);
      const len = 40 + Math.sin(v * 2.3) * 25;
      bc.strokeStyle = a.color;
      bc.lineWidth = 1.5 - v * 0.1;
      bc.beginPath();
      bc.moveTo(a.x, a.y);
      const cpx = a.x + Math.cos(angle) * len * 0.6 + Math.sin(v * 1.7) * 15;
      const cpy = a.y + Math.sin(angle) * len * 0.6 + Math.cos(v * 2.1) * 10;
      const ex = a.x + Math.cos(angle) * len;
      const ey = a.y + Math.sin(angle) * len;
      bc.quadraticCurveTo(cpx, cpy, ex, ey);
      bc.stroke();
      // Branch
      if (v % 2 === 0) {
        bc.lineWidth = 0.8;
        bc.beginPath();
        bc.moveTo(cpx, cpy);
        bc.lineTo(cpx + Math.cos(angle + 0.8) * 15, cpy + Math.sin(angle + 0.8) * 15);
        bc.stroke();
      }
    }
  }

  // Eye markings — 2 large eye shapes on the body
  bc.globalCompositeOperation = 'source-over';
  const eyes = [{ x: bMidX - 35, y: bMidY - 5 }, { x: bMidX + 35, y: bMidY - 5 }];
  for (const eye of eyes) {
    // Eye socket (dark indent)
    const sockG = bc.createRadialGradient(eye.x, eye.y, 0, eye.x, eye.y, 18);
    sockG.addColorStop(0, 'rgba(0,0,0,0.4)');
    sockG.addColorStop(0.6, 'rgba(20,5,30,0.2)');
    sockG.addColorStop(1, 'rgba(20,5,30,0)');
    bc.fillStyle = sockG;
    bc.beginPath(); bc.ellipse(eye.x, eye.y, 18, 12, 0, 0, Math.PI * 2); bc.fill();
    // Iris glow
    bc.globalCompositeOperation = 'lighter';
    const irisG = bc.createRadialGradient(eye.x, eye.y, 0, eye.x, eye.y, 10);
    irisG.addColorStop(0, 'rgba(180,60,255,0.25)');
    irisG.addColorStop(0.4, 'rgba(120,30,200,0.15)');
    irisG.addColorStop(1, 'rgba(80,20,150,0)');
    bc.fillStyle = irisG;
    bc.beginPath(); bc.ellipse(eye.x, eye.y, 12, 8, 0, 0, Math.PI * 2); bc.fill();
    // Pupil slit
    bc.globalCompositeOperation = 'source-over';
    bc.fillStyle = 'rgba(0,0,0,0.5)';
    bc.beginPath(); bc.ellipse(eye.x, eye.y, 2, 7, 0, 0, Math.PI * 2); bc.fill();
    // Catch light
    bc.globalCompositeOperation = 'lighter';
    bc.fillStyle = 'rgba(255,200,255,0.3)';
    bc.beginPath(); bc.arc(eye.x - 2, eye.y - 3, 2, 0, Math.PI * 2); bc.fill();
    bc.globalCompositeOperation = 'source-over';
  }

  // Small eye cluster in center (third eye)
  bc.globalCompositeOperation = 'lighter';
  const thirdG = bc.createRadialGradient(bMidX, bMidY - 20, 0, bMidX, bMidY - 20, 8);
  thirdG.addColorStop(0, 'rgba(255,100,255,0.3)');
  thirdG.addColorStop(1, 'rgba(200,50,200,0)');
  bc.fillStyle = thirdG;
  bc.beginPath(); bc.arc(bMidX, bMidY - 20, 8, 0, Math.PI * 2); bc.fill();

  // Tentacle-like protrusions from edges
  bc.globalCompositeOperation = 'source-over';
  const tentAngles = [-2.8, -2.4, -0.7, -0.3, 3.0, 3.4, 0.3, 0.7];
  for (const ta of tentAngles) {
    const tx = bMidX + Math.cos(ta) * 110;
    const ty = bMidY + Math.sin(ta) * 55;
    const tipX = tx + Math.cos(ta) * 30;
    const tipY = ty + Math.sin(ta) * 20;
    bc.strokeStyle = 'rgba(30,15,50,0.6)';
    bc.lineWidth = 4;
    bc.lineCap = 'round';
    bc.beginPath();
    bc.moveTo(tx, ty);
    bc.quadraticCurveTo(tx + Math.cos(ta) * 15, ty + Math.sin(ta) * 15 + 5, tipX, tipY);
    bc.stroke();
    bc.lineWidth = 2;
    bc.strokeStyle = 'rgba(60,30,90,0.3)';
    bc.stroke();
  }

  // Edge fade to transparent
  const edgeData = bc.getImageData(0, 0, bodyW, bodyH);
  const ed = edgeData.data;
  for (let y = 0; y < bodyH; y++) {
    for (let x = 0; x < bodyW; x++) {
      const dx = (x - bMidX) / (bodyW * 0.45);
      const dy = (y - bMidY) / (bodyH * 0.45);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 0.7) {
        const fade = Math.max(0, 1 - (dist - 0.7) / 0.3);
        const i = (y * bodyW + x) * 4;
        ed[i + 3] = Math.floor(ed[i + 3] * fade);
      }
    }
  }
  bc.putImageData(edgeData, 0, 0);
  img['hydraBody'] = bodyC;

  // --- Head sprites: 3 distinct shapes ---
  const headSize = 64;
  const headColors = [
    { name: 'hydraHeadRed', base: '#cc2222', mid: '#ff4444', hi: '#ff8888', glow: 'rgba(255,80,60,', accent: '#ffaa44' },
    { name: 'hydraHeadBlue', base: '#1144aa', mid: '#4488ff', hi: '#88bbff', glow: 'rgba(60,120,255,', accent: '#44ffff' },
    { name: 'hydraHeadPurple', base: '#6622aa', mid: '#cc44ff', hi: '#ee88ff', glow: 'rgba(180,60,255,', accent: '#ff88ff' },
  ];
  for (let hi = 0; hi < 3; hi++) {
    const hc = document.createElement('canvas');
    hc.width = headSize; hc.height = headSize;
    const hx = hc.getContext('2d');
    const cx = headSize / 2, cy = headSize / 2;
    const col = headColors[hi];

    if (hi === 0) {
      // RED — Beam head: angular, slit-eyed, focused
      // Tapered diamond shape
      hx.fillStyle = col.base;
      hx.beginPath();
      hx.moveTo(cx, cy - 22); // top
      hx.lineTo(cx + 16, cy - 6);
      hx.lineTo(cx + 12, cy + 14);
      hx.lineTo(cx, cy + 22); // bottom
      hx.lineTo(cx - 12, cy + 14);
      hx.lineTo(cx - 16, cy - 6);
      hx.closePath();
      hx.fill();
      // Inner shading
      const ig = hx.createRadialGradient(cx, cy - 4, 0, cx, cy, 18);
      ig.addColorStop(0, col.mid + 'aa');
      ig.addColorStop(0.5, col.base + '88');
      ig.addColorStop(1, 'rgba(0,0,0,0)');
      hx.fillStyle = ig;
      hx.beginPath();
      hx.moveTo(cx, cy - 20);
      hx.lineTo(cx + 14, cy - 4);
      hx.lineTo(cx + 10, cy + 12);
      hx.lineTo(cx, cy + 20);
      hx.lineTo(cx - 10, cy + 12);
      hx.lineTo(cx - 14, cy - 4);
      hx.closePath();
      hx.fill();
      // Armored ridges
      hx.strokeStyle = 'rgba(255,120,80,0.2)';
      hx.lineWidth = 1;
      for (let r = 0; r < 4; r++) {
        const ry = cy - 12 + r * 7;
        hx.beginPath();
        hx.moveTo(cx - 12 + r * 2, ry);
        hx.quadraticCurveTo(cx, ry - 2, cx + 12 - r * 2, ry);
        hx.stroke();
      }
      // Central energy slit (beam emitter)
      hx.globalCompositeOperation = 'lighter';
      const slitG = hx.createLinearGradient(cx, cy - 10, cx, cy + 10);
      slitG.addColorStop(0, 'rgba(255,200,150,0)');
      slitG.addColorStop(0.3, 'rgba(255,200,150,0.4)');
      slitG.addColorStop(0.5, 'rgba(255,255,220,0.6)');
      slitG.addColorStop(0.7, 'rgba(255,200,150,0.4)');
      slitG.addColorStop(1, 'rgba(255,200,150,0)');
      hx.fillStyle = slitG;
      hx.beginPath(); hx.ellipse(cx, cy, 2.5, 10, 0, 0, Math.PI * 2); hx.fill();
      // Two smaller side markings
      hx.fillStyle = col.glow + '0.15)';
      hx.beginPath(); hx.arc(cx - 8, cy - 4, 3, 0, Math.PI * 2); hx.fill();
      hx.beginPath(); hx.arc(cx + 8, cy - 4, 3, 0, Math.PI * 2); hx.fill();
    } else if (hi === 1) {
      // BLUE — Breath head: wide jaw, fangs, frost mist
      // Wide rounded trapezoid
      hx.fillStyle = col.base;
      hx.beginPath();
      hx.moveTo(cx - 10, cy - 20);
      hx.lineTo(cx + 10, cy - 20);
      hx.quadraticCurveTo(cx + 22, cy - 10, cx + 20, cy + 4);
      hx.lineTo(cx + 16, cy + 18);
      hx.lineTo(cx - 16, cy + 18);
      hx.lineTo(cx - 20, cy + 4);
      hx.quadraticCurveTo(cx - 22, cy - 10, cx - 10, cy - 20);
      hx.closePath();
      hx.fill();
      // Inner glow
      const ig2 = hx.createRadialGradient(cx, cy - 2, 0, cx, cy, 20);
      ig2.addColorStop(0, col.mid + '99');
      ig2.addColorStop(0.6, col.base + '66');
      ig2.addColorStop(1, 'rgba(0,0,0,0)');
      hx.fillStyle = ig2;
      hx.fill();
      // Jaw opening — dark gap with inner glow
      hx.fillStyle = 'rgba(0,0,10,0.6)';
      hx.beginPath();
      hx.moveTo(cx - 10, cy + 8);
      hx.lineTo(cx + 10, cy + 8);
      hx.lineTo(cx + 6, cy + 18);
      hx.lineTo(cx - 6, cy + 18);
      hx.closePath();
      hx.fill();
      // Jaw inner frost glow
      hx.globalCompositeOperation = 'lighter';
      const jawG = hx.createRadialGradient(cx, cy + 14, 0, cx, cy + 14, 10);
      jawG.addColorStop(0, 'rgba(100,220,255,0.4)');
      jawG.addColorStop(1, 'rgba(60,150,255,0)');
      hx.fillStyle = jawG;
      hx.beginPath(); hx.arc(cx, cy + 14, 10, 0, Math.PI * 2); hx.fill();
      hx.globalCompositeOperation = 'source-over';
      // Fang teeth
      hx.fillStyle = '#ddeeff';
      const fangs = [[-8, 8, -6, 15], [-3, 8, -2, 13], [3, 8, 2, 13], [8, 8, 6, 15]];
      for (const [fx, fy, tx, ty] of fangs) {
        hx.beginPath();
        hx.moveTo(cx + fx - 1.5, cy + fy);
        hx.lineTo(cx + tx, cy + ty);
        hx.lineTo(cx + fx + 1.5, cy + fy);
        hx.closePath();
        hx.fill();
      }
      // Eyes — wide-set, cold
      hx.globalCompositeOperation = 'lighter';
      hx.fillStyle = col.glow + '0.35)';
      hx.beginPath(); hx.ellipse(cx - 8, cy - 6, 4, 3, -0.2, 0, Math.PI * 2); hx.fill();
      hx.beginPath(); hx.ellipse(cx + 8, cy - 6, 4, 3, 0.2, 0, Math.PI * 2); hx.fill();
      // Pupils
      hx.globalCompositeOperation = 'source-over';
      hx.fillStyle = '#001133';
      hx.beginPath(); hx.arc(cx - 8, cy - 6, 1.5, 0, Math.PI * 2); hx.fill();
      hx.beginPath(); hx.arc(cx + 8, cy - 6, 1.5, 0, Math.PI * 2); hx.fill();
    } else {
      // PURPLE — Glob head: bulbous, dripping, organic
      // Large bulb shape
      hx.fillStyle = col.base;
      hx.beginPath();
      hx.arc(cx, cy - 4, 20, 0, Math.PI * 2);
      hx.fill();
      // Lower drip bulge
      hx.beginPath();
      hx.ellipse(cx, cy + 10, 14, 12, 0, 0, Math.PI * 2);
      hx.fill();
      // Inner toxic glow
      const ig3 = hx.createRadialGradient(cx, cy, 0, cx, cy, 22);
      ig3.addColorStop(0, col.mid + 'bb');
      ig3.addColorStop(0.4, col.base + '88');
      ig3.addColorStop(1, 'rgba(30,10,50,0)');
      hx.fillStyle = ig3;
      hx.beginPath(); hx.arc(cx, cy - 2, 20, 0, Math.PI * 2); hx.fill();
      // Bubble/pustule markings
      const pustules = [[cx - 8, cy - 10, 4], [cx + 10, cy - 2, 3.5], [cx - 6, cy + 6, 3], [cx + 5, cy + 12, 2.5], [cx - 12, cy + 2, 2.5]];
      for (const [px, py, pr] of pustules) {
        const pg = hx.createRadialGradient(px - 1, py - 1, 0, px, py, pr);
        pg.addColorStop(0, 'rgba(220,120,255,0.3)');
        pg.addColorStop(0.5, 'rgba(160,60,220,0.15)');
        pg.addColorStop(1, 'rgba(100,30,160,0)');
        hx.fillStyle = pg;
        hx.beginPath(); hx.arc(px, py, pr, 0, Math.PI * 2); hx.fill();
        // Specular highlight
        hx.globalCompositeOperation = 'lighter';
        hx.fillStyle = 'rgba(255,200,255,0.2)';
        hx.beginPath(); hx.arc(px - 1, py - 1, pr * 0.4, 0, Math.PI * 2); hx.fill();
        hx.globalCompositeOperation = 'source-over';
      }
      // Dripping tendrils from bottom
      hx.strokeStyle = 'rgba(120,40,180,0.5)';
      hx.lineWidth = 2;
      hx.lineCap = 'round';
      const drips = [[-6, 18, -8, 28], [0, 20, 2, 30], [6, 18, 8, 26]];
      for (const [dx, dy, ex, ey] of drips) {
        hx.beginPath();
        hx.moveTo(cx + dx, cy + dy);
        hx.quadraticCurveTo(cx + dx + 1, cy + dy + 4, cx + ex, cy + ey);
        hx.stroke();
        // Drip tip
        hx.fillStyle = 'rgba(180,80,255,0.4)';
        hx.beginPath(); hx.arc(cx + ex, cy + ey, 2, 0, Math.PI * 2); hx.fill();
      }
      // Eyes — multiple small eyes, unsettling
      hx.globalCompositeOperation = 'lighter';
      const eyePos = [[cx - 6, cy - 10], [cx + 6, cy - 10], [cx, cy - 14], [cx - 10, cy - 4], [cx + 10, cy - 4]];
      for (let ei = 0; ei < eyePos.length; ei++) {
        const [ex, ey] = eyePos[ei];
        const er = ei < 2 ? 2.5 : 1.5;
        hx.fillStyle = col.glow + '0.3)';
        hx.beginPath(); hx.arc(ex, ey, er, 0, Math.PI * 2); hx.fill();
      }
    }

    hx.globalCompositeOperation = 'source-over';
    // Edge soften — fade edges to transparent
    const hData = hx.getImageData(0, 0, headSize, headSize);
    const hd = hData.data;
    for (let y = 0; y < headSize; y++) {
      for (let x = 0; x < headSize; x++) {
        const dx = (x - cx) / (headSize * 0.42);
        const dy = (y - cy) / (headSize * 0.42);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0.8) {
          const fade = Math.max(0, 1 - (dist - 0.8) / 0.2);
          const i = (y * headSize + x) * 4;
          hd[i + 3] = Math.floor(hd[i + 3] * fade);
        }
      }
    }
    hx.putImageData(hData, 0, 0);
    img[col.name] = hc;
  }

  // --- Neck segment sprites: one per color with scale texture ---
  const segSize = 32;
  const segColors = [
    { name: 'hydraSegRed', dark: '#661515', mid: '#aa2828', hi: '#cc4444', vein: 'rgba(255,100,80,0.15)' },
    { name: 'hydraSegBlue', dark: '#0a2860', mid: '#1e5599', hi: '#3388cc', vein: 'rgba(80,180,255,0.15)' },
    { name: 'hydraSegPurple', dark: '#3a1260', mid: '#6b2e99', hi: '#9944cc', vein: 'rgba(200,100,255,0.15)' },
  ];
  for (let si = 0; si < 3; si++) {
    const sc = document.createElement('canvas');
    sc.width = segSize; sc.height = segSize;
    const sx = sc.getContext('2d');
    const scx = segSize / 2, scy = segSize / 2;
    const col = segColors[si];

    // Base circle with gradient
    const sg = sx.createRadialGradient(scx - 2, scy - 3, 0, scx, scy, 14);
    sg.addColorStop(0, col.hi);
    sg.addColorStop(0.4, col.mid);
    sg.addColorStop(0.8, col.dark);
    sg.addColorStop(1, 'rgba(0,0,0,0)');
    sx.fillStyle = sg;
    sx.beginPath(); sx.arc(scx, scy, 14, 0, Math.PI * 2); sx.fill();

    // Scale overlay — crescent highlight on top
    sx.globalCompositeOperation = 'lighter';
    sx.strokeStyle = col.vein;
    sx.lineWidth = 8;
    sx.beginPath();
    sx.arc(scx, scy + 4, 10, Math.PI * 1.2, Math.PI * 1.8);
    sx.stroke();

    // Specular
    sx.fillStyle = 'rgba(255,255,255,0.08)';
    sx.beginPath(); sx.ellipse(scx - 2, scy - 5, 6, 3, -0.2, 0, Math.PI * 2); sx.fill();

    // Dark underside
    sx.globalCompositeOperation = 'source-over';
    sx.fillStyle = 'rgba(0,0,0,0.15)';
    sx.beginPath(); sx.ellipse(scx, scy + 5, 10, 5, 0, 0, Math.PI * 2); sx.fill();

    // Edge fade
    const sData = sx.getImageData(0, 0, segSize, segSize);
    const sd = sData.data;
    for (let y = 0; y < segSize; y++) {
      for (let x = 0; x < segSize; x++) {
        const dx = (x - scx) / 14;
        const dy = (y - scy) / 14;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0.85) {
          const fade = Math.max(0, 1 - (dist - 0.85) / 0.15);
          const i = (y * segSize + x) * 4;
          sd[i + 3] = Math.floor(sd[i + 3] * fade);
        }
      }
    }
    sx.putImageData(sData, 0, 0);
    img[col.name] = sc;
  }
  } // end if (!hasGrokSprites)

  // --- Glob pool sprite: always generated (no Grok version) ---
  const globSize = 64;
  const globC = document.createElement('canvas');
  globC.width = globSize; globC.height = globSize;
  const gx = globC.getContext('2d');
  const gcx = globSize / 2, gcy = globSize / 2;

  // Irregular pool shape
  gx.fillStyle = '#2a0845';
  gx.beginPath();
  for (let a = 0; a < Math.PI * 2; a += 0.1) {
    const r = 24 + Math.sin(a * 3.7) * 4 + Math.cos(a * 5.3) * 3;
    const px = gcx + Math.cos(a) * r;
    const py = gcy + Math.sin(a) * r;
    if (a === 0) gx.moveTo(px, py); else gx.lineTo(px, py);
  }
  gx.closePath();
  gx.fill();

  // Inner glow
  const poolG = gx.createRadialGradient(gcx, gcy, 0, gcx, gcy, 26);
  poolG.addColorStop(0, 'rgba(180,80,255,0.6)');
  poolG.addColorStop(0.5, 'rgba(120,40,200,0.3)');
  poolG.addColorStop(1, 'rgba(60,20,120,0)');
  gx.globalCompositeOperation = 'lighter';
  gx.fillStyle = poolG;
  gx.beginPath(); gx.arc(gcx, gcy, 26, 0, Math.PI * 2); gx.fill();

  // Surface bubbles (pre-baked positions)
  const bubbles = [[gcx - 8, gcy - 6, 3], [gcx + 6, gcy - 3, 2.5], [gcx - 3, gcy + 8, 2], [gcx + 10, gcy + 4, 2], [gcx - 10, gcy + 2, 1.5]];
  for (const [bx, by, br] of bubbles) {
    const bg = gx.createRadialGradient(bx, by, 0, bx, by, br);
    bg.addColorStop(0, 'rgba(255,200,255,0.3)');
    bg.addColorStop(0.5, 'rgba(200,120,255,0.15)');
    bg.addColorStop(1, 'rgba(150,60,220,0)');
    gx.fillStyle = bg;
    gx.beginPath(); gx.arc(bx, by, br, 0, Math.PI * 2); gx.fill();
  }

  // Edge fade
  const gData = gx.getImageData(0, 0, globSize, globSize);
  const gd = gData.data;
  for (let y = 0; y < globSize; y++) {
    for (let x = 0; x < globSize; x++) {
      const dx = (x - gcx) / 28;
      const dy = (y - gcy) / 28;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 0.8) {
        const fade = Math.max(0, 1 - (dist - 0.8) / 0.2);
        const i = (y * globSize + x) * 4;
        gd[i + 3] = Math.floor(gd[i + 3] * fade);
      }
    }
  }
  gx.putImageData(gData, 0, 0);
  img['hydraGlob'] = globC;
}

// ---- SHIP CONFIGURATIONS ----
const SHIP_CONFIGS = [
  {
    name: 'VANGUARD',
    subtitle: 'BALANCED',
    hp: 5, maxHp: 5, bombs: 3,
    speed: 5, focusSpeed: 2.2,
    hitboxRadius: 3,
    shootDelay: 5,
    color: '#7b68ee',
    drawType: 'foozle',
    desc: ['Versatile all-rounder.', 'Spread shot + full-clear bomb.'],
    stats: { hp: 3, spd: 3, pwr: 3, bmb: 3 }, // 1-5 for display bars
  },
  {
    name: 'TEMPEST',
    subtitle: 'GLASS CANNON',
    hp: 3, maxHp: 3, bombs: 5,
    speed: 6, focusSpeed: 2.5,
    hitboxRadius: 2.5,
    shootDelay: 3,
    color: '#ff4466',
    drawType: 'kenney2',
    baseSprite: 'ship2Base',
    dmgSprites: ['ship2Dmg1', 'ship2Dmg2', 'ship2Dmg3'],
    desc: ['Fast and fragile.', 'Rapid beam + cone bomb.'],
    stats: { hp: 1, spd: 5, pwr: 5, bmb: 4 },
  },
  {
    name: 'BASTION',
    subtitle: 'TANK',
    hp: 8, maxHp: 8, bombs: 2,
    speed: 4, focusSpeed: 1.8,
    hitboxRadius: 4,
    shootDelay: 6,
    color: '#44ff88',
    drawType: 'kenney3',
    baseSprite: 'ship3Base',
    dmgSprites: ['ship3Dmg1', 'ship3Dmg2', 'ship3Dmg3'],
    desc: ['Slow but tough.', 'Wide spread + shield bubble.'],
    stats: { hp: 5, spd: 1, pwr: 2, bmb: 2 },
  },
];

let selectedShip = 0;
let selectAnim = 0; // animation timer for select screen

// ---- GAME STATE ----
let gameState = 'loading';
let score = 0;
let hiScore = parseInt(localStorage.getItem('stellarHiScore') || '0');
let wave = 0;
let waveTimer = 0;
let shakeTimer = 0;
let shakeIntensity = 0;
let slowmoTimer = 0;
let globalTime = 0;
let graze = 0;

// ---- ROGUELIKE STATE ----
const runPowerups = { collected: {}, secondWindUsed: false, bossesDefeated: 0 };
let powerupChoices = [];
let powerupSelectActive = false;
let powerupCollectedThisBoss = false;
let powerupAnnouncement = null;
let resolvedMods = {
  damageMult: 1, shootDelayMult: 1, bulletSpeedMult: 1,
  speedMult: 1, focusSpeedMult: 1, focusDamageMult: 1,
  collectRadiusMult: 1, grazeRadiusBonus: 0, grazeScoreMult: 1,
  scoreKillMult: 1, invincBonus: 0, bombDamageMult: 1,
  pierceCount: 0, homingStrength: 0, backfireStreams: 0,
  splitOnHit: false, autoBomb: false, secondWind: false,
  orbitalBlades: 0, bulletEatChance: 0,
  chainTargets: 0, chainDamagePct: 0,
  maxHpBonus: 0, maxHpOverride: null,
};

// ---- CAMPAIGN / MODE STATE ----
let gameMode = 'endless'; // 'endless', 'campaign', or 'bossfight'
let modeSelectIndex = 0;  // 0 = endless, 1 = campaign, 2 = boss fight
let bossSelectIndex = 0;  // which boss is highlighted in boss fight mode
let bossFightType = null;  // boss type to spawn in boss fight mode
const BOSS_FIGHT_LIST = [
  { type: 4, name: 'DRIFT JELLYFISH', color: '#44ffee', hp: 80, desc: 'Miniboss 1-1', icon: 'M' },
  { type: 5, name: 'IRON SCARAB', color: '#ff8800', hp: 120, desc: 'Miniboss 1-2', icon: 'M' },
  { type: 6, name: 'NEBULA SERPENT', color: '#22ff66', hp: 220, desc: 'Miniboss 1-3', icon: 'M' },
  { type: 1, name: 'CRIMSON MOTH', color: '#ff4466', hp: 250, desc: 'Boss — Wave 5', icon: 'B' },
  { type: 7, name: 'PLASMA SENTINEL', color: '#4488ff', hp: 220, desc: 'Miniboss 1-4', icon: 'M' },
  { type: 8, name: 'VOID HYDRA', color: '#cc44ff', hp: 200, desc: 'Miniboss 1-5', icon: 'M' },
  { type: 2, name: 'VOID EMPRESS', color: '#aa44ff', hp: 400, desc: 'Boss — Wave 10', icon: 'B' },
  { type: 3, name: 'STELLAR DRAGON', color: '#ffaa00', hp: 600, desc: 'Boss — Wave 15', icon: 'B' },
];
let campaignLevel = null;  // current level def when in campaign
let campaignWaveIndex = 0; // which wave in the level's sequence
let campaignTotalWaves = 0;
let campaignWaveActive = false; // enemies from current wave still alive
let campaignComplete = false;   // all waves done + enemies dead
let levelScore = 0;
let levelDeaths = 0;
let levelDamageTaken = 0;
let equipSelectSlot = null;    // which slot is selected in ship view
let equipSelectIndex = 0;      // cursor in inventory grid
let levelSelectIndex = 0;      // which level is highlighted
let levelDoneTimer = 0;        // frames since level done screen appeared
let levelDoneHover = null;     // 'next' or 'select' — which button is hovered

// ---- SAVE SYSTEM ----
const SAVE_KEY = 'stellarDanmakuSave';
const DEFAULT_SAVE = {
  version: 1,
  chaptersUnlocked: 1,
  levels: {},
  inventory: [],
  equipped: { weapon1: null, weapon2: null, armor: null, wings: null, engine: null, accessory1: null, accessory2: null }
};

function loadSave() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return JSON.parse(JSON.stringify(DEFAULT_SAVE));
    const data = JSON.parse(raw);
    // merge missing fields from default
    for (const k of Object.keys(DEFAULT_SAVE)) {
      if (!(k in data)) data[k] = JSON.parse(JSON.stringify(DEFAULT_SAVE[k]));
    }
    if (!data.equipped) data.equipped = { ...DEFAULT_SAVE.equipped };
    return data;
  } catch (e) {
    return JSON.parse(JSON.stringify(DEFAULT_SAVE));
  }
}

function writeSave() {
  try { localStorage.setItem(SAVE_KEY, JSON.stringify(saveData)); } catch(e) {}
}

let saveData = loadSave();

// ---- INPUT ----
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key === 'Enter') {
    if (gameState === 'title') showModeSelect();
    else if (gameState === 'modeselect') confirmModeSelect();
    else if (gameState === 'bossselect') confirmBossSelect();
    else if (gameState === 'select') startGame();
    else if (gameState === 'gameover') { if (gameMode === 'bossfight') showBossSelect(); else showModeSelect(); }
    else if (gameState === 'levelselect') startCampaignLevel();
    else if (gameState === 'leveldone') showLevelSelect();
    else if (gameState === 'shipview') { gameState = 'levelselect'; equipSelectSlot = null; }
  }
  if (e.key === 'Escape' || e.key === 'Backspace') {
    if (gameState === 'select') { if (gameMode === 'bossfight') showBossSelect(); else showModeSelect(); }
    else if (gameState === 'bossselect') showModeSelect();
    else if (gameState === 'levelselect') showModeSelect();
    else if (gameState === 'shipview') { gameState = 'levelselect'; equipSelectSlot = null; }
    else if (gameState === 'leveldone') showLevelSelect();
  }
  if (gameState === 'modeselect') {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
      modeSelectIndex = (modeSelectIndex + 2) % 3;
    }
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
      modeSelectIndex = (modeSelectIndex + 1) % 3;
    }
  }
  if (gameState === 'bossselect') {
    if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
      bossSelectIndex = (bossSelectIndex + BOSS_FIGHT_LIST.length - 1) % BOSS_FIGHT_LIST.length;
    }
    if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
      bossSelectIndex = (bossSelectIndex + 1) % BOSS_FIGHT_LIST.length;
    }
  }
  if (gameState === 'select') {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
      selectedShip = (selectedShip + SHIP_CONFIGS.length - 1) % SHIP_CONFIGS.length;
    }
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
      selectedShip = (selectedShip + 1) % SHIP_CONFIGS.length;
    }
  }
  if (gameState === 'levelselect') {
    const chapter = CAMPAIGN_CHAPTERS[1];
    if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
      levelSelectIndex = Math.max(0, levelSelectIndex - 1);
    }
    if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
      levelSelectIndex = Math.min(chapter.levels.length - 1, levelSelectIndex + 1);
    }
    // S key for ship view
    if (e.key.toLowerCase() === 'e') {
      gameState = 'shipview';
      equipSelectSlot = null;
      equipSelectIndex = 0;
    }
  }
  if (e.key !== 'F5' && e.key !== 'F12') e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

function showModeSelect() {
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';
  gameState = 'modeselect';
  selectAnim = 0;
  resetTouchState();
}

function confirmModeSelect() {
  if (modeSelectIndex === 0) {
    gameMode = 'endless';
    showSelectScreen();
  } else if (modeSelectIndex === 1) {
    gameMode = 'campaign';
    showLevelSelect();
  } else {
    showBossSelect();
  }
}

function showBossSelect() {
  gameState = 'bossselect';
  selectAnim = 0;
  resetTouchState();
  document.getElementById('game-over').style.display = 'none';
}

function confirmBossSelect() {
  gameMode = 'bossfight';
  bossFightType = BOSS_FIGHT_LIST[bossSelectIndex].type;
  showSelectScreen();
}

function showSelectScreen() {
  gameState = 'select';
  selectAnim = 0;
  resetTouchState();
}

function showLevelSelect() {
  gameState = 'levelselect';
  selectAnim = 0;
  resetTouchState();
}

function resetTouchState() {
  touch.dragId = null;
  touch.active = false;
  touch.dx = 0;
  touch.dy = 0;
  touch.focus = false;
  touch.bomb = false;
  touch.btnIds.clear();
}

function isLevelUnlocked(levelId) {
  if (levelId === '1-1') return true;
  // Unlock next level when previous is cleared
  const chapter = CAMPAIGN_CHAPTERS[1];
  const idx = chapter.levels.findIndex(l => l.id === levelId);
  if (idx <= 0) return true;
  const prevId = chapter.levels[idx - 1].id;
  return saveData.levels[prevId] && saveData.levels[prevId].cleared;
}

function startCampaignLevel() {
  const chapter = CAMPAIGN_CHAPTERS[1];
  const level = chapter.levels[levelSelectIndex];
  if (!level || !isLevelUnlocked(level.id)) return;
  campaignLevel = level;
  campaignWaveIndex = 0;
  campaignTotalWaves = level.waves.length;
  campaignWaveActive = false;
  campaignComplete = false;
  levelScore = 0;
  levelDeaths = 0;
  levelDamageTaken = 0;
  gameMode = 'campaign';
  startGame();
}

function getCanvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scale = canvas._scale || 1;
  return { x: (clientX - rect.left) / scale, y: (clientY - rect.top) / scale };
}

function handleCanvasInput(clientX, clientY) {
  const { x: cx, y: cy } = getCanvasCoords(clientX, clientY);

  if (gameState === 'title') { showModeSelect(); return; }
  if (gameState === 'gameover') { if (gameMode === 'bossfight') showBossSelect(); else showModeSelect(); return; }

  if (gameState === 'modeselect') {
    // Three panels side by side
    if (cy > 140 && cy < 420) {
      const panelW = 135, gap = 12;
      const totalW = 3 * panelW + 2 * gap;
      const startX = (W - totalW) / 2;
      const idx = Math.floor((cx - startX) / (panelW + gap));
      if (idx >= 0 && idx < 3) {
        modeSelectIndex = idx;
        confirmModeSelect();
      }
    }
    return;
  }

  if (gameState === 'bossselect') {
    const rowH = 72, startY = 95;
    for (let i = 0; i < BOSS_FIGHT_LIST.length; i++) {
      const ry = startY + i * rowH;
      if (cy > ry && cy < ry + rowH - 6 && cx > 30 && cx < W - 30) {
        if (bossSelectIndex === i) confirmBossSelect();
        else bossSelectIndex = i;
        return;
      }
    }
    return;
  }

  if (gameState === 'select') {
    const panelW = W / 3;
    if (cy > 80 && cy < 600) {
      const tapped = Math.floor(cx / panelW);
      if (tapped >= 0 && tapped < 3) {
        if (tapped === selectedShip) startGame();
        else selectedShip = tapped;
      }
    }
    if (cy > 600) startGame();
    return;
  }

  if (gameState === 'levelselect') {
    // Level list area
    const chapter = CAMPAIGN_CHAPTERS[1];
    const startY = 140;
    for (let i = 0; i < chapter.levels.length; i++) {
      const ly = startY + i * 75;
      if (cy > ly && cy < ly + 65 && cx > 40 && cx < W - 40) {
        if (isLevelUnlocked(chapter.levels[i].id)) {
          if (levelSelectIndex === i) {
            startCampaignLevel();
          } else {
            levelSelectIndex = i;
          }
        }
        return;
      }
    }
    // Ship view button
    if (cy > 620 && cy < 680 && cx > 40 && cx < 230) {
      gameState = 'shipview';
      equipSelectSlot = null;
      equipSelectIndex = 0;
    }
    // Back button
    if (cy > 620 && cy < 680 && cx > 250 && cx < W - 40) {
      showModeSelect();
    }
    return;
  }

  if (gameState === 'shipview') {
    handleShipViewTap(cx, cy);
    return;
  }

  if (gameState === 'leveldone') {
    const btnY = 500, btnH = 50, btnW = W / 2 - 50;
    // Next level button
    if (cy > btnY && cy < btnY + btnH && cx > 40 && cx < 40 + btnW) {
      const chapter = CAMPAIGN_CHAPTERS[1];
      const idx = chapter.levels.findIndex(l => l.id === campaignLevel.id);
      if (idx < chapter.levels.length - 1) {
        levelSelectIndex = idx + 1;
        startCampaignLevel();
      } else {
        showLevelSelect();
      }
    }
    // Level select button
    if (cy > btnY && cy < btnY + btnH && cx > W / 2 + 10 && cx < W / 2 + 10 + btnW) {
      showLevelSelect();
    }
    return;
  }
}

canvas.addEventListener('click', (e) => {
  handleCanvasInput(e.clientX, e.clientY);
});
canvas.addEventListener('touchend', (e) => {
  const t = e.changedTouches[0];
  if (!t) return;
  handleCanvasInput(t.clientX, t.clientY);
}, { passive: true });

// Hover tracking for button feedback
function updateLevelDoneHover(clientX, clientY) {
  if (gameState !== 'leveldone') { levelDoneHover = null; return; }
  const { x: cx, y: cy } = getCanvasCoords(clientX, clientY);
  const btnY = 500, btnH = 50, btnW = W / 2 - 50;
  if (cy > btnY && cy < btnY + btnH && cx > 40 && cx < 40 + btnW) {
    levelDoneHover = 'next';
  } else if (cy > btnY && cy < btnY + btnH && cx > W / 2 + 10 && cx < W / 2 + 10 + btnW) {
    levelDoneHover = 'select';
  } else {
    levelDoneHover = null;
  }
}
canvas.addEventListener('mousemove', (e) => updateLevelDoneHover(e.clientX, e.clientY));
canvas.addEventListener('touchstart', (e) => {
  const t = e.touches[0];
  if (t) updateLevelDoneHover(t.clientX, t.clientY);
}, { passive: true });
document.getElementById('title-screen').addEventListener('click', () => showModeSelect());
document.getElementById('title-screen').addEventListener('touchend', () => showModeSelect());
document.getElementById('game-over').addEventListener('click', () => showModeSelect());
document.getElementById('game-over').addEventListener('touchend', () => showModeSelect());

// ---- TOUCH CONTROLS ----
const touch = {
  active: false,
  dragId: null,
  lastX: 0, lastY: 0,
  dx: 0, dy: 0,
  focus: false,
  bomb: false,
  btnIds: new Set(),
};

const dragZone = document.getElementById('drag-zone');
const btnFocus = document.getElementById('btn-focus');
const btnBomb = document.getElementById('btn-bomb');
const touchControls = document.getElementById('touch-controls');
const autoFireIndicator = document.getElementById('auto-fire-indicator');

function screenToGame(screenPx) {
  return screenPx / (canvas._scale || 1);
}

// Drag is now handled at document level (see above).
// Buttons use stopPropagation so their touches don't become drags.

btnFocus.addEventListener('touchstart', e => {
  e.stopPropagation();
  for (const t of e.changedTouches) touch.btnIds.add(t.identifier);
  touch.focus = true;
  btnFocus.classList.add('pressed');
}, { passive: true });
btnFocus.addEventListener('touchend', e => {
  e.stopPropagation();
  for (const t of e.changedTouches) touch.btnIds.delete(t.identifier);
  touch.focus = false;
  btnFocus.classList.remove('pressed');
}, { passive: true });
btnFocus.addEventListener('touchcancel', e => {
  for (const t of e.changedTouches) touch.btnIds.delete(t.identifier);
  touch.focus = false;
  btnFocus.classList.remove('pressed');
}, { passive: true });

btnBomb.addEventListener('touchstart', e => {
  e.stopPropagation();
  for (const t of e.changedTouches) touch.btnIds.add(t.identifier);
  touch.bomb = true;
  btnBomb.classList.add('pressed');
}, { passive: true });
btnBomb.addEventListener('touchend', e => {
  e.stopPropagation();
  for (const t of e.changedTouches) touch.btnIds.delete(t.identifier);
  touch.bomb = false;
  btnBomb.classList.remove('pressed');
}, { passive: true });
btnBomb.addEventListener('touchcancel', e => {
  for (const t of e.changedTouches) touch.btnIds.delete(t.identifier);
  touch.bomb = false;
  btnBomb.classList.remove('pressed');
}, { passive: true });

// ---- PLAYER ----
const player = {
  x: W / 2, y: H - 80,
  w: 28, h: 28,
  hitboxRadius: 3,
  speed: 5,
  focusSpeed: 2.2,
  hp: 5,
  maxHp: 5,
  shootTimer: 0,
  shootDelay: 5,
  power: 1,
  bombs: 3,
  invincible: 0,
  deathAnim: 0,
  alive: true,
  options: [],
  engineFrame: 0,
  engineTimer: 0,
};

// ---- COLLECTIONS ----
let playerBullets = [];
let enemies = [];
let enemyBullets = [];
let particles = [];
let items = [];
let bgStars = [];      // parallax star layers
let bgMeteors = [];     // decorative meteors
let bosses = [];
let fireSprites = [];   // sprite-based explosion effects

// ---- SCROLLING BACKGROUND ----
let bgScrollY = 0;

function initBackground() {
  bgStars = [];
  // 3 layers of parallax stars
  for (let layer = 0; layer < 3; layer++) {
    for (let i = 0; i < 30 + layer * 15; i++) {
      bgStars.push({
        x: Math.random() * W,
        y: Math.random() * H,
        speed: 0.3 + layer * 0.6 + Math.random() * 0.5,
        size: 0.5 + layer * 0.8 + Math.random() * 0.5,
        brightness: 0.2 + layer * 0.2 + Math.random() * 0.3,
        layer,
        twinkle: Math.random() * Math.PI * 2,
      });
    }
  }
  // Decorative meteors
  bgMeteors = [];
  for (let i = 0; i < 4; i++) {
    bgMeteors.push({
      x: Math.random() * W,
      y: Math.random() * H,
      speed: 0.4 + Math.random() * 0.8,
      rot: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.02,
      type: Math.floor(Math.random() * 3),
      size: 8 + Math.random() * 12,
      alpha: 0.2 + Math.random() * 0.3,
    });
  }
}

// ---- COLORS ----
const COLORS = {
  playerShot: '#00ffff',
  playerGlow: '#7b68ee',
  enemy1: '#ff6ec7',
  enemy2: '#ff9944',
  enemy3: '#44ff88',
  boss: '#ff4444',
  bulletPink: '#ff6ec7',
  bulletCyan: '#00ffff',
  bulletYellow: '#ffff44',
  bulletGreen: '#44ff88',
  bulletOrange: '#ff9944',
  bulletPurple: '#bb66ff',
  bulletWhite: '#ffffff',
  bulletRed: '#ff4444',
  powerItem: '#ff4444',
  scoreItem: '#44aaff',
  bombItem: '#44ff44',
};

// ---- RARITY & ROGUELIKE POWERUPS ----
const RARITY = {
  COMMON:    { name: 'COMMON',    color: '#88bbff', weight: 60 },
  UNCOMMON:  { name: 'UNCOMMON',  color: '#44ff88', weight: 25 },
  RARE:      { name: 'RARE',      color: '#ff66cc', weight: 12 },
  LEGENDARY: { name: 'LEGENDARY', color: '#ffaa22', weight: 3 },
};

const ROGUELIKE_POWERUPS = [
  // WEAPONS
  { id: 'rapid_fire', name: 'RAPID FIRE', desc: 'Shoot 15% faster', icon: '>>', category: 'weapon',
    rarity: RARITY.COMMON, stackable: true, maxStacks: 4,
    effect: s => ({ shootDelayMult: 1 - s * 0.15 }) },
  { id: 'heavy_caliber', name: 'HEAVY CALIBER', desc: '+20% damage, -10% bullet speed', icon: '(!)', category: 'weapon',
    rarity: RARITY.COMMON, stackable: true, maxStacks: 5,
    effect: s => ({ damageMult: 1 + s * 0.2, bulletSpeedMult: 1 - s * 0.1 }) },
  { id: 'backfire', name: 'BACKFIRE ENGINE', desc: 'Fire weak bullets backwards', icon: '<>', category: 'weapon',
    rarity: RARITY.COMMON, stackable: true, maxStacks: 3,
    effect: s => ({ backfireStreams: s }) },
  { id: 'piercing_shots', name: 'PIERCING ROUNDS', desc: 'Bullets pierce +1 enemy', icon: '|>', category: 'weapon',
    rarity: RARITY.UNCOMMON, stackable: true, maxStacks: 3,
    effect: s => ({ pierceCount: s }) },
  { id: 'homing_rounds', name: 'HOMING ROUNDS', desc: 'Side bullets track enemies', icon: '~>', category: 'weapon',
    rarity: RARITY.UNCOMMON, stackable: true, maxStacks: 3,
    effect: s => ({ homingStrength: s * 0.02 }) },
  { id: 'splitshot', name: 'SPLIT SHOT', desc: 'Main bullets fork into 2 on hit', icon: 'Y', category: 'weapon',
    rarity: RARITY.RARE, stackable: false, maxStacks: 1,
    effect: () => ({ splitOnHit: true }) },
  { id: 'orbital_blades', name: 'ORBITAL BLADES', desc: 'Spinning blades orbit your ship', icon: '\u2726', category: 'weapon',
    rarity: RARITY.LEGENDARY, stackable: true, maxStacks: 3,
    effect: s => ({ orbitalBlades: s }) },

  // DEFENSE
  { id: 'hull_plating', name: 'HULL PLATING', desc: '+1 max HP and heal 1', icon: '+', category: 'defense',
    rarity: RARITY.COMMON, stackable: true, maxStacks: 5,
    effect: s => ({ maxHpBonus: s }),
    onPickup: () => { player.maxHp++; player.hp = Math.min(player.hp + 1, player.maxHp); } },
  { id: 'phase_armor', name: 'PHASE ARMOR', desc: '+30 invincibility frames on hit', icon: '()', category: 'defense',
    rarity: RARITY.UNCOMMON, stackable: true, maxStacks: 3,
    effect: s => ({ invincBonus: s * 30 }) },
  { id: 'bomb_synthesis', name: 'BOMB SYNTHESIS', desc: '+1 bomb, bombs deal +25% dmg', icon: 'B+', category: 'defense',
    rarity: RARITY.UNCOMMON, stackable: true, maxStacks: 3,
    effect: s => ({ bombDamageMult: 1 + s * 0.25 }),
    onPickup: () => { player.bombs = Math.min(player.bombs + 1, 9); } },
  { id: 'auto_bomb', name: 'AUTO BOMB', desc: 'Auto-bomb when hit', icon: 'AB', category: 'defense',
    rarity: RARITY.RARE, stackable: false, maxStacks: 1,
    effect: () => ({ autoBomb: true }) },
  { id: 'second_wind', name: 'SECOND WIND', desc: 'Revive once with 2 HP on death', icon: '\u2665\u2665', category: 'defense',
    rarity: RARITY.LEGENDARY, stackable: false, maxStacks: 1,
    effect: () => ({ secondWind: true }) },

  // UTILITY
  { id: 'magnet_field', name: 'MAGNET FIELD', desc: 'Double item attraction radius', icon: 'U', category: 'utility',
    rarity: RARITY.COMMON, stackable: true, maxStacks: 3,
    effect: s => ({ collectRadiusMult: 1 + s }) },
  { id: 'speed_boost', name: 'AFTERBURNER', desc: '+10% move speed', icon: '^', category: 'utility',
    rarity: RARITY.COMMON, stackable: true, maxStacks: 4,
    effect: s => ({ speedMult: 1 + s * 0.1 }) },
  { id: 'score_streak', name: 'SCORE STREAK', desc: '+25% kill score', icon: '$', category: 'utility',
    rarity: RARITY.COMMON, stackable: true, maxStacks: 4,
    effect: s => ({ scoreKillMult: 1 + s * 0.25 }) },
  { id: 'graze_master', name: 'GRAZE MASTER', desc: '+50% graze radius, graze score x2', icon: '~', category: 'utility',
    rarity: RARITY.UNCOMMON, stackable: true, maxStacks: 3,
    effect: s => ({ grazeRadiusBonus: s * 10, grazeScoreMult: 1 + s }) },
  { id: 'focus_power', name: 'FOCUS POWER', desc: '+30% dmg while focused, +15% focus speed', icon: 'F+', category: 'utility',
    rarity: RARITY.UNCOMMON, stackable: true, maxStacks: 3,
    effect: s => ({ focusDamageMult: 1 + s * 0.3, focusSpeedMult: 1 + s * 0.15 }) },

  // SPECIAL
  { id: 'bullet_eater', name: 'BULLET EATER', desc: '10% chance graze destroys bullet + heals 1', icon: '\u00d8', category: 'special',
    rarity: RARITY.RARE, stackable: true, maxStacks: 2,
    effect: s => ({ bulletEatChance: s * 0.10 }) },
  { id: 'chain_lightning', name: 'CHAIN LIGHTNING', desc: 'Kills zap nearby enemies for 30% dmg', icon: 'ZZ', category: 'special',
    rarity: RARITY.RARE, stackable: true, maxStacks: 2,
    effect: s => ({ chainTargets: s + 1, chainDamagePct: 0.30 }) },
  { id: 'void_reaper', name: 'VOID REAPER', desc: '+50% all damage. Max HP becomes 1.', icon: '\u2620', category: 'special',
    rarity: RARITY.LEGENDARY, stackable: false, maxStacks: 1,
    effect: () => ({ damageMult: 1.5, maxHpOverride: 1 }),
    onPickup: () => { player.maxHp = 1; player.hp = 1; } },
];

// ---- CAMPAIGN SHIP ----
const CAMPAIGN_SHIP = {
  name: 'PIONEER', subtitle: 'STANDARD-ISSUE',
  hp: 4, maxHp: 4, bombs: 2,
  speed: 4.5, focusSpeed: 2,
  hitboxRadius: 3, shootDelay: 7,
  color: '#88aacc',
  drawType: 'kenney2',
  baseSprite: 'ship2Base',
  dmgSprites: ['ship2Dmg1', 'ship2Dmg2', 'ship2Dmg3'],
  desc: ['Basic fighter.', 'Equip gear to grow.'],
  stats: { hp: 2, spd: 2, pwr: 1, bmb: 2 },
};

// ---- EQUIPMENT SYSTEM ----
const EQUIP_RARITY = {
  common:    { name: 'COMMON',    color: '#aaaaaa', weight: 50 },
  uncommon:  { name: 'UNCOMMON',  color: '#44cc44', weight: 30 },
  rare:      { name: 'RARE',      color: '#4488ff', weight: 15 },
  epic:      { name: 'EPIC',      color: '#aa44ff', weight: 4 },
  legendary: { name: 'LEGENDARY', color: '#ffaa00', weight: 1 },
};

const EQUIPMENT_DEFS = {
  // ═══ WEAPONS (2 slots) ═══
  wpn_pulse_laser:     { name: 'Pulse Laser',      slot: 'weapon',    rarity: 'common',    desc: '+1 stream, -10% delay',    icon: '\u2502', effect: m => { m.shootDelayMult *= 0.9; m.extraStreams = (m.extraStreams||0) + 1; } },
  wpn_scatter_gun:     { name: 'Scatter Gun',      slot: 'weapon',    rarity: 'common',    desc: '+2 angled shots',          icon: '\u2571', effect: m => { m.sideShots = (m.sideShots||0) + 2; } },
  wpn_plasma_repeater: { name: 'Plasma Repeater',  slot: 'weapon',    rarity: 'uncommon',  desc: '-25% delay, +15% dmg',     icon: '\u00BB', effect: m => { m.shootDelayMult *= 0.75; m.damageMult *= 1.15; } },
  wpn_homing_pods:     { name: 'Homing Pods',      slot: 'weapon',    rarity: 'uncommon',  desc: '+2 homing missiles',       icon: '~',  effect: m => { m.homingStrength += 0.04; m.sideShots = (m.sideShots||0) + 2; } },
  wpn_railgun:         { name: 'Railgun',          slot: 'weapon',    rarity: 'rare',      desc: '+80% dmg, +2 pierce',      icon: '\u2550', effect: m => { m.damageMult *= 1.8; m.pierceCount += 2; m.shootDelayMult *= 1.3; } },
  wpn_beam_cannon:     { name: 'Beam Cannon',      slot: 'weapon',    rarity: 'rare',      desc: 'x3 focus dmg, +1 pierce',  icon: '\u2503', effect: m => { m.focusDamageMult *= 3; m.pierceCount += 1; } },
  wpn_void_launcher:   { name: 'Void Launcher',    slot: 'weapon',    rarity: 'epic',      desc: 'AoE shots, +40% dmg',      icon: '\u2734', effect: m => { m.splitOnHit = true; m.damageMult *= 1.4; } },

  // ═══ ARMOR (1 slot) ═══
  arm_steel_plate:   { name: 'Steel Plating',    slot: 'armor',  rarity: 'common',    desc: '+2 max HP',                icon: '\u25A0', effect: m => { m.maxHpBonus += 2; } },
  arm_reactive_hull: { name: 'Reactive Hull',    slot: 'armor',  rarity: 'common',    desc: '+1 HP, +20 inv frames',    icon: '\u25A3', effect: m => { m.maxHpBonus += 1; m.invincBonus += 20; } },
  arm_nano_repair:   { name: 'Nano Repair',      slot: 'armor',  rarity: 'uncommon',  desc: 'Regen 1 HP / 45s',         icon: '+',  effect: m => { m.regenInterval = 2700; } },
  arm_mirror_coat:   { name: 'Mirror Coating',   slot: 'armor',  rarity: 'rare',      desc: '+3 HP, 15% reflect',       icon: '\u25C7', effect: m => { m.maxHpBonus += 3; m.reflectChance = 0.15; } },
  arm_phase_shield:  { name: 'Phase Shield',     slot: 'armor',  rarity: 'epic',      desc: 'Auto-bomb on lethal, +4HP', icon: '\u2742', effect: m => { m.autoBomb = true; m.maxHpBonus += 4; } },

  // ═══ WINGS (1 slot) ═══
  wng_stabilizers:    { name: 'Stabilizer Fins',  slot: 'wings', rarity: 'common',    desc: '+15% speed',                icon: '\u2190', effect: m => { m.speedMult *= 1.15; } },
  wng_swept_wings:    { name: 'Swept Wings',      slot: 'wings', rarity: 'common',    desc: '+10% spd, smaller hitbox',  icon: '\u2194', effect: m => { m.speedMult *= 1.1; m.hitboxShrink = (m.hitboxShrink||0) + 0.5; } },
  wng_phantom_wings:  { name: 'Phantom Wings',    slot: 'wings', rarity: 'uncommon',  desc: '+25% focus speed',          icon: '\u2591', effect: m => { m.focusSpeedMult *= 1.25; } },
  wng_vector_thrust:  { name: 'Vector Thrust',    slot: 'wings', rarity: 'rare',      desc: '+30% spd, +20% focus spd',  icon: '\u21C9', effect: m => { m.speedMult *= 1.3; m.focusSpeedMult *= 1.2; m.hitboxShrink = (m.hitboxShrink||0) + 1; } },
  wng_blink_drive:    { name: 'Blink Drive',      slot: 'wings', rarity: 'epic',      desc: '+50% spd, +40% focus',      icon: '\u21AF', effect: m => { m.speedMult *= 1.5; m.focusSpeedMult *= 1.4; } },

  // ═══ ENGINE (1 slot) ═══
  eng_intake_fan:    { name: 'Intake Fan',        slot: 'engine', rarity: 'common',    desc: '+50% collect radius',        icon: '\u00A4', effect: m => { m.collectRadiusMult *= 1.5; } },
  eng_graze_turbine: { name: 'Graze Turbine',     slot: 'engine', rarity: 'common',    desc: '+20 graze, x1.5 graze pts',  icon: '\u2248', effect: m => { m.grazeRadiusBonus += 20; m.grazeScoreMult *= 1.5; } },
  eng_fusion_core:   { name: 'Fusion Core',       slot: 'engine', rarity: 'uncommon',  desc: '+30% focus dmg, 2x collect',  icon: '\u2299', effect: m => { m.focusDamageMult *= 1.3; m.collectRadiusMult *= 2; } },
  eng_overcharge:    { name: 'Overcharge Reactor', slot: 'engine', rarity: 'rare',      desc: '-30% shoot delay',           icon: '\u26A1', effect: m => { m.shootDelayMult *= 0.7; } },
  eng_dark_matter:   { name: 'Dark Matter Engine', slot: 'engine', rarity: 'epic',      desc: '+40 graze, x2 graze pts',    icon: '\u2604', effect: m => { m.grazeRadiusBonus += 40; m.grazeScoreMult *= 2; } },

  // ═══ ACCESSORIES (2 slots) ═══
  acc_score_chip:       { name: 'Score Chip',       slot: 'accessory', rarity: 'common',    desc: '+30% kill score',            icon: '$',  effect: m => { m.scoreKillMult *= 1.3; } },
  acc_bomb_pack:        { name: 'Bomb Satchel',     slot: 'accessory', rarity: 'common',    desc: '+2 bombs, +15% bomb dmg',    icon: 'B',  effect: m => { m.bombBonus = (m.bombBonus||0) + 2; m.bombDamageMult *= 1.15; } },
  acc_lucky_charm:      { name: 'Lucky Charm',      slot: 'accessory', rarity: 'uncommon',  desc: '+25% item drops',            icon: '\u2663', effect: m => { m.dropRateMult = (m.dropRateMult||1) * 1.25; } },
  acc_orbital_drone:    { name: 'Orbital Drone',    slot: 'accessory', rarity: 'rare',      desc: 'Drone fires at enemies',     icon: '\u25CB', effect: m => { m.orbitalBlades += 1; } },
  acc_chain_amplifier:  { name: 'Chain Amplifier',  slot: 'accessory', rarity: 'rare',      desc: 'Kills zap 2 nearby',         icon: '\u2301', effect: m => { m.chainTargets += 2; m.chainDamagePct = Math.max(m.chainDamagePct||0, 0.4); } },
  acc_soul_siphon:      { name: 'Soul Siphon',      slot: 'accessory', rarity: 'epic',      desc: '8% kill heal chance',        icon: '\u2665', effect: m => { m.killHealChance = (m.killHealChance||0) + 0.08; } },
  acc_void_cloak:       { name: 'Void Cloak',       slot: 'accessory', rarity: 'legendary', desc: 'Revive once with 1HP',       icon: '\u2726', effect: m => { m.secondWind = true; } },
};

// ---- LOOT TABLES ----
const LOOT_WEIGHTS = {
  miniboss: { common: 50, uncommon: 35, rare: 12, epic: 3, legendary: 0 },
  boss:     { common: 20, uncommon: 35, rare: 30, epic: 12, legendary: 3 },
};

const LEVEL_LOOT_POOLS = {
  '1-1': ['arm_steel_plate', 'wng_stabilizers', 'eng_intake_fan', 'acc_score_chip', 'wpn_pulse_laser'],
  '1-2': ['arm_steel_plate', 'wng_stabilizers', 'eng_intake_fan', 'acc_score_chip', 'wpn_pulse_laser',
           'wpn_scatter_gun', 'acc_bomb_pack', 'eng_graze_turbine'],
  '1-3': ['arm_steel_plate', 'wng_stabilizers', 'eng_intake_fan', 'acc_score_chip', 'wpn_pulse_laser',
           'arm_reactive_hull', 'wpn_scatter_gun', 'acc_bomb_pack', 'eng_graze_turbine',
           'wpn_plasma_repeater', 'wng_phantom_wings', 'eng_fusion_core', 'acc_lucky_charm'],
  '1-4': ['arm_reactive_hull', 'wpn_scatter_gun', 'acc_bomb_pack', 'eng_graze_turbine',
           'wpn_plasma_repeater', 'wng_phantom_wings', 'eng_fusion_core', 'acc_lucky_charm',
           'wpn_railgun', 'arm_mirror_coat'],
  '1-5': ['wpn_plasma_repeater', 'wng_phantom_wings', 'eng_fusion_core', 'acc_lucky_charm',
           'wpn_railgun', 'arm_mirror_coat', 'wng_vector_thrust', 'eng_overcharge',
           'wpn_beam_cannon', 'acc_chain_amplifier'],
  '1-6': ['wpn_railgun', 'arm_mirror_coat', 'wng_vector_thrust', 'eng_overcharge',
           'wpn_beam_cannon', 'acc_chain_amplifier', 'acc_orbital_drone',
           'wpn_void_launcher', 'arm_phase_shield', 'wng_blink_drive',
           'eng_dark_matter', 'acc_soul_siphon', 'acc_void_cloak',
           'wpn_homing_pods', 'arm_nano_repair', 'wng_swept_wings'],
};

function rollLoot(lootType, levelId) {
  const weights = LOOT_WEIGHTS[lootType];
  const pool = LEVEL_LOOT_POOLS[levelId];
  if (!weights || !pool) return null;

  // Roll rarity
  const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
  let roll = Math.random() * totalWeight;
  let rolledRarity = 'common';
  for (const [rarity, weight] of Object.entries(weights)) {
    roll -= weight;
    if (roll <= 0) { rolledRarity = rarity; break; }
  }

  // Filter pool by rarity
  let candidates = pool.filter(id => EQUIPMENT_DEFS[id] && EQUIPMENT_DEFS[id].rarity === rolledRarity);
  // If no candidates at that rarity, try adjacent rarities
  if (candidates.length === 0) {
    candidates = pool.filter(id => EQUIPMENT_DEFS[id]);
  }
  if (candidates.length === 0) return null;

  return candidates[Math.floor(Math.random() * candidates.length)];
}

// ---- CAMPAIGN CHAPTERS ----
const CAMPAIGN_CHAPTERS = {
  1: {
    name: 'FRONTIER SECTOR',
    levels: [
      {
        id: '1-1', name: 'First Contact',
        enemies: ['grunt'],
        miniboss: true, bossType: 4, bossHP: 80,
        waves: [
          { pattern: 'VERTICAL_COLUMN', types: ['grunt'], count: 5 },
          { pattern: 'CHEVRON', types: ['grunt'], count: 5 },
          { pattern: 'STREAM', types: ['grunt'], count: 8, side: 'left' },
          { pattern: 'BOSS', bossType: 4, bossHP: 80 },
        ]
      },
      {
        id: '1-2', name: 'Patrol Duty',
        enemies: ['grunt', 'swooper'],
        miniboss: true, bossType: 5, bossHP: 120,
        waves: [
          { pattern: 'VERTICAL_COLUMN', types: ['grunt'], count: 5 },
          { pattern: 'SIDE_SWOOP', types: ['swooper'], count: 6, side: 'left' },
          { pattern: 'CROSSING_STREAMS', types: ['grunt'], count: 8 },
          { pattern: 'PINCER', types: ['swooper'], count: 6 },
          { pattern: 'BOSS', bossType: 5, bossHP: 120 },
        ]
      },
      {
        id: '1-3', name: 'Ambush',
        enemies: ['grunt', 'swooper', 'spinner'],
        miniboss: true, boss: true, bossType: 1, bossHP: 180,
        waves: [
          { pattern: 'CHEVRON', types: ['grunt'], count: 7 },
          { pattern: 'SPINNER_DESCENT', types: ['spinner'], count: 4 },
          { pattern: 'BOSS', bossType: 6, bossHP: 150 },
          { pattern: 'STREAM', types: ['grunt'], count: 10, side: 'right' },
          { pattern: 'DECOY_AND_AMBUSH', types: ['grunt', 'spinner'] },
          { pattern: 'BOSS', bossType: 1, bossHP: 180 },
        ]
      },
      {
        id: '1-4', name: 'Supply Lines',
        enemies: ['grunt', 'tank', 'swooper'],
        miniboss: true, bossType: 7, bossHP: 200,
        waves: [
          { pattern: 'SIDE_SWOOP', types: ['swooper'], count: 6, side: 'right' },
          { pattern: 'CURTAIN_WALL', types: ['grunt', 'tank'], count: 7 },
          { pattern: 'STREAM', types: ['grunt'], count: 6, side: 'left' },
          { pattern: 'ANCHOR', types: ['tank', 'grunt'] },
          { pattern: 'BRACKET', types: ['swooper', 'grunt'] },
          { pattern: 'BOSS', bossType: 7, bossHP: 200 },
        ]
      },
      {
        id: '1-5', name: 'Blockade Run',
        enemies: ['tank', 'spinner', 'sniper'],
        miniboss: true, bossType: 8, bossHP: 200,
        waves: [
          { pattern: 'SNIPER_ALLEY', types: ['sniper'], count: 3 },
          { pattern: 'CURTAIN_WALL', types: ['tank', 'grunt'], count: 6 },
          { pattern: 'VERTICAL_COLUMN', types: ['grunt'], count: 4 },
          { pattern: 'REVOLVING_DOOR', types: ['spinner', 'tank', 'grunt'] },
          { pattern: 'CAGE', types: ['grunt', 'tank'], count: 8 },
          { pattern: 'ESCALATION_LADDER', types: ['grunt', 'spinner', 'sniper'] },
          { pattern: 'BOSS', bossType: 8, bossHP: 200 },
        ]
      },
      {
        id: '1-6', name: "Dragon's Gate",
        enemies: ['grunt', 'swooper', 'spinner', 'tank', 'sniper'],
        miniboss: false, boss: true, bossType: 3, bossHP: 450,
        waves: [
          { pattern: 'PINCER', types: ['swooper'], count: 8 },
          { pattern: 'CURTAIN_WALL', types: ['grunt', 'tank'], count: 8 },
          { pattern: 'SPOKE_WHEEL', types: ['spinner', 'grunt'] },
          { pattern: 'STREAM', types: ['grunt'], count: 6, side: 'left' },
          { pattern: 'BRACKET', types: ['tank', 'spinner'] },
          { pattern: 'FALSE_RETREAT', types: ['swooper'], count: 5 },
          { pattern: 'CROSSING_STREAMS', types: ['grunt', 'spinner'], count: 10 },
          { pattern: 'SNIPER_ALLEY', types: ['sniper'], count: 3 },
          { pattern: 'BOSS', bossType: 3, bossHP: 450 },
        ]
      },
    ]
  }
};

// ---- HELPER FUNCTIONS ----
function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
function angleToward(from, to) { return Math.atan2(to.y - from.y, to.x - from.x); }
function lerp(a, b, t) { return a + (b - a) * t; }
function rand(min, max) { return min + Math.random() * (max - min); }
function randInt(min, max) { return Math.floor(rand(min, max + 1)); }

// ---- SPRITE-BASED EXPLOSION SYSTEM ----
function spawnFireSprite(x, y, scale) {
  const fireKeys = ['fire00', 'fire04', 'fire08', 'fire12', 'fire16'];
  const key = fireKeys[Math.floor(Math.random() * fireKeys.length)];
  if (!img[key]) return;
  fireSprites.push({
    x: x + rand(-10, 10),
    y: y + rand(-10, 10),
    key,
    scale: scale * (0.5 + Math.random()),
    alpha: 1,
    decay: 0.03 + Math.random() * 0.03,
    rot: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.1,
    vx: (Math.random() - 0.5) * 2,
    vy: (Math.random() - 0.5) * 2 - 1,
  });
}

// ---- PARTICLE SYSTEM ----
function spawnParticles(x, y, color, count, speed, life, size) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = Math.random() * speed;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd,
      life: life * (0.5 + Math.random() * 0.5),
      maxLife: life,
      color,
      size: size * (0.5 + Math.random()),
    });
  }
}

function spawnExplosion(x, y, color, big) {
  const n = big ? 40 : 15;
  const spd = big ? 6 : 3;
  spawnParticles(x, y, color, n, spd, big ? 40 : 25, big ? 4 : 2);
  if (big) {
    spawnParticles(x, y, '#ffffff', 10, 3, 20, 3);
    shakeTimer = 15;
    shakeIntensity = 6;
    // Sprite fire explosions
    for (let i = 0; i < 6; i++) spawnFireSprite(x, y, big ? 1.5 : 0.8);
  } else {
    for (let i = 0; i < 3; i++) spawnFireSprite(x, y, 0.6);
  }
}

// ---- IS FOCUS ACTIVE ----
function isFocused() {
  return keys['shift'] || touch.focus;
}

// ---- PLAYER SHOOTING (dispatches to ship-specific) ----
function playerShootPioneer() {
  const p = player;
  // Basic single stream — equipment adds more via resolvedMods
  createPlayerBullet({ x: p.x, y: p.y - 16, vx: 0, vy: -10, damage: 1.5, size: 3, color: '#88aacc', type: 'main' });
  // Extra streams from equipment
  const extra = resolvedMods.extraStreams || 0;
  if (extra >= 1) {
    createPlayerBullet({ x: p.x, y: p.y - 12, vx: 0, vy: -10, damage: 1.2, size: 2.5, color: '#88aacc', type: 'main' });
  }
  // Side shots from equipment
  const sides = resolvedMods.sideShots || 0;
  if (sides >= 2) {
    createPlayerBullet({ x: p.x - 8, y: p.y - 8, vx: -1.5, vy: -9, damage: 1, size: 2, color: '#88ccff', type: 'side' });
    createPlayerBullet({ x: p.x + 8, y: p.y - 8, vx: 1.5, vy: -9, damage: 1, size: 2, color: '#88ccff', type: 'side' });
  }
  if (sides >= 4) {
    createPlayerBullet({ x: p.x - 14, y: p.y - 4, vx: -3, vy: -8, damage: 0.8, size: 2, color: '#88ccff', type: 'side' });
    createPlayerBullet({ x: p.x + 14, y: p.y - 4, vx: 3, vy: -8, damage: 0.8, size: 2, color: '#88ccff', type: 'side' });
  }
}

function playerShoot() {
  if (gameMode === 'campaign') { playerShootPioneer(); return; }
  if (selectedShip === 0) playerShootVanguard();
  else if (selectedShip === 1) playerShootTempest();
  else playerShootBastion();
}

function findNearestEnemy(x, y) {
  let nearest = null, minD = Infinity;
  for (const e of enemies) {
    const d = Math.hypot(e.x - x, e.y - y);
    if (d < minD) { minD = d; nearest = e; }
  }
  for (const b of bosses) {
    const d = Math.hypot(b.x - x, b.y - y);
    if (d < minD) { minD = d; nearest = b; }
  }
  return nearest;
}

// ---- BOMBS ----
let bombCooldown = 0;
let shieldBombActive = false;
let shieldBombTimer = 0;
let shieldBombRadius = 60;

// ---- SHIP-SPECIFIC SHOOTING ----
function playerShootVanguard() {
  const focused = isFocused();
  const p = player;
  const pw = p.power;
  createPlayerBullet({ x: p.x, y: p.y - 16, vx: 0, vy: -12, damage: 2, size: 3, color: COLORS.playerShot, type: 'main' });
  if (pw >= 2) {
    createPlayerBullet({ x: p.x - 10, y: p.y - 10, vx: focused ? -0.5 : -2, vy: -11, damage: 1.5, size: 2.5, color: '#88ddff', type: 'side' });
    createPlayerBullet({ x: p.x + 10, y: p.y - 10, vx: focused ? 0.5 : 2, vy: -11, damage: 1.5, size: 2.5, color: '#88ddff', type: 'side' });
  }
  if (pw >= 3) {
    createPlayerBullet({ x: p.x - 18, y: p.y - 5, vx: focused ? -1 : -3.5, vy: -10, damage: 1, size: 2, color: '#aaccff', type: 'wide' });
    createPlayerBullet({ x: p.x + 18, y: p.y - 5, vx: focused ? 1 : 3.5, vy: -10, damage: 1, size: 2, color: '#aaccff', type: 'wide' });
  }
  if (pw >= 4) {
    for (const opt of player.options) {
      let target = findNearestEnemy(opt.x, opt.y);
      let angle = target ? angleToward(opt, target) : -Math.PI / 2;
      createPlayerBullet({ x: opt.x, y: opt.y, vx: Math.cos(angle) * 9, vy: Math.sin(angle) * 9, damage: 1.5, size: 2, color: '#ff88ff', type: 'homing' });
    }
  }
}

function playerShootTempest() {
  const focused = isFocused();
  const p = player;
  const pw = p.power;
  createPlayerBullet({ x: p.x, y: p.y - 16, vx: 0, vy: -14, damage: 3, size: 3.5, color: '#ff6666', type: 'main' });
  if (pw >= 2) {
    createPlayerBullet({ x: p.x - 5, y: p.y - 14, vx: focused ? 0 : -0.8, vy: -13, damage: 2.5, size: 2.5, color: '#ff8888', type: 'side' });
    createPlayerBullet({ x: p.x + 5, y: p.y - 14, vx: focused ? 0 : 0.8, vy: -13, damage: 2.5, size: 2.5, color: '#ff8888', type: 'side' });
  }
  if (pw >= 3) {
    createPlayerBullet({ x: p.x - 8, y: p.y - 12, vx: focused ? 0 : -1.2, vy: -13, damage: 2, size: 2, color: '#ffaaaa', type: 'wide' });
    createPlayerBullet({ x: p.x + 8, y: p.y - 12, vx: focused ? 0 : 1.2, vy: -13, damage: 2, size: 2, color: '#ffaaaa', type: 'wide' });
  }
  if (pw >= 4) {
    createPlayerBullet({ x: p.x - 3, y: p.y - 18, vx: 0, vy: -15, damage: 4, size: 4, color: '#ff4444', type: 'main', pierce: true });
    createPlayerBullet({ x: p.x + 3, y: p.y - 18, vx: 0, vy: -15, damage: 4, size: 4, color: '#ff4444', type: 'main', pierce: true });
  }
}

function playerShootBastion() {
  const focused = isFocused();
  const p = player;
  const pw = p.power;
  createPlayerBullet({ x: p.x, y: p.y - 16, vx: 0, vy: -10, damage: 1.5, size: 3, color: '#44ff88', type: 'main' });
  createPlayerBullet({ x: p.x - 8, y: p.y - 12, vx: focused ? -0.5 : -2, vy: -10, damage: 1, size: 2, color: '#66ffaa', type: 'side' });
  createPlayerBullet({ x: p.x + 8, y: p.y - 12, vx: focused ? 0.5 : 2, vy: -10, damage: 1, size: 2, color: '#66ffaa', type: 'side' });
  if (pw >= 2) {
    createPlayerBullet({ x: p.x - 16, y: p.y - 8, vx: focused ? -1 : -3.5, vy: -9, damage: 1, size: 2, color: '#88ffcc', type: 'wide' });
    createPlayerBullet({ x: p.x + 16, y: p.y - 8, vx: focused ? 1 : 3.5, vy: -9, damage: 1, size: 2, color: '#88ffcc', type: 'wide' });
  }
  if (pw >= 3) {
    createPlayerBullet({ x: p.x - 22, y: p.y - 4, vx: focused ? -1.5 : -5, vy: -8, damage: 0.8, size: 2, color: '#aaffdd', type: 'wide' });
    createPlayerBullet({ x: p.x + 22, y: p.y - 4, vx: focused ? 1.5 : 5, vy: -8, damage: 0.8, size: 2, color: '#aaffdd', type: 'wide' });
  }
  if (pw >= 4) {
    for (const opt of player.options) {
      let target = findNearestEnemy(opt.x, opt.y);
      let angle = target ? angleToward(opt, target) : -Math.PI / 2;
      createPlayerBullet({ x: opt.x, y: opt.y, vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8, damage: 1, size: 2, color: '#88ff88', type: 'homing' });
    }
  }
}

// ---- SHIP-SPECIFIC BOMBS ----
function useBombVanguard() {
  // Full-screen clear (original behavior)
  player.bombs--;
  player.invincible = 120;
  bombCooldown = 30;
  shakeTimer = 20; shakeIntensity = 8; slowmoTimer = 30;
  for (const b of enemyBullets) {
    spawnParticles(b.x, b.y, b.color || '#ffffff', 3, 2, 15, 2);
    score += 10;
  }
  enemyBullets = [];
  const bombMult = resolvedMods.bombDamageMult;
  for (const e of enemies) { e.hp -= 20 * bombMult; }
  for (const b of bosses) { b.hp -= 30 * bombMult; }
  spawnParticles(player.x, player.y, '#ffffff', 60, 10, 40, 5);
  spawnParticles(player.x, player.y, '#7b68ee', 40, 8, 35, 4);
  for (let i = 0; i < 10; i++) spawnFireSprite(player.x, player.y, 2);
}

function useBombTempest() {
  // Directional cone — 60° forward arc
  player.bombs--;
  player.invincible = 60;
  bombCooldown = 20;
  shakeTimer = 12; shakeIntensity = 6; slowmoTimer = 15;
  const coneAngle = Math.PI / 3; // 60 degrees
  const coneRange = 400;
  const coneDir = -Math.PI / 2; // straight up

  // Clear bullets in cone
  const newBullets = [];
  for (const b of enemyBullets) {
    const dx = b.x - player.x, dy = b.y - player.y;
    const d = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx);
    const angleDiff = Math.abs(((angle - coneDir + Math.PI * 3) % (Math.PI * 2)) - Math.PI);
    if (d < coneRange && angleDiff < coneAngle / 2) {
      spawnParticles(b.x, b.y, '#ff4444', 2, 2, 10, 2);
      score += 10;
    } else {
      newBullets.push(b);
    }
  }
  enemyBullets = newBullets;

  // Damage enemies in cone (2x damage)
  for (const e of enemies) {
    const dx = e.x - player.x, dy = e.y - player.y;
    const d = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx);
    const angleDiff = Math.abs(((angle - coneDir + Math.PI * 3) % (Math.PI * 2)) - Math.PI);
    if (d < coneRange && angleDiff < coneAngle / 2) { e.hp -= 40 * resolvedMods.bombDamageMult; e.flash = 5; }
  }
  for (const b of bosses) {
    const dx = b.x - player.x, dy = b.y - player.y;
    const d = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx);
    const angleDiff = Math.abs(((angle - coneDir + Math.PI * 3) % (Math.PI * 2)) - Math.PI);
    if (d < coneRange && angleDiff < coneAngle / 2) { b.hp -= 60 * resolvedMods.bombDamageMult; b.flash = 5; }
  }

  // Cone visual particles
  for (let i = 0; i < 30; i++) {
    const a = coneDir + (Math.random() - 0.5) * coneAngle;
    const d = Math.random() * coneRange;
    spawnParticles(player.x + Math.cos(a) * d, player.y + Math.sin(a) * d, '#ff4444', 2, 3, 20, 3);
  }
  for (let i = 0; i < 5; i++) spawnFireSprite(player.x, player.y - 60, 1.5);
}

function useBombBastion() {
  // Shield bubble — sustained protection
  player.bombs--;
  bombCooldown = 30;
  shieldBombActive = true;
  shieldBombTimer = 180; // 3 seconds
  shieldBombRadius = 70;
  shakeTimer = 8; shakeIntensity = 4;
  spawnParticles(player.x, player.y, '#44ff88', 30, 6, 25, 3);
}

function useBomb() {
  if (player.bombs <= 0 || !player.alive || bombCooldown > 0) return;
  if (gameMode === 'campaign') { useBombVanguard(); return; }
  const shipType = selectedShip;
  if (shipType === 0) useBombVanguard();
  else if (shipType === 1) useBombTempest();
  else useBombBastion();
}

// ---- ENEMY TYPES ----
function createEnemy(type, x, y, path) {
  const base = {
    x, y, type, path, pathT: 0, pathSpeed: 0.01,
    hp: 3, maxHp: 3,
    shootTimer: 0, shootDelay: 60,
    w: 24, h: 24,
    value: 100,
    alive: true,
    flash: 0,
    entryTimer: 0,
  };

  switch (type) {
    case 'grunt':
      return { ...base, hp: 3, maxHp: 3, shootDelay: 90, color: COLORS.enemy1, value: 100, spriteKey: 'enemyGrunt' };
    case 'spinner':
      return { ...base, hp: 5, maxHp: 5, shootDelay: 50, color: COLORS.enemy2, value: 200, spinAngle: 0, spriteKey: 'enemySpinner' };
    case 'tank':
      return { ...base, hp: 12, maxHp: 12, shootDelay: 70, color: COLORS.enemy3, value: 300, w: 32, h: 32, spriteKey: 'enemyTank' };
    case 'sniper':
      return { ...base, hp: 4, maxHp: 4, shootDelay: 80, color: '#ff88ff', value: 250, spriteKey: 'enemySniper' };
    case 'swooper':
      return { ...base, hp: 3, maxHp: 3, shootDelay: 120, color: '#ffaa44', value: 150, swoopPhase: 0, spriteKey: 'enemySwooper' };
    default:
      return { ...base, color: COLORS.enemy1, spriteKey: 'enemyGrunt' };
  }
}

// ---- BOSS ----
function createBoss(bossType) {
  const base = {
    x: W / 2, y: -60,
    targetY: 100,
    w: 50, h: 50,
    hp: 200, maxHp: 200,
    phase: 0, phaseTimer: 0, shootTimer: 0,
    alive: true, flash: 0,
    color: COLORS.boss, value: 5000,
    type: bossType, moveTimer: 0, targetX: W / 2,
    angle: 0, entered: false,
  };

  switch (bossType) {
    case 1: return { ...base, hp: 250, maxHp: 250, name: 'CRIMSON MOTH', color: '#ff4466', spriteKey: 'boss1' };
    case 2: return { ...base, hp: 400, maxHp: 400, name: 'VOID EMPRESS', color: '#aa44ff', w: 60, h: 60, spriteKey: 'boss2' };
    case 3: return { ...base, hp: 600, maxHp: 600, name: 'STELLAR DRAGON', color: '#ffaa00', w: 65, h: 65, spriteKey: 'boss3' };
    // Minibosses (types 4-8) — renderW/renderH = display size (2:3 aspect), w/h = base collision box
    case 4: return { ...base, hp: 120, maxHp: 120, name: 'DRIFT JELLYFISH', color: '#44ffee', w: 50, h: 70, renderW: 120, renderH: 180, spriteKey: 'miniboss4', isMiniboss: true, value: 2000, targetY: 130, curveT: 0, curveAx: 160, curveAy: 120, curveFx: 1, curveFy: 2, curveCx: W / 2, curveCy: 280, phaseState: 'solid', phaseTimer: 0, phaseCooldown: 0, trailHistory: [], trailBulletTimer: 0 };
    case 5: return { ...base, hp: 160, maxHp: 160, name: 'IRON SCARAB', color: '#ff8800', w: 60, h: 60, renderW: 140, renderH: 210, spriteKey: 'miniboss5', isMiniboss: true, value: 2500, targetY: 120, chargeTimer: 0, charging: false, chargeVx: 0, chargeVy: 0, aiState: 'HOVER', aiTimer: 0, bouncesLeft: 0, maxBounces: 2, craters: [], chargeSpeed: 5.5, wingsSpread: true };
    case 6: return { ...base, hp: 220, maxHp: 220, name: 'NEBULA SERPENT', color: '#22ff66', w: 60, h: 75, renderW: 120, renderH: 135, spriteKey: 'serpentHead', isMiniboss: true, value: 3000, targetY: 180, segments: [], posHistory: [], heading: Math.PI / 2, aiState: 'ROTATE', aiTimer: 0, aiDuration: 45, rotateDir: 1, baseSpeed: 2.2, segCount: 7, segSpacing: 42, _cycleStep: 0 };
    case 7: return { ...base, hp: 220, maxHp: 220, name: 'PLASMA SENTINEL', color: '#4488ff', w: 55, h: 55, renderW: 130, renderH: 195, spriteKey: 'miniboss7', isMiniboss: true, value: 3500, targetY: 140, orbAngle: 0, orbCount: 4, orbSpeed: 0.03, shields: [{hp:30,maxHp:30,alive:true},{hp:30,maxHp:30,alive:true},{hp:30,maxHp:30,alive:true},{hp:30,maxHp:30,alive:true}], shieldsAlive: 4, vulnerabilityTimer: 0, vulnerabilityActive: false, vulnerabilityDuration: 90, vulnerabilityCooldown: 480, vulnerabilityDmgAccum: 0, retreatTimer: 0 };
    case 8: return { ...base, hp: 300, maxHp: 300, name: 'VOID HYDRA', color: '#cc44ff', w: 100, h: 60, renderW: 220, renderH: 120, spriteKey: 'miniboss8', isMiniboss: true, value: 4000, targetY: 15,
      bodyDriftX: W / 2,
      necks: [
        { anchorOfsX: -55, anchorOfsY: 55, headX: W / 2 - 80, headY: 200, headTgtX: W / 2 - 80, headTgtY: 200, headVx: 0, headVy: 0, segments: [], attackState: 'IDLE', attackTimer: 0, attackCooldown: 60, ctrlPhase: 0, retargetTimer: 0 },
        { anchorOfsX: 0, anchorOfsY: 65, headX: W / 2, headY: 220, headTgtX: W / 2, headTgtY: 220, headVx: 0, headVy: 0, segments: [], attackState: 'IDLE', attackTimer: 0, attackCooldown: 180, ctrlPhase: 2.1, retargetTimer: 0 },
        { anchorOfsX: 55, anchorOfsY: 55, headX: W / 2 + 80, headY: 200, headTgtX: W / 2 + 80, headTgtY: 200, headVx: 0, headVy: 0, segments: [], attackState: 'IDLE', attackTimer: 0, attackCooldown: 300, ctrlPhase: 4.2, retargetTimer: 0 },
      ],
      heads: [
        { hp: 60, maxHp: 60, alive: true, regenTimer: 0, regenCount: 0, attackType: 'beam' },
        { hp: 60, maxHp: 60, alive: true, regenTimer: 0, regenCount: 0, attackType: 'breath' },
        { hp: 60, maxHp: 60, alive: true, regenTimer: 0, regenCount: 0, attackType: 'glob' },
      ],
      globs: [], beams: [],
      exposedTimer: 0, exposedActive: false, lastSeverTimes: [0, 0, 0], headsAlive: 3,
      headPositions: [{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }],
      neckSegCount: 10, maxNeckLen: 360,
    };
    default: return { ...base, hp: 200 + bossType * 100, maxHp: 200 + bossType * 100, name: 'BOSS', color: '#ff4444', spriteKey: 'boss1' };
  }
}

// ---- BULLET PATTERNS ----
function fireCircle(x, y, count, speed, color, offset) {
  for (let i = 0; i < count; i++) {
    const angle = (i / count) * Math.PI * 2 + (offset || 0);
    enemyBullets.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size: 4, color, type: 'round' });
  }
}

function fireAimed(x, y, speed, color, size) {
  const angle = angleToward({ x, y }, player);
  enemyBullets.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size: size || 5, color, type: 'round' });
}

function fireSpiral(x, y, arms, speed, color, offset, count) {
  for (let a = 0; a < arms; a++) {
    for (let i = 0; i < count; i++) {
      const angle = (a / arms) * Math.PI * 2 + offset + i * 0.15;
      const spd = speed + i * 0.1;
      enemyBullets.push({ x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd, size: 4, color, type: 'round', delay: i * 2 });
    }
  }
}

function fireFan(x, y, count, spread, speed, color, baseAngle) {
  const startAngle = baseAngle - spread / 2;
  for (let i = 0; i < count; i++) {
    const angle = startAngle + (count > 1 ? (i / (count - 1)) * spread : 0);
    enemyBullets.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size: 5, color, type: 'rice' });
  }
}

// ---- ENEMY AI ----
function updateEnemyAI(e) {
  e.shootTimer++;

  if (e.path) {
    e.pathT += e.pathSpeed;
    const p = e.path(e.pathT, e);
    if (p) { e.x = p.x; e.y = p.y; }
  }

  if (e.y > 0 && e.y < H - 50) {
    switch (e.type) {
      case 'grunt':
        if (e.shootTimer >= e.shootDelay) { e.shootTimer = 0; fireAimed(e.x, e.y, 2.5, COLORS.bulletPink); }
        break;
      case 'spinner':
        e.spinAngle = (e.spinAngle || 0) + 0.08;
        if (e.shootTimer % 8 === 0) fireCircle(e.x, e.y, 3, 2, COLORS.bulletCyan, e.spinAngle);
        break;
      case 'tank':
        if (e.shootTimer >= e.shootDelay) {
          e.shootTimer = 0;
          fireFan(e.x, e.y, 5, 0.6, 2.5, COLORS.bulletYellow, angleToward(e, player));
        }
        break;
      case 'sniper':
        if (e.shootTimer >= e.shootDelay) {
          e.shootTimer = 0;
          fireAimed(e.x, e.y, 5, COLORS.bulletPurple, 6);
          fireAimed(e.x, e.y, 4.5, COLORS.bulletPurple, 4);
        }
        break;
      case 'swooper':
        e.swoopPhase += 0.03;
        if (e.shootTimer >= e.shootDelay) { e.shootTimer = 0; fireCircle(e.x, e.y, 8, 2, COLORS.bulletOrange, 0); }
        break;
    }
  }

  if (e.y > H + 50 || e.y < -100 || e.x < -100 || e.x > W + 100) {
    if (e.pathT > 1) e.alive = false;
  }
}

// ---- BOSS AI ----
function updateBossAI(b) {
  if (!b.entered) {
    b.y = lerp(b.y, b.targetY, 0.02);
    if (Math.abs(b.y - b.targetY) < 2) b.entered = true;
    // Serpent: record position history during entry so body forms smoothly
    if (b.type === 6 && b.posHistory) {
      b.posHistory.push({ x: b.x, y: b.y, heading: b.heading });
      if (b.posHistory.length > 500) b.posHistory.shift();
    }
    // Hydra: compute neck segments during entry so necks unfurl smoothly
    if (b.type === 8 && b.necks) {
      for (let h = 0; h < 3; h++) {
        const neck = b.necks[h];
        const ax = b.x + neck.anchorOfsX, ay = b.y + neck.anchorOfsY;
        // During entry, heads cluster near anchors and slowly extend
        neck.headX = lerp(neck.headX, ax + (h - 1) * 40, 0.02);
        neck.headY = lerp(neck.headY, ay + 80 + h * 20, 0.02);
        b.headPositions[h] = { x: neck.headX, y: neck.headY };
        // Compute segments
        const p0x = ax, p0y = ay, p3x = neck.headX, p3y = neck.headY;
        const p1x = ax, p1y = ay + 40;
        const p2x = neck.headX, p2y = neck.headY - 20;
        neck.segments = [];
        for (let s = 0; s <= b.neckSegCount; s++) {
          const t = s / b.neckSegCount;
          const mt = 1 - t;
          const sx = mt*mt*mt*p0x + 3*mt*mt*t*p1x + 3*mt*t*t*p2x + t*t*t*p3x;
          const sy = mt*mt*mt*p0y + 3*mt*mt*t*p1y + 3*mt*t*t*p2y + t*t*t*p3y;
          neck.segments.push({ x: sx, y: sy, r: Math.max(12 - s * 0.5, 6) });
        }
      }
    }
    return;
  }

  b.phaseTimer++; b.shootTimer++; b.moveTimer++; b.angle += 0.02;

  const hpPct = b.hp / b.maxHp;
  if (hpPct < 0.3) b.phase = 2;
  else if (hpPct < 0.6) b.phase = 1;

  // Movement differs by type
  if (b.isMiniboss) {
    updateMinibossMovement(b);
  } else {
    if (b.moveTimer > 120) { b.moveTimer = 0; b.targetX = 80 + Math.random() * (W - 160); }
    b.x = lerp(b.x, b.targetX, 0.03);
  }

  switch (b.type) {
    case 1: bossPattern1(b); break;
    case 2: bossPattern2(b); break;
    case 3: bossPattern3(b); break;
    case 4: bossPattern4(b); break;
    case 5: bossPattern5(b); break;
    case 6: bossPattern6(b); break;
    case 7: bossPattern7(b); break;
    case 8: bossPattern8(b); break;
    default: bossPattern1(b); break;
  }
}

function updateMinibossMovement(b) {
  switch (b.type) {
    case 4: { // Jellyfish: lissajous drift + phase-shifting
      // Phase-shift state machine
      b.phaseCooldown--;
      const phaseOutDur = b.phase >= 2 ? 60 : 90; // shorter at phase 2
      switch (b.phaseState) {
        case 'solid':
          if (b.phaseCooldown <= 0 && globalTime > 120) {
            b.phaseState = 'fading';
            b.phaseTimer = 0;
          }
          break;
        case 'fading':
          b.phaseTimer++;
          if (b.phaseTimer >= 30) { // 0.5s fade out
            b.phaseState = 'phased';
            b.phaseTimer = 0;
            // Shift lissajous parameters
            b.curveFx = 1 + Math.floor(Math.random() * 2); // 1 or 2
            b.curveFy = 2 + Math.floor(Math.random() * 2); // 2 or 3
            b.curveCx = 120 + Math.random() * (W - 240);
            b.curveCy = 180 + Math.random() * 200;
          }
          break;
        case 'phased':
          b.phaseTimer++;
          if (b.phaseTimer >= phaseOutDur) {
            b.phaseState = 'appearing';
            b.phaseTimer = 0;
          }
          break;
        case 'appearing':
          b.phaseTimer++;
          if (b.phaseTimer >= 30) { // 0.5s fade in
            b.phaseState = 'solid';
            b.phaseTimer = 0;
            b.phaseCooldown = b.phase >= 2 ? 240 : b.phase >= 1 ? 300 : 360;
            // Phase-in burst
            const burstCount = b.phase >= 2 ? 12 : 8;
            fireCircle(b.x, b.y, burstCount, 1.8, '#44ffee', Math.random() * Math.PI * 2);
          }
          break;
      }
      // Lissajous curve movement — drifts across entire arena
      b.curveT += 0.008;
      const targetX4 = b.curveCx + Math.sin(b.curveT * b.curveFx) * b.curveAx;
      const targetY4 = b.curveCy + Math.sin(b.curveT * b.curveFy) * b.curveAy;
      // Clamp to arena bounds
      const clampedX = Math.max(50, Math.min(W - 50, targetX4));
      const clampedY = Math.max(60, Math.min(H - 200, targetY4));
      b.x = lerp(b.x, clampedX, 0.03);
      b.y = lerp(b.y, clampedY, 0.03);
      // Trail history for tentacle rendering
      if (globalTime % 3 === 0) {
        b.trailHistory.push({ x: b.x, y: b.y + 30 });
        if (b.trailHistory.length > 40) b.trailHistory.shift();
      }
      // Tentacle trail bullets — drop slow bullets from trail
      if (b.phaseState === 'solid' || b.phaseState === 'appearing') {
        b.trailBulletTimer++;
        const trailRate = b.phase >= 2 ? 12 : b.phase >= 1 ? 18 : 25;
        if (b.trailBulletTimer >= trailRate) {
          b.trailBulletTimer = 0;
          // Drop bullet at current tail position
          enemyBullets.push({ x: b.x + rand(-15, 15), y: b.y + 35, vx: rand(-0.3, 0.3), vy: 0.7 + Math.random() * 0.4, size: 3, color: '#88ffee', type: 'round' });
        }
      }
      break;
    }
    case 5: { // Scarab: AI state machine — HOVER → TELEGRAPH → CHARGE → IMPACT → HOVER
      // Update craters
      for (let ci = b.craters.length - 1; ci >= 0; ci--) {
        const cr = b.craters[ci];
        cr.timer--;
        if (cr.timer <= 0) { b.craters.splice(ci, 1); continue; }
        // Crater bullet burst every 90 frames
        if (cr.timer % 90 === 0) {
          const count = b.phase >= 2 ? 8 : 6;
          fireCircle(cr.x, cr.y, count, 1.8, '#ffaa44', Math.random() * Math.PI * 2);
        }
      }
      const hoverDur = b.phase >= 2 ? 90 : b.phase >= 1 ? 120 : 150;
      switch (b.aiState) {
        case 'HOVER':
          b.wingsSpread = true;
          b.aiTimer++;
          b.x = lerp(b.x, b.targetX, 0.025);
          b.y = lerp(b.y, b.targetY + Math.sin(globalTime * 0.03) * 20, 0.02);
          if (b.aiTimer > hoverDur) {
            b.aiState = 'TELEGRAPH';
            b.aiTimer = 0;
          }
          break;
        case 'TELEGRAPH':
          b.wingsSpread = false;
          b.aiTimer++;
          // Aim at player — compute charge heading
          const dx5 = player.x - b.x, dy5 = player.y - b.y;
          b.chargeHeading = Math.atan2(dy5, dx5);
          if (b.aiTimer >= 48) { // 0.8 seconds telegraph
            b.aiState = 'CHARGE';
            b.aiTimer = 0;
            b.charging = true;
            b.maxBounces = b.phase >= 2 ? 3 : 2;
            b.bouncesLeft = b.maxBounces;
            const spd5 = b.chargeSpeed + b.phase * 0.8;
            b.chargeVx = Math.cos(b.chargeHeading) * spd5;
            b.chargeVy = Math.sin(b.chargeHeading) * spd5;
          }
          break;
        case 'CHARGE':
          b.x += b.chargeVx;
          b.y += b.chargeVy;
          b.aiTimer++;
          // Wall bouncing
          if (b.x < 30 || b.x > W - 30) {
            b.chargeVx = -b.chargeVx;
            b.x = Math.max(30, Math.min(W - 30, b.x));
            b.bouncesLeft--;
            // Small ring on bounce
            fireCircle(b.x, b.y, 5, 1.5, '#ffaa44', Math.random() * Math.PI * 2);
            shakeTimer = 3; shakeIntensity = 2;
          }
          if (b.y < 30 || b.y > H - 80) {
            b.chargeVy = -b.chargeVy;
            b.y = Math.max(30, Math.min(H - 80, b.y));
            b.bouncesLeft--;
            fireCircle(b.x, b.y, 5, 1.5, '#ffaa44', Math.random() * Math.PI * 2);
            shakeTimer = 3; shakeIntensity = 2;
          }
          if (b.bouncesLeft <= 0 || b.aiTimer > 90) {
            b.aiState = 'IMPACT';
            b.aiTimer = 0;
            b.charging = false;
          }
          break;
        case 'IMPACT':
          b.aiTimer++;
          b.wingsSpread = true;
          if (b.aiTimer === 1) {
            // Shockwave ring + create crater
            fireCircle(b.x, b.y, 12 + b.phase * 2, 2.5, '#ffcc44', 0);
            shakeTimer = 8; shakeIntensity = 5;
            spawnParticles(b.x, b.y, '#ff8800', 12, 4, 20, 3);
            const craterDur = b.phase >= 2 ? 480 : 300; // 8s or 5s
            b.craters.push({ x: b.x, y: b.y, timer: craterDur, maxTimer: craterDur });
          }
          if (b.aiTimer >= 30) { // 0.5s recovery
            b.aiState = 'HOVER';
            b.aiTimer = 0;
            b.targetX = 60 + Math.random() * (W - 120);
            b.targetY = 80 + Math.random() * 120;
          }
          break;
      }
      break;
    }
    case 6: { // Moldorm-style: rotate → walk → face player → charge → repeat
      const lowHp = b.hp / b.maxHp < 0.33;
      const spd = b.baseSpeed * (lowHp ? 1.4 : 1.0);
      b.aiTimer++;
      switch (b.aiState) {
        case 'ROTATE':
          if (b.aiTimer % 4 === 0) b.heading += b.rotateDir * (Math.PI / 8);
          b.x += Math.cos(b.heading) * spd * 0.7;
          b.y += Math.sin(b.heading) * spd * 0.7;
          if (b.aiTimer >= b.aiDuration) {
            b.aiState = 'WALK'; b.aiTimer = 0;
            b.aiDuration = 10 + Math.floor(Math.random() * 14);
          }
          break;
        case 'WALK':
          b.x += Math.cos(b.heading) * spd;
          b.y += Math.sin(b.heading) * spd;
          if (b.aiTimer >= b.aiDuration) {
            b._cycleStep = (b._cycleStep + 1) % 3;
            if (b._cycleStep === 2) {
              b.aiState = 'FACE_PLAYER'; b.aiTimer = 0;
            } else {
              b.aiState = 'ROTATE'; b.aiTimer = 0;
              b.aiDuration = 32 + Math.floor(Math.random() * 32);
              b.rotateDir = Math.random() < 0.5 ? 1 : -1;
            }
          }
          break;
        case 'FACE_PLAYER':
          b.heading = Math.atan2(player.y - b.y, player.x - b.x);
          b.aiState = 'CHARGE'; b.aiTimer = 0;
          b.aiDuration = 40 + Math.floor(Math.random() * 20);
          break;
        case 'CHARGE':
          b.x += Math.cos(b.heading) * spd * 1.6;
          b.y += Math.sin(b.heading) * spd * 1.6;
          if (b.aiTimer >= b.aiDuration) {
            b.aiState = 'ROTATE'; b.aiTimer = 0;
            b.aiDuration = 32 + Math.floor(Math.random() * 32);
            b.rotateDir = Math.random() < 0.5 ? 1 : -1;
          }
          break;
      }
      // Boundary bouncing — reflect heading off walls
      const sMargin = 25;
      if (b.x < sMargin) { b.x = sMargin; b.heading = Math.PI - b.heading; }
      if (b.x > W - sMargin) { b.x = W - sMargin; b.heading = Math.PI - b.heading; }
      if (b.y < sMargin) { b.y = sMargin; b.heading = -b.heading; }
      if (b.y > H - 140) { b.y = H - 140; b.heading = -b.heading; }
      // Normalize heading to [-π, π]
      while (b.heading > Math.PI) b.heading -= Math.PI * 2;
      while (b.heading < -Math.PI) b.heading += Math.PI * 2;
      // Record position history for trailing body
      b.posHistory.push({ x: b.x, y: b.y, heading: b.heading });
      if (b.posHistory.length > 500) b.posHistory.shift();
      // Update segment positions from history
      b.segments = [];
      for (let i = 1; i <= b.segCount; i++) {
        const hIdx = b.posHistory.length - 1 - i * b.segSpacing;
        const r = Math.max(26 - i * 1.5, 14);
        if (hIdx >= 0) {
          const h = b.posHistory[hIdx];
          b.segments.push({ x: h.x, y: h.y, heading: h.heading, r });
        } else {
          // Not enough history yet — place at head so segments bunch up
          // and naturally separate as history accumulates
          const src = b.posHistory.length > 0 ? b.posHistory[0] : b;
          b.segments.push({ x: src.x, y: src.y, heading: src.heading, r });
        }
      }
      break;
    }
    case 7: { // Sentinel: shield rotation + vulnerability windows + retreat
      b.shieldsAlive = b.shields.filter(s => s.alive).length;
      // Shield orbit speed — faster with fewer shields and higher phase
      const baseOrbSpeed = 0.03 + b.phase * 0.01 + (4 - b.shieldsAlive) * 0.008;
      // During vulnerability window, shields stop rotating
      if (!b.vulnerabilityActive) {
        b.orbAngle += baseOrbSpeed;
      }
      b.orbSpeed = baseOrbSpeed;
      // Vulnerability window cooldown
      b.vulnerabilityTimer++;
      const vulnCooldown = b.shieldsAlive >= 3 ? 480 : b.shieldsAlive === 2 ? 400 : 360;
      if (!b.vulnerabilityActive && b.vulnerabilityTimer >= vulnCooldown && b.shieldsAlive > 0) {
        // Open vulnerability window — shields spread apart and stop
        b.vulnerabilityActive = true;
        b.vulnerabilityTimer = 0;
        b.vulnerabilityDmgAccum = 0;
      }
      if (b.vulnerabilityActive) {
        b.vulnerabilityTimer++;
        const maxDur = 90 + (b.vulnerabilityDmgAccum >= 15 ? 60 : 0); // Extend if player dealt enough damage
        if (b.vulnerabilityTimer >= maxDur) {
          b.vulnerabilityActive = false;
          b.vulnerabilityTimer = 0;
        }
      }
      // Movement — slow drift normally, retreat dash when shield destroyed
      if (b.retreatTimer > 0) {
        b.retreatTimer--;
        b.x = lerp(b.x, b.targetX, 0.08);
        b.y = lerp(b.y, b.targetY, 0.04);
      } else {
        b.moveTimer++;
        const movePeriod = b.shieldsAlive <= 1 && b.phase >= 2 ? 100 : 200;
        const moveSpd = b.shieldsAlive <= 1 && b.phase >= 2 ? 0.025 : 0.01;
        if (b.moveTimer > movePeriod) { b.moveTimer = 0; b.targetX = 80 + Math.random() * (W - 160); }
        b.x = lerp(b.x, b.targetX, moveSpd);
      }
      b.y = lerp(b.y, b.targetY + Math.sin(globalTime * 0.02) * 15, 0.02);
      break;
    }
    case 8: { // Hydra: stationary body + 3 serpent necks + independent head AI
      b.headsAlive = b.heads.filter(h => h.alive).length;

      // Body: nearly stationary, very slow horizontal drift
      b.moveTimer++;
      if (b.exposedActive) {
        b.x += Math.sin(globalTime * 0.3) * 2;
        b.exposedTimer--;
        if (b.exposedTimer <= 0) b.exposedActive = false;
      } else {
        if (b.moveTimer > 300) { b.moveTimer = 0; b.bodyDriftX = W / 2 + (Math.random() - 0.5) * 60; }
        b.x = lerp(b.x, b.bodyDriftX, 0.005);
      }
      b.y = lerp(b.y, b.targetY, 0.02);

      // --- Per-head AI: independent movement + attack state machine ---
      for (let h = 0; h < 3; h++) {
        const neck = b.necks[h];
        const head = b.heads[h];
        const anchorX = b.x + neck.anchorOfsX;
        const anchorY = b.y + neck.anchorOfsY;

        if (head.alive) {
          // Attack state machine
          neck.attackTimer++;
          switch (neck.attackState) {
            case 'IDLE':
              // Head wanders independently
              neck.retargetTimer--;
              if (neck.retargetTimer <= 0) {
                neck.retargetTimer = 90 + Math.floor(Math.random() * 60);
                // Each head roams a different horizontal zone to spread out
                const zoneX = h === 0 ? W * 0.25 : h === 1 ? W * 0.5 : W * 0.75;
                neck.headTgtX = zoneX + (Math.random() - 0.5) * (W * 0.4);
                neck.headTgtX = Math.max(35, Math.min(W - 35, neck.headTgtX));
                // Push heads deep into the arena — y 200 to 420
                neck.headTgtY = 200 + Math.random() * 220;
              }
              // Check if ready to attack
              if (neck.attackCooldown <= 0) {
                neck.attackState = 'TELEGRAPH';
                neck.attackTimer = 0;
              }
              neck.attackCooldown--;
              break;
            case 'TELEGRAPH':
              // Head slows down toward attack position
              neck.headTgtY = lerp(neck.headTgtY, 160 + h * 40, 0.03);
              // Telegraph duration varies by attack type
              const telegraphDur = head.attackType === 'beam' ? 90 : head.attackType === 'breath' ? 60 : 50;
              if (neck.attackTimer >= telegraphDur) {
                neck.attackState = 'ATTACK';
                neck.attackTimer = 0;
              }
              break;
            case 'ATTACK':
              // Head holds position — attacks handled in bossPattern8
              const attackDur = head.attackType === 'beam' ? 120 : head.attackType === 'breath' ? 90 : 30;
              if (neck.attackTimer >= attackDur) {
                neck.attackState = 'COOLDOWN';
                neck.attackTimer = 0;
              }
              break;
            case 'COOLDOWN':
              // Retreat toward body briefly
              neck.headTgtY = lerp(neck.headTgtY, anchorY + 80, 0.05);
              const cdDur = head.attackType === 'beam' ? 240 : head.attackType === 'breath' ? 240 : 300;
              if (neck.attackTimer >= 60) {
                neck.attackState = 'IDLE';
                neck.attackTimer = 0;
                neck.attackCooldown = cdDur;
                neck.retargetTimer = 0; // Immediately pick new wander target
              }
              break;
          }

          // Move head toward target
          const headSpd = neck.attackState === 'ATTACK' ? 0.4 : neck.attackState === 'TELEGRAPH' ? 1.0 : 2.5;
          const dx = neck.headTgtX - neck.headX;
          const dy = neck.headTgtY - neck.headY;
          const dLen = Math.hypot(dx, dy);
          if (dLen > 1) {
            const moveAmt = Math.min(headSpd, dLen);
            neck.headX += (dx / dLen) * moveAmt;
            neck.headY += (dy / dLen) * moveAmt;
          }

          // Neck length constraint — pull head back if too far from anchor
          const neckDx = neck.headX - anchorX;
          const neckDy = neck.headY - anchorY;
          const neckDist = Math.hypot(neckDx, neckDy);
          if (neckDist > b.maxNeckLen) {
            const pullback = neckDist - b.maxNeckLen;
            neck.headX -= (neckDx / neckDist) * pullback;
            neck.headY -= (neckDy / neckDist) * pullback;
          }

          // Keep head in arena bounds
          neck.headX = Math.max(25, Math.min(W - 25, neck.headX));
          neck.headY = Math.max(60, Math.min(H - 100, neck.headY));

          // Track smoothed velocity for bezier control
          const newVx = neck.headX - (b.headPositions[h].x || neck.headX);
          const newVy = neck.headY - (b.headPositions[h].y || neck.headY);
          neck.headVx = lerp(neck.headVx, newVx, 0.15);
          neck.headVy = lerp(neck.headVy, newVy, 0.15);
        } else {
          // Dead head: retract neck toward anchor
          neck.headX = lerp(neck.headX, anchorX, 0.02);
          neck.headY = lerp(neck.headY, anchorY + 40, 0.02);
          neck.headVx *= 0.95; neck.headVy *= 0.95;
          neck.attackState = 'IDLE';
          neck.attackTimer = 0;
        }

        // Update head world position
        b.headPositions[h] = { x: neck.headX, y: neck.headY };

        // --- Compute neck segments via cubic bezier + perpendicular wobble ---
        const p0x = anchorX, p0y = anchorY;
        const p3x = neck.headX, p3y = neck.headY;
        // Control points: P1 curves neck downward from body, P2 curves based on head velocity
        const p1x = anchorX + Math.sin(globalTime * 0.025 + neck.ctrlPhase) * 25;
        const p1y = anchorY + 75;
        const p2x = neck.headX - neck.headVx * 8;
        const p2y = neck.headY - 35;

        neck.segments = [];
        for (let s = 0; s <= b.neckSegCount; s++) {
          const t = s / b.neckSegCount;
          const mt = 1 - t;
          // Cubic bezier position
          let sx = mt * mt * mt * p0x + 3 * mt * mt * t * p1x + 3 * mt * t * t * p2x + t * t * t * p3x;
          let sy = mt * mt * mt * p0y + 3 * mt * mt * t * p1y + 3 * mt * t * t * p2y + t * t * t * p3y;
          // Tangent direction (bezier derivative)
          const tx = 3 * mt * mt * (p1x - p0x) + 6 * mt * t * (p2x - p1x) + 3 * t * t * (p3x - p2x);
          const ty = 3 * mt * mt * (p1y - p0y) + 6 * mt * t * (p2y - p1y) + 3 * t * t * (p3y - p2y);
          const tLen = Math.hypot(tx, ty) || 1;
          // Perpendicular wobble — stronger in middle, weaker at ends
          const wobbleAmp = Math.sin(t * Math.PI) * 12; // Peaks at t=0.5
          const wobble = Math.sin(globalTime * 0.06 + s * 0.8 + neck.ctrlPhase) * wobbleAmp;
          sx += (-ty / tLen) * wobble;
          sy += (tx / tLen) * wobble;
          // Radius tapers: thicker near body, thinner toward head
          const r = 12 - s * 0.5;
          neck.segments.push({ x: sx, y: sy, r: Math.max(r, 6) });
        }
      }

      // --- Head regeneration ---
      for (let h = 0; h < 3; h++) {
        if (!b.heads[h].alive) {
          b.heads[h].regenTimer--;
          if (b.heads[h].regenTimer <= 0) {
            b.heads[h].alive = true;
            b.heads[h].regenCount++;
            b.heads[h].maxHp = Math.floor(60 * (1 + 0.25 * b.heads[h].regenCount));
            b.heads[h].hp = b.heads[h].maxHp;
            const hp = b.headPositions[h];
            fireCircle(hp.x, hp.y, 10, 2, b.heads[h].regenCount > 1 ? '#ff88ff' : '#cc44ff', 0);
            spawnParticles(hp.x, hp.y, '#cc44ff', 8, 3, 20, 3);
            // Reset attack cooldown on regen
            b.necks[h].attackCooldown = 120;
          }
        }
      }

      // --- Synchronized sever check ---
      if (b.headsAlive === 0 && !b.exposedActive) {
        const now = globalTime;
        const allRecent = b.lastSeverTimes.every(t => now - t < 300);
        if (allRecent) {
          b.exposedActive = true;
          b.exposedTimer = 300;
          shakeTimer = 20; shakeIntensity = 8;
          spawnExplosion(b.x, b.y, '#ff44ff', false);
          enemyBullets.length = 0;
          b.globs.length = 0; // Clear globs as reward too
          b.beams.length = 0;
        }
      }

      // --- Update persistent globs ---
      for (let g = b.globs.length - 1; g >= 0; g--) {
        const glob = b.globs[g];
        glob.timer--;
        glob.pulseTimer--;
        if (glob.pulseTimer <= 0) {
          glob.pulseTimer = 90;
          fireCircle(glob.x, glob.y, 6, 1.8, '#bb44ff', Math.random() * Math.PI * 2);
        }
        if (glob.timer <= 0) b.globs.splice(g, 1);
      }

      // --- Update active beams ---
      for (let i = b.beams.length - 1; i >= 0; i--) {
        const beam = b.beams[i];
        beam.timer++;
        // Sweep angle from sweepStart to sweepEnd over maxTimer frames
        const sweepT = Math.min(beam.timer / beam.maxTimer, 1);
        beam.angle = beam.sweepStart + (beam.sweepEnd - beam.sweepStart) * sweepT;
        // Update beam origin to track head position
        const headPos = b.headPositions[beam.headIdx];
        if (headPos) { beam.x = headPos.x; beam.y = headPos.y; }
        if (beam.timer >= beam.maxTimer) b.beams.splice(i, 1);
      }

      break;
    }
  }
}

function bossPattern1(b) {
  const rate = b.phase === 2 ? 0.7 : b.phase === 1 ? 0.85 : 1;
  if (b.shootTimer % Math.floor(40 * rate) === 0) fireCircle(b.x, b.y, 12 + b.phase * 4, 2 + b.phase * 0.3, COLORS.bulletPink, b.angle);
  if (b.shootTimer % Math.floor(60 * rate) === 0) {
    fireAimed(b.x, b.y, 3.5, COLORS.bulletCyan, 6);
    if (b.phase >= 1) { fireAimed(b.x - 20, b.y, 3.2, COLORS.bulletCyan, 5); fireAimed(b.x + 20, b.y, 3.2, COLORS.bulletCyan, 5); }
  }
  if (b.phase === 2 && b.shootTimer % 100 === 0) fireSpiral(b.x, b.y, 4, 1.8, COLORS.bulletYellow, b.angle, 6);
}

function bossPattern2(b) {
  const rate = b.phase === 2 ? 0.6 : b.phase === 1 ? 0.8 : 1;
  if (b.shootTimer % Math.floor(6 * rate) === 0) {
    const arms = 5 + b.phase * 2;
    for (let i = 0; i < arms; i++) {
      const angle = (i / arms) * Math.PI * 2 + b.angle * 2;
      enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * 2.2, vy: Math.sin(angle) * 2.2, size: 4, color: COLORS.bulletPurple, type: 'round' });
    }
  }
  if (b.shootTimer % Math.floor(80 * rate) === 0) {
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        if (!b.alive) return;
        fireFan(b.x, b.y, 7 + b.phase * 2, 0.8, 3, COLORS.bulletCyan, angleToward(b, player));
      }, i * 100);
    }
  }
  if (b.phase === 2 && b.shootTimer % 120 === 0) {
    for (let i = 0; i < 36; i++) {
      const angle = (i / 36) * Math.PI * 2;
      const speed = 1.5 + Math.sin(i * 5) * 0.8;
      enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size: 5, color: i % 2 ? COLORS.bulletPink : COLORS.bulletPurple, type: 'round' });
    }
  }
}

function bossPattern3(b) {
  const rate = b.phase === 2 ? 0.5 : b.phase === 1 ? 0.75 : 1;
  if (b.shootTimer % Math.floor(4 * rate) === 0) {
    for (let i = 0; i < 3; i++) {
      const a1 = (i / 3) * Math.PI * 2 + b.angle * 3;
      enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(a1) * 2, vy: Math.sin(a1) * 2, size: 5, color: COLORS.bulletOrange, type: 'round' });
      const a2 = (i / 3) * Math.PI * 2 - b.angle * 2;
      enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(a2) * 2.5, vy: Math.sin(a2) * 2.5, size: 4, color: COLORS.bulletYellow, type: 'round' });
    }
  }
  if (b.shootTimer % Math.floor(30 * rate) === 0) {
    for (let i = 0; i < 5 + b.phase * 3; i++) {
      enemyBullets.push({ x: rand(30, W - 30), y: -10, vx: rand(-0.5, 0.5), vy: rand(2, 4), size: 5, color: COLORS.bulletRed, type: 'rice' });
    }
  }
  if (b.shootTimer % Math.floor(50 * rate) === 0) {
    const ba = angleToward(b, player);
    for (let i = 0; i < 8; i++) {
      enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(ba) * (2 + i * 0.4), vy: Math.sin(ba) * (2 + i * 0.4), size: 4, color: COLORS.bulletWhite, type: 'round' });
    }
  }
}

// ---- MINIBOSS ATTACK PATTERNS ----

// DRIFT JELLYFISH: Pulsing rings + dangling tentacle streams
function bossPattern4(b) {
  // No attacks while phased out or fading
  if (b.phaseState === 'phased' || b.phaseState === 'fading') return;
  const rate = b.phase === 2 ? 0.7 : b.phase === 1 ? 0.85 : 1;
  // Gentle ring bursts
  if (b.shootTimer % Math.floor(70 * rate) === 0) {
    fireCircle(b.x, b.y, 8 + b.phase * 3, 1.5 + b.phase * 0.2, COLORS.bulletCyan, b.angle);
  }
  // Phase 1+: aimed shots during solid state
  if (b.phase >= 1 && b.shootTimer % Math.floor(50 * rate) === 0) {
    fireAimed(b.x, b.y, 2.8, COLORS.bulletPurple, 5);
  }
  // Phase 2: trail bullets gain slight homing (handled via curve)
  if (b.phase === 2 && b.shootTimer % Math.floor(35 * rate) === 0) {
    // Curved tentacle shots that arc toward player
    const toPlayer = angleToward(b, player);
    for (let i = 0; i < 3; i++) {
      const a = toPlayer + (i - 1) * 0.4;
      enemyBullets.push({ x: b.x, y: b.y + 20, vx: Math.cos(a) * 1.5, vy: Math.sin(a) * 1.5, size: 4, color: '#cc66ff', type: 'round' });
    }
  }
}

// IRON SCARAB: Charge + spread shots + ground pound shockwave
function bossPattern5(b) {
  const rate = b.phase === 2 ? 0.65 : b.phase === 1 ? 0.8 : 1;
  // HOVER: defensive fan burst
  if (b.aiState === 'HOVER' && b.shootTimer % Math.floor(50 * rate) === 0) {
    fireFan(b.x, b.y, 5 + b.phase * 2, 0.7, 2.5 + b.phase * 0.3, COLORS.bulletOrange, Math.PI / 2);
  }
  // HOVER phase 1+: aimed double-shot
  if (b.aiState === 'HOVER' && b.phase >= 1 && b.shootTimer % Math.floor(40 * rate) === 0) {
    fireAimed(b.x - 15, b.y, 3, COLORS.bulletRed, 5);
    fireAimed(b.x + 15, b.y, 3, COLORS.bulletRed, 5);
  }
  // CHARGE: trail of bullets along charge path
  if (b.aiState === 'CHARGE' && b.aiTimer % 5 === 0) {
    // Perpendicular spray — bullets go sideways from charge direction
    const cAngle = Math.atan2(b.chargeVy, b.chargeVx);
    const perpAngle = cAngle + Math.PI / 2;
    enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(perpAngle) * 1.5, vy: Math.sin(perpAngle) * 1.5, size: 4, color: COLORS.bulletOrange, type: 'round' });
    enemyBullets.push({ x: b.x, y: b.y, vx: -Math.cos(perpAngle) * 1.5, vy: -Math.sin(perpAngle) * 1.5, size: 4, color: COLORS.bulletOrange, type: 'round' });
  }
  // Phase 2: additional forward spray during charge
  if (b.aiState === 'CHARGE' && b.phase >= 2 && b.aiTimer % 8 === 0) {
    const cAngle = Math.atan2(b.chargeVy, b.chargeVx);
    enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(cAngle) * 3, vy: Math.sin(cAngle) * 3, size: 5, color: COLORS.bulletYellow, type: 'rice' });
  }
}

// NEBULA SERPENT (Moldorm): Forward spray + poison trail from body + aimed burst
function bossPattern6(b) {
  const rate = b.phase === 2 ? 0.6 : b.phase === 1 ? 0.8 : 1;
  // Forward spray from head in direction of travel
  if (b.shootTimer % Math.floor(10 * rate) === 0) {
    const spread = 0.35;
    const angle = b.heading + (Math.random() - 0.5) * spread;
    const spd = 2.8 + b.phase * 0.3;
    enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd, size: 4, color: '#44ff88', type: 'round' });
  }
  // Poison trail: body segments drop slow bullets
  if (b.shootTimer % Math.floor(25 * rate) === 0 && b.segments.length > 2) {
    const midSeg = b.segments[Math.floor(b.segments.length / 2)];
    enemyBullets.push({ x: midSeg.x, y: midSeg.y, vx: (Math.random() - 0.5) * 0.5, vy: 1.2, size: 3, color: '#22ff66', type: 'round' });
  }
  // During charge: rapid burst from head
  if (b.aiState === 'CHARGE' && b.shootTimer % Math.floor(6 * rate) === 0) {
    const a = b.heading + (Math.random() - 0.5) * 0.5;
    enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(a) * 3.5, vy: Math.sin(a) * 3.5, size: 5, color: '#88ffaa', type: 'round' });
  }
  // Phase 1+: aimed fan burst
  if (b.phase >= 1 && b.shootTimer % Math.floor(55 * rate) === 0) {
    fireFan(b.x, b.y, 3 + b.phase * 2, 0.5, 3, '#88ffaa', angleToward(b, player));
  }
  // Phase 2: tail drops spiral mines
  if (b.phase === 2 && b.shootTimer % 80 === 0 && b.segments.length > 0) {
    const tail = b.segments[b.segments.length - 1];
    fireCircle(tail.x, tail.y, 6 + b.phase * 2, 1.5, '#22ff66', b.angle);
  }
}

// PLASMA SENTINEL: Shield-dependent attacks — more aggressive with fewer shields
function bossPattern7(b) {
  // No attacks during vulnerability window — player's reward for timing
  if (b.vulnerabilityActive) return;
  const rate = b.phase === 2 ? 0.6 : b.phase === 1 ? 0.8 : 1;
  const sa = b.shieldsAlive;
  // Alive shield orbs fire aimed shots
  if (b.shootTimer % Math.floor(35 * rate) === 0) {
    for (let i = 0; i < b.orbCount; i++) {
      if (!b.shields[i].alive) continue;
      const oa = b.orbAngle + (i / b.orbCount) * Math.PI * 2;
      const ox = b.x + Math.cos(oa) * 55;
      const oy = b.y + Math.sin(oa) * 55;
      fireAimed(ox, oy, 2.5 + b.phase * 0.3, COLORS.bulletCyan, 4);
    }
  }
  // Central beam burst — stronger with fewer shields
  const beamRate = sa >= 3 ? 80 : sa === 2 ? 65 : sa === 1 ? 50 : 35;
  if (b.shootTimer % Math.floor(beamRate * rate) === 0) {
    const count = (6 + b.phase * 2) + (4 - sa) * 2;
    for (let i = 0; i < count; i++) {
      const a = angleToward(b, player) + (i - (count - 1) / 2) * 0.07;
      enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(a) * (3 + i * 0.2), vy: Math.sin(a) * (3 + i * 0.2), size: 4, color: '#4488ff', type: 'round' });
    }
  }
  // Phase 1+: barrier walls
  if (b.phase >= 1 && b.shootTimer % Math.floor(100 * rate) === 0) {
    for (let i = 0; i < 8; i++) {
      enemyBullets.push({ x: 30 + i * (W - 60) / 7, y: b.y + 30, vx: 0, vy: 2, size: 5, color: COLORS.bulletPurple, type: 'rice' });
    }
  }
  // 0 shields — exposed fury: rapid rotating cross + aimed fire
  if (sa === 0) {
    // Rotating cross
    if (b.shootTimer % Math.floor(5 * rate) === 0) {
      for (let i = 0; i < 4; i++) {
        const a = b.orbAngle * 2 + (i / 4) * Math.PI * 2;
        enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(a) * 2.5, vy: Math.sin(a) * 2.5, size: 3, color: '#88aaff', type: 'round' });
      }
    }
    // Rapid aimed shots
    if (b.shootTimer % Math.floor(20 * rate) === 0) {
      fireAimed(b.x, b.y, 3.5, '#ff8844', 5);
    }
  } else if (b.phase === 2 && b.shootTimer % Math.floor(8) === 0) {
    // Phase 2 with shields: slower rotating cross
    for (let i = 0; i < 4; i++) {
      const a = b.orbAngle * 1.5 + (i / 4) * Math.PI * 2;
      enemyBullets.push({ x: b.x, y: b.y, vx: Math.cos(a) * 2, vy: Math.sin(a) * 2, size: 3, color: '#88aaff', type: 'round' });
    }
  }
}

// VOID HYDRA: Three heads with signature attacks — beam, breath, globs
function bossPattern8(b) {
  if (b.exposedActive) return;
  const headColors = ['#ff4444', '#4488ff', '#cc44ff'];
  const hp = b.headPositions;
  const heads = b.heads;

  for (let h = 0; h < 3; h++) {
    if (!heads[h].alive) continue;
    const neck = b.necks[h];

    // Idle: light aimed shots to keep pressure (all heads)
    if (neck.attackState === 'IDLE' && b.shootTimer % 50 === 0) {
      fireAimed(hp[h].x, hp[h].y, 2.5 + b.phase * 0.3, headColors[h], 4);
    }

    // --- Signature attacks based on state machine ---
    if (neck.attackState !== 'ATTACK') continue;

    switch (heads[h].attackType) {
      case 'beam': {
        // Red head: sweeping beam — create beam on first frame, then it self-updates
        if (neck.attackTimer === 1) {
          const aimAngle = angleToward(hp[h], player);
          const sweepDir = player.x > hp[h].x ? 1 : -1;
          b.beams.push({
            headIdx: h, x: hp[h].x, y: hp[h].y,
            angle: aimAngle - sweepDir * 0.6,
            sweepStart: aimAngle - sweepDir * 0.6,
            sweepEnd: aimAngle + sweepDir * 0.6,
            timer: 0, maxTimer: 110, width: 18,
          });
        }
        // Scatter sparks along beam during attack
        if (neck.attackTimer % 8 === 0) {
          const beamAngle = b.beams.length > 0 ? b.beams[b.beams.length - 1].angle : 0;
          const sparkDist = 80 + Math.random() * 200;
          const sx = hp[h].x + Math.cos(beamAngle) * sparkDist;
          const sy = hp[h].y + Math.sin(beamAngle) * sparkDist;
          spawnParticles(sx, sy, '#ff6644', 3, 2, 10, 2);
        }
        break;
      }
      case 'breath': {
        // Blue head: cone breath — dense fan every 6 frames during attack
        if (neck.attackTimer % 6 === 0) {
          const breathAngle = angleToward(hp[h], player);
          const count = 8 + b.phase * 2 + (heads[h].regenCount > 0 ? 3 : 0);
          const spread = 0.9 + b.phase * 0.15;
          fireFan(hp[h].x, hp[h].y, count, spread, 2.8 + b.phase * 0.3, headColors[h], breathAngle);
        }
        // Post-regen: add slow heavy bullets every 18 frames
        if (heads[h].regenCount > 0 && neck.attackTimer % 18 === 0) {
          const a = angleToward(hp[h], player) + (Math.random() - 0.5) * 0.4;
          enemyBullets.push({ x: hp[h].x, y: hp[h].y, vx: Math.cos(a) * 1.5, vy: Math.sin(a) * 1.5, size: 8, color: '#88ccff', type: 'round' });
        }
        break;
      }
      case 'glob': {
        // Purple head: spit 2-3 globs that become persistent area denial
        if (neck.attackTimer === 1) {
          const globCount = 2 + (b.phase >= 1 ? 1 : 0);
          for (let g = 0; g < globCount; g++) {
            // Aim at positions near the player, spread out
            const tgtX = player.x + (g - (globCount - 1) / 2) * 80 + (Math.random() - 0.5) * 40;
            const tgtY = player.y + (Math.random() - 0.5) * 60;
            const clampX = Math.max(30, Math.min(W - 30, tgtX));
            const clampY = Math.max(100, Math.min(H - 60, tgtY));
            const a = Math.atan2(clampY - hp[h].y, clampX - hp[h].x);
            enemyBullets.push({
              x: hp[h].x, y: hp[h].y,
              vx: Math.cos(a) * 2.2, vy: Math.sin(a) * 2.2,
              size: 10, color: '#bb55ff', type: 'round',
              isGlob: true, globTargetX: clampX, globTargetY: clampY,
              globOwner: b, globDuration: (heads[h].regenCount > 0 ? 480 : 360),
            });
          }
        }
        break;
      }
    }
  }

  // Body desperation: when 0 heads alive and NOT exposed, body fires rings
  if (b.headsAlive === 0 && !b.exposedActive && b.shootTimer % 40 === 0) {
    fireCircle(b.x, b.y + 50, 10, 2.5, '#cc44ff', b.angle);
  }
}

// ---- WAVE SYSTEM ----
function spawnWave() {
  wave++;
  waveTimer = 0;

  if (wave % 5 === 0) {
    const bossType = Math.min(3, Math.ceil(wave / 5));
    const boss = createBoss(bossType);
    boss.hp += wave * 20;
    boss.maxHp = boss.hp;
    bosses.push(boss);
    return;
  }

  const patterns = [
    () => {
      for (let i = 0; i < 7; i++) {
        const ii = i;
        setTimeout(() => {
          const e = createEnemy('grunt', W / 2 - 80 + (ii % 2 === 0 ? -1 : 1) * Math.floor(ii / 2) * 50, -30);
          const sx = e.x;
          e.path = (t) => ({ x: sx, y: -30 + t * 200 });
          e.pathSpeed = 0.005;
          enemies.push(e);
        }, i * 160);
      }
    },
    () => {
      const fromLeft = Math.random() > 0.5;
      for (let i = 0; i < 6; i++) {
        const ii = i;
        setTimeout(() => {
          const startX = fromLeft ? -30 : W + 30;
          const dir = fromLeft ? 1 : -1;
          const sy = 100 + ii * 30;
          const e = createEnemy('swooper', startX, sy);
          e.path = (t) => ({ x: startX + t * 400 * dir, y: sy + Math.sin(t * 8) * 60 });
          e.pathSpeed = 0.006;
          enemies.push(e);
        }, i * 100);
      }
    },
    () => {
      for (let i = 0; i < 4; i++) {
        const ii = i;
        const sx = 80 + ii * 110;
        const e = createEnemy('spinner', sx, -30);
        e.path = (t) => ({ x: sx + Math.sin(t * 4 + ii) * 30, y: -30 + t * 150 });
        e.pathSpeed = 0.005;
        enemies.push(e);
      }
    },
    () => {
      const tank = createEnemy('tank', W / 2, -40);
      tank.path = (t) => ({ x: W / 2 + Math.sin(t * 3) * 100, y: -40 + t * 100 });
      tank.pathSpeed = 0.005;
      enemies.push(tank);
      for (let i = 0; i < 3; i++) {
        const ii = i;
        setTimeout(() => {
          const sx = W / 2 + (ii - 1) * 80;
          const e = createEnemy('grunt', sx, -30);
          e.path = (t) => ({ x: sx + Math.sin(t * 3) * 50, y: -30 + t * 130 });
          e.pathSpeed = 0.005;
          enemies.push(e);
        }, 300);
      }
    },
    () => {
      for (let i = 0; i < 3; i++) {
        const ii = i;
        const sx = 100 + ii * 140;
        const e = createEnemy('sniper', sx, -30);
        e.path = (t) => {
          if (t < 0.5) return { x: sx, y: -30 + t * 300 };
          return { x: sx + Math.sin((t - 0.5) * 6) * 40, y: 120 };
        };
        e.pathSpeed = 0.004;
        enemies.push(e);
      }
    },
    () => {
      const cx = W / 2, cy = -30;
      for (let i = 0; i < 8; i++) {
        const a = (i / 8) * Math.PI * 2;
        const e = createEnemy('grunt', cx, cy);
        e.path = (t) => ({ x: cx + Math.cos(a + t * 3) * (40 + t * 60), y: cy + t * 180 });
        e.pathSpeed = 0.004;
        enemies.push(e);
      }
    },
  ];

  const count = Math.min(3, 1 + Math.floor(wave / 3));
  for (let i = 0; i < count; i++) {
    setTimeout(() => patterns[randInt(0, patterns.length - 1)](), i * 1500);
  }
}

// ---- WAVE FORMATION PATTERNS ----
// Each function spawns enemies using the existing path system.
// Used by both the campaign wave spawner and can be called by endless mode.

const WAVE_PATTERNS = {
  VERTICAL_COLUMN(opts) {
    const type = opts.types[0] || 'grunt';
    const n = opts.count || 5;
    for (let i = 0; i < n; i++) {
      const ii = i;
      setTimeout(() => {
        const sx = W / 2 - ((n-1)/2 - ii) * 50;
        const e = createEnemy(type, sx, -30);
        e.path = t => ({ x: sx, y: -30 + t * 200 });
        e.pathSpeed = 0.005;
        enemies.push(e);
      }, i * 160);
    }
  },

  SIDE_SWOOP(opts) {
    const type = opts.types[0] || 'swooper';
    const n = opts.count || 6;
    const fromLeft = opts.side === 'left';
    for (let i = 0; i < n; i++) {
      const ii = i;
      setTimeout(() => {
        const startX = fromLeft ? -30 : W + 30;
        const dir = fromLeft ? 1 : -1;
        const sy = 100 + ii * 30;
        const e = createEnemy(type, startX, sy);
        e.path = t => ({ x: startX + t * 400 * dir, y: sy + Math.sin(t * 8) * 60 });
        e.pathSpeed = 0.006;
        enemies.push(e);
      }, i * 100);
    }
  },

  SPINNER_DESCENT(opts) {
    const type = opts.types[0] || 'spinner';
    const n = opts.count || 4;
    for (let i = 0; i < n; i++) {
      const sx = 80 + i * (W - 160) / Math.max(1, n - 1);
      const e = createEnemy(type, sx, -30);
      const ii = i;
      e.path = t => ({ x: sx + Math.sin(t * 4 + ii) * 30, y: -30 + t * 150 });
      e.pathSpeed = 0.005;
      enemies.push(e);
    }
  },

  CHEVRON(opts) {
    const type = opts.types[0] || 'grunt';
    const n = opts.count || 5;
    const cx = W / 2;
    for (let i = 0; i < n; i++) {
      const ii = i;
      setTimeout(() => {
        // V-shape: leader at center, wings spread out
        const row = ii === 0 ? 0 : Math.ceil(ii / 2);
        const side = ii % 2 === 0 ? 0 : (ii % 4 < 2 ? -1 : 1);
        const sx = cx + side * row * 45;
        const startY = -30 - row * 20;
        const e = createEnemy(type, sx, startY);
        e.path = t => ({ x: sx + side * t * 20, y: startY + t * 220 });
        e.pathSpeed = 0.004;
        enemies.push(e);
      }, i * 80);
    }
  },

  PINCER(opts) {
    const type = opts.types[0] || 'swooper';
    const n = opts.count || 6;
    const half = Math.ceil(n / 2);
    for (let i = 0; i < half; i++) {
      const ii = i;
      setTimeout(() => {
        // Left group
        const eL = createEnemy(type, -30, 80 + ii * 40);
        eL.path = t => ({
          x: -30 + t * 300 + Math.sin(t * 4) * 20,
          y: 80 + ii * 40 + t * 100
        });
        eL.pathSpeed = 0.005;
        enemies.push(eL);
        // Right group
        const eR = createEnemy(type, W + 30, 80 + ii * 40);
        eR.path = t => ({
          x: W + 30 - t * 300 - Math.sin(t * 4) * 20,
          y: 80 + ii * 40 + t * 100
        });
        eR.pathSpeed = 0.005;
        enemies.push(eR);
      }, i * 120);
    }
  },

  CURTAIN_WALL(opts) {
    const n = opts.count || 7;
    const types = opts.types || ['grunt'];
    for (let i = 0; i < n; i++) {
      const sx = 40 + i * ((W - 80) / (n - 1));
      // Put a tank at random positions in the wall
      const type = (types.includes('tank') && (i === 2 || i === n - 3)) ? 'tank' : types[0];
      const e = createEnemy(type, sx, -30);
      const sxi = sx;
      e.path = t => ({ x: sxi, y: -30 + t * 160 });
      e.pathSpeed = 0.003;
      enemies.push(e);
    }
  },

  STREAM(opts) {
    const type = opts.types[0] || 'grunt';
    const n = opts.count || 8;
    const fromLeft = opts.side !== 'right';
    const startX = fromLeft ? -30 : W + 30;
    const dir = fromLeft ? 1 : -1;
    for (let i = 0; i < n; i++) {
      const ii = i;
      setTimeout(() => {
        const e = createEnemy(type, startX, -20);
        e.path = t => ({
          x: startX + t * 500 * dir,
          y: -20 + t * 100 + Math.sin(t * 6 + ii * 0.5) * 50
        });
        e.pathSpeed = 0.005;
        enemies.push(e);
      }, i * 120);
    }
  },

  CROSSING_STREAMS(opts) {
    const type = opts.types[0] || 'grunt';
    const n = opts.count || 8;
    const half = Math.ceil(n / 2);
    for (let i = 0; i < half; i++) {
      const ii = i;
      setTimeout(() => {
        // Left to right stream
        const e1 = createEnemy(type, -20, -20 - ii * 10);
        e1.path = t => ({ x: -20 + t * 500, y: -20 + t * 300 - ii * 10 });
        e1.pathSpeed = 0.004;
        enemies.push(e1);
        // Right to left stream
        const e2 = createEnemy(type, W + 20, -20 - ii * 10);
        e2.path = t => ({ x: W + 20 - t * 500, y: -20 + t * 300 - ii * 10 });
        e2.pathSpeed = 0.004;
        enemies.push(e2);
      }, i * 140);
    }
  },

  SPLIT(opts) {
    const type = opts.types[0] || 'grunt';
    const n = opts.count || 6;
    for (let i = 0; i < n; i++) {
      const sx = W / 2 + (i - n / 2) * 15;
      const e = createEnemy(type, sx, -30);
      const side = i < n / 2 ? -1 : 1;
      const sxi = sx;
      e.path = t => {
        if (t < 0.4) return { x: sxi, y: -30 + t * 600 };
        const splitT = t - 0.4;
        return { x: sxi + splitT * 300 * side, y: -30 + 0.4 * 600 + splitT * 200 };
      };
      e.pathSpeed = 0.004;
      enemies.push(e);
    }
  },

  CAGE(opts) {
    const n = opts.count || 8;
    const types = opts.types || ['grunt'];
    const tankType = types.includes('tank') ? 'tank' : types[0];
    const gruntType = types[0];
    // Rectangle perimeter at y=200-400, x=80-400
    const positions = [
      {x:80,y:200}, {x:240,y:200}, {x:400,y:200},    // top
      {x:400,y:300}, {x:400,y:400},                    // right
      {x:240,y:400}, {x:80,y:400},                     // bottom
      {x:80,y:300},                                      // left
    ];
    for (let i = 0; i < Math.min(n, positions.length); i++) {
      const ii = i;
      const target = positions[i];
      const type = i === positions.length - 1 ? tankType : gruntType;
      setTimeout(() => {
        const e = createEnemy(type, target.x, -30);
        const tx = target.x, ty = target.y;
        e.path = t => {
          if (t < 0.3) return { x: tx, y: -30 + t / 0.3 * (ty + 30) };
          return { x: tx + Math.sin((t - 0.3) * 4) * 10, y: ty };
        };
        e.pathSpeed = 0.003;
        enemies.push(e);
      }, i * 80);
    }
  },

  BRACKET(opts) {
    const types = opts.types || ['tank', 'grunt'];
    const sideType = types[0] || 'tank';
    const centerType = types[1] || types[0] || 'spinner';
    // Left column
    for (let i = 0; i < 3; i++) {
      const sy = 100 + i * 100;
      const e = createEnemy(sideType, 50, -30);
      e.path = t => ({ x: 50 + Math.sin(t * 3) * 15, y: -30 + t * (sy + 30) / 0.5 });
      e.pathSpeed = 0.003;
      enemies.push(e);
    }
    // Right column
    for (let i = 0; i < 3; i++) {
      const sy = 100 + i * 100;
      const e = createEnemy(sideType, W - 50, -30);
      e.path = t => ({ x: W - 50 + Math.sin(t * 3) * 15, y: -30 + t * (sy + 30) / 0.5 });
      e.pathSpeed = 0.003;
      enemies.push(e);
    }
    // Center threat
    setTimeout(() => {
      const e = createEnemy(centerType, W / 2, -30);
      e.path = t => ({ x: W / 2 + Math.sin(t * 5) * 60, y: -30 + t * 150 });
      e.pathSpeed = 0.004;
      enemies.push(e);
    }, 500);
  },

  ANCHOR(opts) {
    const types = opts.types || ['tank', 'grunt'];
    const centerType = types[0] || 'tank';
    const orbitType = types[1] || types[0] || 'grunt';
    // Center tank
    const tank = createEnemy(centerType, W / 2, -40);
    tank.path = t => ({ x: W / 2 + Math.sin(t * 2) * 40, y: Math.min(-40 + t * 200, 200) });
    tank.pathSpeed = 0.004;
    enemies.push(tank);
    // Orbiting escorts
    setTimeout(() => {
      for (let i = 0; i < 4; i++) {
        const a = (i / 4) * Math.PI * 2;
        const e = createEnemy(orbitType, W / 2, 200);
        const ai = a;
        e.path = t => ({
          x: W / 2 + Math.sin(t * 2) * 40 + Math.cos(ai + t * 8) * 80,
          y: 200 + Math.sin(ai + t * 8) * 80 + t * 30
        });
        e.pathSpeed = 0.003;
        enemies.push(e);
      }
    }, 600);
  },

  SNIPER_ALLEY(opts) {
    const n = opts.count || 3;
    for (let i = 0; i < n; i++) {
      const ii = i;
      setTimeout(() => {
        const sx = 100 + ii * 140;
        const targetY = 150 + ii * 80;
        const e = createEnemy('sniper', sx, -30);
        e.path = t => {
          if (t < 0.4) return { x: sx, y: -30 + t / 0.4 * (targetY + 30) };
          return { x: sx + Math.sin((t - 0.4) * 5) * 30, y: targetY };
        };
        e.pathSpeed = 0.003;
        enemies.push(e);
      }, i * 500);
    }
  },

  REVOLVING_DOOR(opts) {
    const types = opts.types || ['spinner', 'tank', 'grunt'];
    const positions = [
      { dx: -50, dy: -50 }, { dx: 50, dy: -50 },
      { dx: 50, dy: 50 },  { dx: -50, dy: 50 },
    ];
    const cx = W / 2;
    for (let i = 0; i < 4; i++) {
      const type = types[i % types.length];
      const p = positions[i];
      const e = createEnemy(type, cx + p.dx, -60);
      const pdx = p.dx, pdy = p.dy;
      e.path = t => {
        const cy = Math.min(-60 + t * 300, 250);
        const rotT = t * 1.5;
        const cos = Math.cos(rotT), sin = Math.sin(rotT);
        return {
          x: cx + pdx * cos - pdy * sin,
          y: cy + pdx * sin + pdy * cos
        };
      };
      e.pathSpeed = 0.003;
      enemies.push(e);
    }
  },

  BREATHING_RING(opts) {
    const type = opts.types[0] || 'spinner';
    const n = opts.count || 6;
    const cx = W / 2;
    for (let i = 0; i < n; i++) {
      const a = (i / n) * Math.PI * 2;
      const e = createEnemy(type, cx, -30);
      const ai = a;
      e.path = t => {
        const cy = Math.min(-30 + t * 300, 280);
        const radius = 80 + Math.sin(t * 5) * 60;
        return {
          x: cx + Math.cos(ai + t * 2) * radius,
          y: cy + Math.sin(ai + t * 2) * radius * 0.5
        };
      };
      e.pathSpeed = 0.003;
      enemies.push(e);
    }
  },

  SPOKE_WHEEL(opts) {
    const types = opts.types || ['spinner', 'grunt'];
    const centerType = types[0] || 'spinner';
    const spokeType = types[1] || types[0] || 'grunt';
    // Center spinner
    const center = createEnemy(centerType, W / 2, -40);
    center.path = t => ({ x: W / 2, y: Math.min(-40 + t * 200, 220) + Math.sin(t * 3) * 20 });
    center.pathSpeed = 0.003;
    enemies.push(center);
    // 4 spokes
    setTimeout(() => {
      for (let i = 0; i < 4; i++) {
        const a = (i / 4) * Math.PI * 2;
        const e = createEnemy(spokeType, W / 2, 220);
        const ai = a;
        e.path = t => ({
          x: W / 2 + Math.cos(ai + t * 6) * 100,
          y: 220 + Math.sin(t * 3) * 20 + Math.sin(ai + t * 6) * 100
        });
        e.pathSpeed = 0.003;
        enemies.push(e);
      }
    }, 400);
  },

  ESCALATION_LADDER(opts) {
    const types = opts.types || ['grunt', 'spinner', 'sniper'];
    // Sub-wave 1: 3 of type 0
    for (let i = 0; i < 3; i++) {
      const sx = W / 2 + (i - 1) * 60;
      const e = createEnemy(types[0], sx, -30);
      const sxi = sx;
      e.path = t => ({ x: sxi, y: -30 + t * 180 });
      e.pathSpeed = 0.005;
      enemies.push(e);
    }
    // Sub-wave 2: 4 of type 0 + 1 of type 1
    setTimeout(() => {
      for (let i = 0; i < 4; i++) {
        const sx = 60 + i * 120;
        const e = createEnemy(types[0], sx, -30);
        const sxi = sx;
        e.path = t => ({ x: sxi, y: -30 + t * 180 });
        e.pathSpeed = 0.005;
        enemies.push(e);
      }
      const e = createEnemy(types[1] || types[0], W / 2, -30);
      e.path = t => ({ x: W / 2 + Math.sin(t * 4) * 40, y: -30 + t * 150 });
      e.pathSpeed = 0.004;
      enemies.push(e);
    }, 2000);
    // Sub-wave 3: 5 of type 0 + 1 of type 1 + 1 of type 2
    setTimeout(() => {
      for (let i = 0; i < 5; i++) {
        const sx = 40 + i * 100;
        const e = createEnemy(types[0], sx, -30);
        const sxi = sx;
        e.path = t => ({ x: sxi, y: -30 + t * 200 });
        e.pathSpeed = 0.005;
        enemies.push(e);
      }
      const e1 = createEnemy(types[1] || types[0], 120, -30);
      e1.path = t => ({ x: 120 + Math.sin(t * 4) * 40, y: -30 + t * 150 });
      e1.pathSpeed = 0.004;
      enemies.push(e1);
      const e2 = createEnemy(types[2] || types[1] || types[0], 360, -30);
      e2.path = t => ({ x: 360 + Math.sin(t * 4) * 40, y: -30 + t * 150 });
      e2.pathSpeed = 0.004;
      enemies.push(e2);
    }, 4000);
  },

  DECOY_AND_AMBUSH(opts) {
    const types = opts.types || ['grunt', 'spinner'];
    const decoyType = types[0];
    const ambushType = types[1] || 'sniper';
    // Decoy V
    for (let i = 0; i < 3; i++) {
      const sx = W / 2 + (i - 1) * 50;
      const e = createEnemy(decoyType, sx, -30);
      const sxi = sx;
      e.path = t => ({ x: sxi, y: -30 + t * 200 });
      e.pathSpeed = 0.005;
      enemies.push(e);
    }
    // Ambush flankers (delayed)
    setTimeout(() => {
      const eL = createEnemy(ambushType, -30, 280);
      eL.path = t => {
        if (t < 0.3) return { x: -30 + t / 0.3 * 90, y: 280 };
        return { x: 60 + Math.sin((t - 0.3) * 5) * 20, y: 280 };
      };
      eL.pathSpeed = 0.003;
      enemies.push(eL);
      const eR = createEnemy(ambushType, W + 30, 280);
      eR.path = t => {
        if (t < 0.3) return { x: W + 30 - t / 0.3 * 90, y: 280 };
        return { x: W - 60 + Math.sin((t - 0.3) * 5) * 20, y: 280 };
      };
      eR.pathSpeed = 0.003;
      enemies.push(eR);
    }, 800);
  },

  FALSE_RETREAT(opts) {
    const type = opts.types[0] || 'swooper';
    const n = opts.count || 5;
    for (let i = 0; i < n; i++) {
      const sx = 80 + i * ((W - 160) / Math.max(1, n - 1));
      const e = createEnemy(type, sx, -30);
      const sxi = sx;
      e.path = t => {
        if (t < 0.3) return { x: sxi, y: -30 + t / 0.3 * 330 };         // descend to 300
        if (t < 0.5) return { x: sxi, y: 300 - (t - 0.3) / 0.2 * 200 }; // retreat to 100
        return { x: sxi + Math.sin(t * 8) * 30, y: 100 + (t - 0.5) * 600 }; // fast dive
      };
      e.pathSpeed = 0.004;
      enemies.push(e);
    }
  },
};

// ---- CAMPAIGN WAVE SPAWNER ----
function spawnCampaignWave() {
  if (!campaignLevel) return;
  const waves = campaignLevel.waves;
  if (campaignWaveIndex >= waves.length) {
    campaignComplete = true;
    return;
  }

  const waveDef = waves[campaignWaveIndex];
  campaignWaveIndex++;
  wave = campaignWaveIndex;
  waveTimer = 0;

  if (waveDef.pattern === 'BOSS') {
    const boss = createBoss(waveDef.bossType);
    boss.hp = waveDef.bossHP;
    boss.maxHp = waveDef.bossHP;
    bosses.push(boss);
    return;
  }

  const patternFn = WAVE_PATTERNS[waveDef.pattern];
  if (patternFn) {
    patternFn(waveDef);
  }
}

// ---- ITEMS ----
function spawnItem(x, y, type) {
  items.push({ x, y, vy: -2, gravity: 0.05, type, life: 300, size: 8, collected: false });
}

// ---- ROGUELIKE POWERUP FUNCTIONS ----
function applyModFx(mods, fx) {
  for (const [key, val] of Object.entries(fx)) {
    if (typeof val === 'boolean') mods[key] = mods[key] || val;
    else if (key.endsWith('Mult') || key.endsWith('Pct')) mods[key] *= val;
    else if (val !== null) mods[key] += val;
  }
}

function resolveModifiers() {
  const mods = {
    damageMult: 1, shootDelayMult: 1, bulletSpeedMult: 1,
    speedMult: 1, focusSpeedMult: 1, focusDamageMult: 1,
    collectRadiusMult: 1, grazeRadiusBonus: 0, grazeScoreMult: 1,
    scoreKillMult: 1, invincBonus: 0, bombDamageMult: 1,
    pierceCount: 0, homingStrength: 0, backfireStreams: 0,
    splitOnHit: false, autoBomb: false, secondWind: false,
    orbitalBlades: 0, bulletEatChance: 0,
    chainTargets: 0, chainDamagePct: 0,
    maxHpBonus: 0, maxHpOverride: null,
    bombBonus: 0, extraStreams: 0, sideShots: 0,
    hitboxShrink: 0, regenInterval: 0, reflectChance: 0,
    dropRateMult: 1, killHealChance: 0,
  };

  // Layer 1: Equipment (campaign only)
  if (gameMode === 'campaign') {
    const eq = saveData.equipped;
    for (const slotId of Object.values(eq)) {
      if (!slotId) continue;
      const def = EQUIPMENT_DEFS[slotId];
      if (def && def.effect) {
        const fx = {};
        def.effect(fx);
        // The effect function mutates the passed object directly
      }
    }
    // Re-apply using a temporary object approach
    for (const slotId of Object.values(eq)) {
      if (!slotId) continue;
      const def = EQUIPMENT_DEFS[slotId];
      if (def && def.effect) {
        def.effect(mods);
      }
    }
  }

  // Layer 2: Roguelike powerups (both modes)
  for (const [id, stacks] of Object.entries(runPowerups.collected)) {
    const def = ROGUELIKE_POWERUPS.find(p => p.id === id);
    if (!def) continue;
    const fx = def.effect(stacks);
    applyModFx(mods, fx);
  }
  resolvedMods = mods;
}

function selectWeightedPowerups(count) {
  const pool = ROGUELIKE_POWERUPS.filter(p => {
    const current = runPowerups.collected[p.id] || 0;
    return current < p.maxStacks;
  });
  if (pool.length === 0) return [];
  const selected = [];
  const remaining = [...pool];
  for (let i = 0; i < count && remaining.length > 0; i++) {
    const totalWeight = remaining.reduce((sum, p) => sum + p.rarity.weight, 0);
    let roll = Math.random() * totalWeight;
    for (let j = 0; j < remaining.length; j++) {
      roll -= remaining[j].rarity.weight;
      if (roll <= 0) {
        selected.push(remaining[j]);
        remaining.splice(j, 1);
        break;
      }
    }
  }
  // Pity: after 3+ bosses, guarantee at least one non-Common
  if (runPowerups.bossesDefeated >= 3 && selected.every(p => p.rarity === RARITY.COMMON)) {
    const better = pool.filter(p => p.rarity !== RARITY.COMMON);
    if (better.length > 0) selected[Math.floor(Math.random() * selected.length)] = better[Math.floor(Math.random() * better.length)];
  }
  return selected;
}

function spawnPowerupChoices(x, y) {
  powerupSelectActive = true;
  powerupCollectedThisBoss = false;
  runPowerups.bossesDefeated++;
  powerupChoices = [];
  const choices = selectWeightedPowerups(3);
  const spread = 80;
  const offsets = choices.length === 3 ? [-spread, 0, spread] : choices.length === 2 ? [-spread/2, spread/2] : [0];
  for (let i = 0; i < choices.length; i++) {
    powerupChoices.push({
      x: Math.max(30, Math.min(W - 30, x + offsets[i])),
      y: y, vy: -1.5, gravity: 0.03,
      powerup: choices[i], life: 900, size: 18,
      bobPhase: Math.random() * Math.PI * 2, collected: false,
    });
  }
}

function collectPowerup(def) {
  if (powerupCollectedThisBoss) return;
  powerupCollectedThisBoss = true;
  const current = runPowerups.collected[def.id] || 0;
  runPowerups.collected[def.id] = Math.min(current + 1, def.maxStacks);
  if (def.onPickup) def.onPickup();
  resolveModifiers();
  spawnParticles(player.x, player.y, def.rarity.color, 30, 5, 30, 3);
  spawnParticles(player.x, player.y, '#ffffff', 15, 3, 20, 2);
  shakeTimer = 10; shakeIntensity = 4; slowmoTimer = 20;
  powerupAnnouncement = { name: def.name, desc: def.desc, rarity: def.rarity, timer: 150 };
}

function createPlayerBullet(props) {
  const focused = isFocused();
  let dmgMult = resolvedMods.damageMult;
  if (focused) dmgMult *= resolvedMods.focusDamageMult;
  const b = {
    ...props,
    damage: props.damage * dmgMult,
    vx: props.vx * resolvedMods.bulletSpeedMult,
    vy: props.vy * resolvedMods.bulletSpeedMult,
  };
  if (resolvedMods.pierceCount > 0 && !b.pierce) {
    b.pierce = true;
    b.pierceRemaining = resolvedMods.pierceCount;
  }
  if (resolvedMods.homingStrength > 0 && (props.type === 'side' || props.type === 'wide')) {
    b.homing = resolvedMods.homingStrength;
  }
  playerBullets.push(b);
}

// ============================================================
//  DRAWING FUNCTIONS — Sprite-based with canvas effects
// ============================================================

// Helper: draw sprite centered with optional rotation/scale
function drawSprite(sprite, x, y, w, h, rot) {
  if (!sprite) return false;
  ctx.save();
  ctx.translate(x, y);
  if (rot) ctx.rotate(rot);
  ctx.drawImage(sprite, -w / 2, -h / 2, w, h);
  ctx.restore();
  return true;
}

// Helper: draw spritesheet frame
function drawSpriteFrame(sprite, x, y, frameW, frameH, frame, drawW, drawH) {
  if (!sprite) return false;
  const cols = Math.floor(sprite.width / frameW);
  const sx = (frame % cols) * frameW;
  const sy = Math.floor(frame / cols) * frameH;
  ctx.drawImage(sprite, sx, sy, frameW, frameH, x - drawW / 2, y - drawH / 2, drawW, drawH);
  return true;
}

// ---- DRAW TILED SCROLLING BACKGROUND ----
function drawBackground() {
  // Tiled background
  if (img.bgTile) {
    const tileH = 256, tileW = 256;
    const tilesX = Math.ceil(W / tileW) + 1;
    const tilesY = Math.ceil(H / tileH) + 2;
    const offsetY = bgScrollY % tileH;
    for (let ty = -1; ty < tilesY; ty++) {
      for (let tx = 0; tx < tilesX; tx++) {
        ctx.drawImage(img.bgTile, tx * tileW, ty * tileH + offsetY, tileW, tileH);
      }
    }
  } else {
    ctx.fillStyle = '#0a0a15';
    ctx.fillRect(0, 0, W, H);
  }

  // Decorative meteors (far background)
  for (const m of bgMeteors) {
    const meteorKeys = ['meteorTiny1', 'meteorTiny2', 'meteorSmall1'];
    const mImg = img[meteorKeys[m.type]];
    if (mImg) {
      ctx.save();
      ctx.globalAlpha = m.alpha;
      ctx.translate(m.x, m.y);
      ctx.rotate(m.rot);
      ctx.drawImage(mImg, -m.size / 2, -m.size / 2, m.size, m.size);
      ctx.restore();
    }
  }

  // Parallax star layers
  for (const s of bgStars) {
    const twinkle = 0.7 + 0.3 * Math.sin(globalTime * 0.05 + s.twinkle);
    ctx.globalAlpha = s.brightness * twinkle;

    // Use star sprites for larger stars
    if (s.layer >= 2 && img.star1) {
      const starImgs = [img.star1, img.star2, img.star3];
      const si = starImgs[Math.floor(s.twinkle) % 3];
      if (si) {
        ctx.drawImage(si, s.x - s.size, s.y - s.size, s.size * 2, s.size * 2);
      }
    } else {
      ctx.fillStyle = `rgb(200, 220, 255)`;
      ctx.fillRect(s.x, s.y, s.size, s.size);
    }
  }
  ctx.globalAlpha = 1;

  // Side border gradient
  const borderGrad = ctx.createLinearGradient(0, 0, 30, 0);
  borderGrad.addColorStop(0, 'rgba(123, 104, 238, 0.15)');
  borderGrad.addColorStop(1, 'rgba(123, 104, 238, 0)');
  ctx.fillStyle = borderGrad;
  ctx.fillRect(0, 0, 30, H);
  const borderGrad2 = ctx.createLinearGradient(W, 0, W - 30, 0);
  borderGrad2.addColorStop(0, 'rgba(123, 104, 238, 0.15)');
  borderGrad2.addColorStop(1, 'rgba(123, 104, 238, 0)');
  ctx.fillStyle = borderGrad2;
  ctx.fillRect(W - 30, 0, 30, H);
}

// ---- DRAW PLAYER (Foozle — Vanguard) ----
function drawPlayerFoozle() {
  const p = player;
  ctx.save();
  ctx.translate(p.x, p.y);

  if (p.invincible > 0 && Math.floor(globalTime / 3) % 2) ctx.globalAlpha = 0.5;

  // Animated engine exhaust (drawn behind ship)
  p.engineTimer++;
  if (p.engineTimer >= 6) { p.engineTimer = 0; p.engineFrame++; }

  const engineImg = img.engineIdle;
  if (engineImg) {
    const frameW = 48, frameH = 48;
    const totalFrames = Math.floor(engineImg.width / frameW);
    const frame = p.engineFrame % totalFrames;
    const drawSize = 56;
    ctx.drawImage(engineImg, frame * frameW, 0, frameW, frameH,
      -drawSize / 2, 8, drawSize, drawSize);
  }

  // Choose player sprite based on HP
  const hpPct = p.hp / p.maxHp;
  let shipSprite;
  if (hpPct > 0.75) shipSprite = img.playerBase;
  else if (hpPct > 0.5) shipSprite = img.playerDmg1;
  else if (hpPct > 0.25) shipSprite = img.playerDmg2;
  else shipSprite = img.playerDmg3;

  const shipSize = 56;
  if (shipSprite) {
    ctx.drawImage(shipSprite, -shipSize / 2, -shipSize / 2, shipSize, shipSize);
  } else {
    ctx.fillStyle = '#ddeeff';
    ctx.beginPath();
    ctx.moveTo(0, -16); ctx.lineTo(-12, 10); ctx.lineTo(-6, 14); ctx.lineTo(6, 14); ctx.lineTo(12, 10);
    ctx.closePath(); ctx.fill();
  }

  // Engine glow effect (additive)
  ctx.globalCompositeOperation = 'lighter';
  const glowR = 20 + Math.sin(globalTime * 0.2) * 5;
  const thrustGrad = ctx.createRadialGradient(0, 20, 0, 0, 20, glowR);
  thrustGrad.addColorStop(0, 'rgba(80, 160, 255, 0.5)');
  thrustGrad.addColorStop(0.5, 'rgba(60, 80, 200, 0.2)');
  thrustGrad.addColorStop(1, 'rgba(60, 80, 200, 0)');
  ctx.fillStyle = thrustGrad;
  ctx.fillRect(-glowR, 10, glowR * 2, glowR);
  ctx.globalCompositeOperation = 'source-over';

  ctx.globalAlpha = 1;
  ctx.restore();
}

// ---- DRAW PLAYER (Kenney — Tempest / Bastion) ----
function drawPlayerKenney(baseKey, dmgKeys, shipColor) {
  const p = player;
  ctx.save();
  ctx.translate(p.x, p.y);

  if (p.invincible > 0 && Math.floor(globalTime / 3) % 2) ctx.globalAlpha = 0.5;

  // Programmatic engine glow behind ship
  const glowSize = 15 + Math.sin(globalTime * 0.3) * 3;
  const engineGrad = ctx.createRadialGradient(0, 18, 0, 0, 18, glowSize);
  const glowCol = shipColor || '#00ccff';
  engineGrad.addColorStop(0, glowCol + 'cc');
  engineGrad.addColorStop(0.5, glowCol + '44');
  engineGrad.addColorStop(1, glowCol + '00');
  ctx.fillStyle = engineGrad;
  ctx.fillRect(-glowSize, 10, glowSize * 2, glowSize * 1.5);

  // Draw base ship sprite
  const baseSprite = img[baseKey];
  const shipSize = 56;
  if (baseSprite) {
    ctx.drawImage(baseSprite, -shipSize / 2, -shipSize / 2, shipSize, shipSize);

    // Overlay damage sprite based on HP
    const hpPct = p.hp / p.maxHp;
    let dmgSprite = null;
    if (hpPct <= 0.25) dmgSprite = img[dmgKeys[2]];
    else if (hpPct <= 0.5) dmgSprite = img[dmgKeys[1]];
    else if (hpPct <= 0.75) dmgSprite = img[dmgKeys[0]];
    if (dmgSprite) {
      ctx.drawImage(dmgSprite, -shipSize / 2, -shipSize / 2, shipSize, shipSize);
    }
  } else {
    ctx.fillStyle = shipColor || '#ffffff';
    ctx.beginPath();
    ctx.moveTo(0, -16); ctx.lineTo(-14, 12); ctx.lineTo(14, 12);
    ctx.closePath(); ctx.fill();
  }

  // Engine glow effect (additive)
  ctx.globalCompositeOperation = 'lighter';
  const glowR = 18 + Math.sin(globalTime * 0.2) * 4;
  const thrustGrad = ctx.createRadialGradient(0, 20, 0, 0, 20, glowR);
  thrustGrad.addColorStop(0, glowCol + '88');
  thrustGrad.addColorStop(0.5, glowCol + '33');
  thrustGrad.addColorStop(1, glowCol + '00');
  ctx.fillStyle = thrustGrad;
  ctx.fillRect(-glowR, 10, glowR * 2, glowR);
  ctx.globalCompositeOperation = 'source-over';

  ctx.globalAlpha = 1;
  ctx.restore();
}

// ---- DRAW PLAYER (dispatch + shared elements) ----
function drawPlayer() {
  const p = player;
  if (!p.alive) return;

  const focused = isFocused();
  const cfg = gameMode === 'campaign' ? CAMPAIGN_SHIP : SHIP_CONFIGS[selectedShip];

  // Draw ship body
  if (cfg.drawType === 'foozle') {
    drawPlayerFoozle();
  } else if (cfg.drawType === 'kenney2') {
    drawPlayerKenney(cfg.baseSprite || 'ship2Base', cfg.dmgSprites || ['ship2Dmg1', 'ship2Dmg2', 'ship2Dmg3'], cfg.color || '#ff4466');
  } else {
    drawPlayerKenney(cfg.baseSprite || 'ship3Base', cfg.dmgSprites || ['ship3Dmg1', 'ship3Dmg2', 'ship3Dmg3'], cfg.color || '#44ff88');
  }

  // Shield bomb bubble (Bastion)
  if (shieldBombActive) {
    ctx.save();
    ctx.translate(p.x, p.y);
    const shieldImg = img.shieldInvinc;
    if (shieldImg) {
      const shieldFrameW = 64, shieldFrameH = 64;
      const totalShieldFrames = Math.floor(shieldImg.width / shieldFrameW);
      const shieldFrame = Math.floor(globalTime / 6) % totalShieldFrames;
      const sz = shieldBombRadius * 2.2;
      ctx.globalAlpha = 0.5 + Math.sin(globalTime * 0.15) * 0.2;
      ctx.drawImage(shieldImg, shieldFrame * shieldFrameW, 0, shieldFrameW, shieldFrameH,
        -sz / 2, -sz / 2, sz, sz);
    } else {
      // Fallback: programmatic bubble
      ctx.globalAlpha = 0.3 + Math.sin(globalTime * 0.15) * 0.1;
      ctx.strokeStyle = '#44ff88';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0, 0, shieldBombRadius, 0, Math.PI * 2); ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // Focus mode shield + hitbox
  if (focused) {
    ctx.save();
    ctx.translate(p.x, p.y);
    const shieldImg = img.shieldRound;
    if (shieldImg) {
      const shieldFrameW = 64, shieldFrameH = 64;
      const totalShieldFrames = Math.floor(shieldImg.width / shieldFrameW);
      const shieldFrame = Math.floor(globalTime / 8) % totalShieldFrames;
      ctx.globalAlpha = 0.7;
      ctx.drawImage(shieldImg, shieldFrame * shieldFrameW, 0, shieldFrameW, shieldFrameH,
        -36, -36, 72, 72);
      ctx.globalAlpha = 1;
    }
    ctx.strokeStyle = '#ff6ec7'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(0, 0, p.hitboxRadius + 4, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = '#ff6ec7';
    ctx.beginPath(); ctx.arc(0, 0, p.hitboxRadius, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }

  // Options (power level 4)
  const optCount = selectedShip === 2 ? 3 : 2; // Bastion gets 3 options
  if (p.power >= 4) {
    for (const opt of p.options) {
      ctx.save();
      ctx.translate(opt.x, opt.y);
      const optColor = SHIP_CONFIGS[selectedShip].color;
      ctx.globalCompositeOperation = 'lighter';
      const optGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);
      optGrad.addColorStop(0, optColor + 'ee');
      optGrad.addColorStop(0.5, optColor + '55');
      optGrad.addColorStop(1, optColor + '00');
      ctx.fillStyle = optGrad;
      ctx.fillRect(-10, -10, 20, 20);
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = optColor;
      ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    }
  }
}

// ---- DRAW ENEMY ----
function drawEnemy(e) {
  ctx.save();
  ctx.translate(e.x, e.y);

  const isFlash = e.flash > 0;
  if (isFlash) e.flash--;

  // Get sprite
  const sprite = img[e.spriteKey];
  const drawW = e.w + 16;
  const drawH = e.h + 14;

  if (e.type === 'spinner') {
    ctx.rotate(e.spinAngle || 0);
  }

  if (sprite) {
    if (isFlash) {
      // Flash white on hit
      ctx.globalCompositeOperation = 'source-over';
      ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
      ctx.globalCompositeOperation = 'source-atop';
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.fillRect(-drawW / 2, -drawH / 2, drawW, drawH);
      ctx.globalCompositeOperation = 'source-over';
    } else {
      ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
    }
  } else {
    // Fallback: programmatic
    ctx.fillStyle = isFlash ? '#ffffff' : e.color;
    switch (e.type) {
      case 'grunt':
        ctx.beginPath(); ctx.moveTo(0, 12); ctx.lineTo(-12, -8); ctx.lineTo(12, -8); ctx.closePath(); ctx.fill();
        break;
      case 'spinner':
        for (let i = 0; i < 4; i++) { ctx.rotate(Math.PI / 2); ctx.fillRect(-3, -14, 6, 14); }
        break;
      case 'tank':
        ctx.fillRect(-16, -12, 32, 24);
        break;
      case 'sniper':
        ctx.beginPath(); ctx.moveTo(0, -14); ctx.lineTo(10, 0); ctx.lineTo(0, 14); ctx.lineTo(-10, 0); ctx.closePath(); ctx.fill();
        break;
      case 'swooper':
        ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI, false);
        ctx.lineTo(-8, 5); ctx.quadraticCurveTo(0, -5, 8, 5); ctx.closePath(); ctx.fill();
        break;
      default:
        ctx.fillRect(-12, -12, 24, 24);
    }
  }

  // Subtle enemy glow
  ctx.globalCompositeOperation = 'lighter';
  const gR = drawW * 0.6;
  const eGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, gR);
  eGrad.addColorStop(0, e.color + '22');
  eGrad.addColorStop(1, e.color + '00');
  ctx.fillStyle = eGrad;
  ctx.fillRect(-gR, -gR, gR * 2, gR * 2);
  ctx.globalCompositeOperation = 'source-over';

  // HP bar for tougher enemies
  if (e.maxHp > 3) {
    const barW = 24;
    ctx.fillStyle = '#33333388';
    ctx.fillRect(-barW / 2, -e.h / 2 - 10, barW, 3);
    ctx.fillStyle = '#44ff44';
    ctx.fillRect(-barW / 2, -e.h / 2 - 10, barW * (e.hp / e.maxHp), 3);
  }
  ctx.restore();
}

// ---- DRAW BOSS ----
function drawMinibossExtras(b, drawW, drawH) {
  const t = globalTime;
  switch (b.type) {
    case 4: { // Jellyfish: phase-shifting glow + flowing tentacles + trail
      // Phase-shift alpha
      let phaseAlpha4 = 1.0;
      if (b.phaseState === 'fading') phaseAlpha4 = 1.0 - b.phaseTimer / 30;
      else if (b.phaseState === 'phased') phaseAlpha4 = 0.15 + Math.sin(t * 0.1) * 0.05;
      else if (b.phaseState === 'appearing') phaseAlpha4 = b.phaseTimer / 30;
      ctx.globalAlpha = phaseAlpha4;
      // Trail visualization (in world space)
      if (b.trailHistory.length > 2) {
        ctx.save();
        ctx.translate(-b.x, -b.y); // World coords
        ctx.globalCompositeOperation = 'lighter';
        for (let ti = 1; ti < b.trailHistory.length; ti++) {
          const tp = b.trailHistory[ti - 1];
          const tc = b.trailHistory[ti];
          const trailAlpha = (ti / b.trailHistory.length) * 0.2 * phaseAlpha4;
          ctx.strokeStyle = `rgba(68, 255, 238, ${trailAlpha})`;
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(tp.x, tp.y); ctx.lineTo(tc.x, tc.y); ctx.stroke();
        }
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();
      }
      // Tentacle glow lines
      ctx.globalCompositeOperation = 'lighter';
      for (let i = 0; i < 7; i++) {
        const ox = (i - 3) * 10;
        const sway1 = Math.sin(t * 0.05 + i * 0.9) * 12;
        const sway2 = Math.sin(t * 0.03 + i * 1.3) * 18;
        const tAlpha4 = (0.3 + Math.sin(t * 0.08 + i) * 0.15) * phaseAlpha4;
        ctx.strokeStyle = (i % 2 === 0 ? b.color : '#cc66ff') + Math.floor(tAlpha4 * 255).toString(16).padStart(2, '0');
        ctx.lineWidth = 2.5 - i * 0.15;
        ctx.beginPath();
        ctx.moveTo(ox, drawH * 0.25);
        ctx.quadraticCurveTo(ox + sway1, drawH * 0.45, ox + sway2, drawH * 0.75 + i * 3);
        ctx.stroke();
      }
      // Inner bell pulse
      const bellPulse4 = Math.sin(t * 0.1) * 0.15 + 0.85;
      const bellGrad4 = ctx.createRadialGradient(0, -drawH * 0.1, 0, 0, -drawH * 0.1, drawW * 0.3 * bellPulse4);
      bellGrad4.addColorStop(0, `rgba(255, 255, 255, ${0.13 * phaseAlpha4})`);
      bellGrad4.addColorStop(0.5, `rgba(68, 255, 238, ${0.09 * phaseAlpha4})`);
      bellGrad4.addColorStop(1, 'rgba(68, 255, 238, 0)');
      ctx.fillStyle = bellGrad4;
      ctx.beginPath();
      ctx.arc(0, -drawH * 0.1, drawW * 0.3 * bellPulse4, 0, Math.PI * 2);
      ctx.fill();
      // Phase-in flash
      if (b.phaseState === 'appearing' && b.phaseTimer < 10) {
        const flashAlpha = (10 - b.phaseTimer) / 10 * 0.4;
        const flashGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
        flashGrad.addColorStop(0, `rgba(255, 255, 255, ${flashAlpha})`);
        flashGrad.addColorStop(1, 'rgba(68, 255, 238, 0)');
        ctx.fillStyle = flashGrad;
        ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI * 2); ctx.fill();
      }
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1.0;
      break;
    }
    case 5: { // Scarab: charge glow + telegraph + craters + wing fold
      // Draw craters (in world space, not boss-relative)
      ctx.save();
      ctx.translate(-b.x, -b.y); // Undo the boss-relative transform
      for (const cr of b.craters) {
        const crFrac = cr.timer / cr.maxTimer;
        const crPulse = 0.3 + Math.sin(t * 0.1) * 0.15;
        // Crater ring
        ctx.strokeStyle = `rgba(255, 136, 0, ${crFrac * crPulse})`;
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cr.x, cr.y, 20 + (1 - crFrac) * 5, 0, Math.PI * 2); ctx.stroke();
        // Inner glow
        ctx.globalCompositeOperation = 'lighter';
        const crGrad = ctx.createRadialGradient(cr.x, cr.y, 0, cr.x, cr.y, 18);
        crGrad.addColorStop(0, `rgba(255, 170, 68, ${crFrac * crPulse * 0.4})`);
        crGrad.addColorStop(1, 'rgba(255, 136, 0, 0)');
        ctx.fillStyle = crGrad;
        ctx.beginPath(); ctx.arc(cr.x, cr.y, 18, 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }
      ctx.restore(); // Back to boss-relative
      // Telegraph glow — orange warning before charge
      if (b.aiState === 'TELEGRAPH') {
        ctx.globalCompositeOperation = 'lighter';
        const telPulse = Math.sin(b.aiTimer * 0.3) * 0.3 + 0.5;
        const telGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 40);
        telGrad.addColorStop(0, `rgba(255, 170, 68, ${telPulse * 0.6})`);
        telGrad.addColorStop(0.5, `rgba(255, 100, 0, ${telPulse * 0.3})`);
        telGrad.addColorStop(1, 'rgba(255, 80, 0, 0)');
        ctx.fillStyle = telGrad;
        ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.fill();
        // Aim indicator — line toward player
        const aimAngle = b.chargeHeading || 0;
        ctx.strokeStyle = `rgba(255, 200, 100, ${telPulse * 0.5})`;
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(aimAngle) * 60, Math.sin(aimAngle) * 60);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalCompositeOperation = 'source-over';
      }
      // Charge: intense motion flare
      if (b.charging) {
        ctx.globalCompositeOperation = 'lighter';
        const flareW5 = drawW * 0.7;
        const cGrad5 = ctx.createRadialGradient(0, 0, 0, 0, 0, flareW5);
        cGrad5.addColorStop(0, '#ffaa4488');
        cGrad5.addColorStop(0.3, '#ff880044');
        cGrad5.addColorStop(1, '#ff880000');
        ctx.fillStyle = cGrad5;
        ctx.beginPath(); ctx.arc(0, 0, flareW5, 0, Math.PI * 2); ctx.fill();
        // Trailing sparks behind charge direction
        const cDir = Math.atan2(b.chargeVy, b.chargeVx);
        for (let s = 0; s < 5; s++) {
          const sx = Math.cos(cDir + Math.PI) * (15 + s * 10) + rand(-5, 5);
          const sy = Math.sin(cDir + Math.PI) * (15 + s * 10) + rand(-5, 5);
          ctx.fillStyle = `rgba(255, 200, 68, ${0.5 - s * 0.08})`;
          ctx.beginPath(); ctx.arc(sx, sy, 3 - s * 0.4, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalCompositeOperation = 'source-over';
      }
      // Impact: flash
      if (b.aiState === 'IMPACT' && b.aiTimer < 10) {
        ctx.globalCompositeOperation = 'lighter';
        const impAlpha = (10 - b.aiTimer) / 10;
        const impGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
        impGrad.addColorStop(0, `rgba(255, 220, 100, ${impAlpha * 0.6})`);
        impGrad.addColorStop(1, 'rgba(255, 136, 0, 0)');
        ctx.fillStyle = impGrad;
        ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }
      // Wing shimmer — spread or folded
      const ws5 = b.wingsSpread ? 1.0 : 0.5;
      const wingShimmer5 = Math.sin(t * 0.06) * 0.3 + 0.2;
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = b.color + Math.floor(wingShimmer5 * 40).toString(16).padStart(2, '0');
      ctx.beginPath();
      ctx.arc(-drawW * 0.3 * ws5, 0, 12 * ws5, 0, Math.PI * 2);
      ctx.arc(drawW * 0.3 * ws5, 0, 12 * ws5, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
      break;
    }
    case 6: { // Moldorm-style segmented body chain — programmatic scales
      const bodySprite = img['serpentBody'];
      const tailSprite = img['serpentTail'];
      const lastIdx = b.segments.length - 1;
      // Draw connecting tissue between segments (behind everything)
      ctx.globalCompositeOperation = 'source-over';
      for (let i = 0; i <= lastIdx; i++) {
        const seg = b.segments[i];
        const sx = seg.x - b.x, sy = seg.y - b.y;
        const px = (i === 0) ? 0 : (b.segments[i - 1].x - b.x);
        const py = (i === 0) ? 0 : (b.segments[i - 1].y - b.y);
        const prevR = (i === 0) ? b.renderW * 0.4 : b.segments[i - 1].r;
        const connW = Math.min(prevR, seg.r) * 1.8;
        const connAlpha = 0.6 - i * 0.04;
        if (connAlpha > 0) {
          // Thick body-colored connector
          ctx.strokeStyle = `rgba(60, 45, 30, ${connAlpha})`;
          ctx.lineWidth = connW;
          ctx.lineCap = 'round';
          ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(sx, sy); ctx.stroke();
          // Darker spine line
          ctx.strokeStyle = `rgba(35, 55, 30, ${connAlpha * 0.5})`;
          ctx.lineWidth = connW * 0.3;
          ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(sx, sy); ctx.stroke();
        }
      }
      // Draw segments tail-to-head so head overlaps body
      for (let i = lastIdx; i >= 0; i--) {
        const seg = b.segments[i];
        const sx = seg.x - b.x;
        const sy = seg.y - b.y;
        const r = seg.r;
        const isTail = (i === lastIdx);
        const sprite = isTail ? tailSprite : bodySprite;
        ctx.save();
        ctx.translate(sx, sy);
        if (seg.heading !== undefined) ctx.rotate(seg.heading);
        if (sprite) {
          const aspect = sprite.width / sprite.height;
          // Scale based on radius — height is cross-section, width follows aspect
          const segH = r * 3.5;
          const segW = segH * aspect;
          ctx.drawImage(sprite, -segW / 2, -segH / 2, segW, segH);
        } else {
          // Fallback circle if sprite not loaded
          ctx.fillStyle = b.color;
          ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
        }
        // Tail tip energy glow
        if (isTail) {
          ctx.globalCompositeOperation = 'lighter';
          const tailPulse = 0.5 + Math.sin(t * 0.12) * 0.5;
          const tGrad = ctx.createRadialGradient(r * 0.5, 0, 0, 0, 0, r * 2.0);
          tGrad.addColorStop(0, `rgba(100, 200, 255, ${tailPulse * 0.3})`);
          tGrad.addColorStop(1, 'rgba(34, 180, 255, 0)');
          ctx.fillStyle = tGrad;
          ctx.beginPath(); ctx.arc(r * 0.5, 0, r * 2.0, 0, Math.PI * 2); ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        }
        ctx.restore();
      }
      ctx.globalCompositeOperation = 'source-over';
      break;
    }
    case 7: { // Sentinel: shield orbs with HP + vulnerability glow + destroyed shield ghosts
      const orbDist = 55;
      const sa7 = b.shieldsAlive;
      // Vulnerability window: core glows bright as signal to attack
      if (b.vulnerabilityActive) {
        ctx.globalCompositeOperation = 'lighter';
        const vPulse = 0.6 + Math.sin(t * 0.25) * 0.3;
        const vGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 45);
        vGrad.addColorStop(0, `rgba(255, 255, 200, ${vPulse * 0.5})`);
        vGrad.addColorStop(0.5, `rgba(68, 136, 255, ${vPulse * 0.3})`);
        vGrad.addColorStop(1, 'rgba(68, 136, 255, 0)');
        ctx.fillStyle = vGrad;
        ctx.beginPath(); ctx.arc(0, 0, 45, 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }
      // 0-shields exposed: core crackles with energy
      if (sa7 === 0) {
        ctx.globalCompositeOperation = 'lighter';
        const ePulse = 0.4 + Math.sin(t * 0.15) * 0.2;
        const eGrad = ctx.createRadialGradient(0, 0, 5, 0, 0, 35);
        eGrad.addColorStop(0, `rgba(255, 136, 68, ${ePulse})`);
        eGrad.addColorStop(1, 'rgba(255, 68, 68, 0)');
        ctx.fillStyle = eGrad;
        ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      }
      // Draw shield orbs
      ctx.globalCompositeOperation = 'lighter';
      for (let i = 0; i < b.orbCount; i++) {
        const oa = b.orbAngle + (i / b.orbCount) * Math.PI * 2;
        const ox = Math.cos(oa) * orbDist;
        const oy = Math.sin(oa) * orbDist;
        const shield = b.shields[i];
        if (shield.alive) {
          // Beam connection from core to alive shield
          const beamAlpha = 0.3 + Math.sin(t * 0.1 + i * 1.5) * 0.15;
          ctx.strokeStyle = b.color + Math.floor(beamAlpha * 255).toString(16).padStart(2, '0');
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(ox, oy); ctx.stroke();
          // Shield arc — 45-degree protective barrier
          const arcR = orbDist + 8;
          const arcSpan = Math.PI / 4; // 45 degrees
          ctx.strokeStyle = `rgba(100, 180, 255, ${0.5 + Math.sin(t * 0.08 + i) * 0.2})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(0, 0, arcR, oa - arcSpan / 2, oa + arcSpan / 2);
          ctx.stroke();
          // Orb glow — brightness proportional to HP
          const hpFrac = shield.hp / shield.maxHp;
          const orbR = 10 + hpFrac * 4;
          const oGrad = ctx.createRadialGradient(ox, oy, 0, ox, oy, orbR);
          oGrad.addColorStop(0, '#ffffff');
          oGrad.addColorStop(0.3, hpFrac > 0.5 ? b.color : '#ff8844');
          oGrad.addColorStop(1, hpFrac > 0.5 ? b.color + '00' : '#ff884400');
          ctx.fillStyle = oGrad;
          ctx.beginPath(); ctx.arc(ox, oy, orbR, 0, Math.PI * 2); ctx.fill();
          // Shield HP pip — small bar below orb
          ctx.globalCompositeOperation = 'source-over';
          ctx.fillStyle = '#333';
          ctx.fillRect(ox - 8, oy + orbR + 2, 16, 3);
          ctx.fillStyle = hpFrac > 0.5 ? '#44aaff' : hpFrac > 0.25 ? '#ffaa44' : '#ff4444';
          ctx.fillRect(ox - 8, oy + orbR + 2, 16 * hpFrac, 3);
          ctx.globalCompositeOperation = 'lighter';
        } else {
          // Destroyed shield — faint ghost orbiting, no arc
          const ghostAlpha = 0.08 + Math.sin(t * 0.05 + i * 2) * 0.04;
          ctx.strokeStyle = `rgba(100, 150, 255, ${ghostAlpha})`;
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(ox, oy); ctx.stroke();
          ctx.fillStyle = `rgba(100, 150, 255, ${ghostAlpha * 2})`;
          ctx.beginPath(); ctx.arc(ox, oy, 6, 0, Math.PI * 2); ctx.fill();
        }
      }
      // Core energy pulse
      const corePulse7 = Math.sin(t * 0.08) * 5 + 20;
      const coreGrad7 = ctx.createRadialGradient(0, 0, 0, 0, 0, corePulse7);
      coreGrad7.addColorStop(0, '#ffffff33');
      coreGrad7.addColorStop(0.5, b.color + '22');
      coreGrad7.addColorStop(1, '#00000000');
      ctx.fillStyle = coreGrad7;
      ctx.beginPath(); ctx.arc(0, 0, corePulse7, 0, Math.PI * 2); ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
      break;
    }
    case 8: { // Hydra: sprite-based body + textured necks + detailed heads + beams + globs
      const hColors = ['#ff4444', '#4488ff', '#cc44ff'];
      const hColorRGB = ['180,60,60', '60,120,200', '160,60,200'];
      const headSpriteKeys = ['hydraHeadRed', 'hydraHeadBlue', 'hydraHeadPurple'];
      const segSpriteKeys = ['hydraSegRed', 'hydraSegBlue', 'hydraSegPurple'];
      const heads = b.heads;
      const bodySprite = img['hydraBody'];
      const globSprite = img['hydraGlob'];

      // --- Draw body mass using pre-rendered sprite ---
      // Normal (source-over) blend: grokEdgeFade made black pixels transparent,
      // so creature detail (tentacles, flesh, orbs) renders opaquely over the
      // space background. Additive overlay adds energy glow on bright spots.
      if (bodySprite) {
        const bsW = 240;
        const bsH = bsW * (bodySprite.height / bodySprite.width);
        const breathe = 1 + Math.sin(t * 0.04) * 0.015;
        ctx.save();
        ctx.scale(breathe, breathe);
        // Main pass: normal compositing for full creature detail
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 0.92;
        ctx.drawImage(bodySprite, -bsW / 2, -bsH / 2 + 10, bsW, bsH);
        // Glow pass: additive for energy highlights (orbs, bright accents)
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.2;
        ctx.drawImage(bodySprite, -bsW / 2, -bsH / 2 + 10, bsW, bsH);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      // Glowing anchor points where necks attach (animated pulse over sprite)
      ctx.globalCompositeOperation = 'lighter';
      for (let h = 0; h < 3; h++) {
        const neck = b.necks[h];
        const ax = neck.anchorOfsX, ay = neck.anchorOfsY;
        const pulse = 0.4 + Math.sin(t * 0.08 + h * 2.1) * 0.2;
        const aR = 22 + pulse * 6;
        const aGrad = ctx.createRadialGradient(ax, ay, 0, ax, ay, aR);
        aGrad.addColorStop(0, `rgba(${hColorRGB[h]}, ${pulse * 0.7})`);
        aGrad.addColorStop(0.5, `rgba(${hColorRGB[h]}, ${pulse * 0.25})`);
        aGrad.addColorStop(1, `rgba(${hColorRGB[h]}, 0)`);
        ctx.fillStyle = aGrad;
        ctx.beginPath(); ctx.arc(ax, ay, aR, 0, Math.PI * 2); ctx.fill();
        // Energy tendrils from anchor downward
        if (heads[h].alive) {
          ctx.strokeStyle = `rgba(${hColorRGB[h]}, ${pulse * 0.15})`;
          ctx.lineWidth = 1.5;
          for (let v = 0; v < 3; v++) {
            const va = -Math.PI * 0.3 + v * Math.PI * 0.3 + Math.sin(t * 0.05 + h + v) * 0.2;
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.quadraticCurveTo(ax + Math.cos(va) * 15, ay + Math.sin(va) * 15, ax + Math.cos(va) * 30, ay + Math.sin(va) * 25);
            ctx.stroke();
          }
        }
      }

      // Exposed state: body glows intensely with pulsing overlay
      if (b.exposedActive) {
        const pulse = 0.5 + Math.sin(t * 0.2) * 0.3;
        const eGrad = ctx.createRadialGradient(0, 30, 0, 0, 30, 90);
        eGrad.addColorStop(0, `rgba(255, 120, 255, ${pulse * 0.8})`);
        eGrad.addColorStop(0.3, `rgba(200, 68, 255, ${pulse * 0.4})`);
        eGrad.addColorStop(0.7, `rgba(150, 40, 200, ${pulse * 0.15})`);
        eGrad.addColorStop(1, 'rgba(100, 20, 150, 0)');
        ctx.fillStyle = eGrad;
        ctx.beginPath(); ctx.arc(0, 30, 90, 0, Math.PI * 2); ctx.fill();
        // Crackle energy lines
        for (let c = 0; c < 5; c++) {
          const ca = (c / 5) * Math.PI * 2 + t * 0.03;
          ctx.strokeStyle = `rgba(255, 200, 255, ${0.3 + Math.sin(t * 0.3 + c) * 0.15})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(Math.cos(ca) * 20, 30 + Math.sin(ca) * 20);
          ctx.lineTo(Math.cos(ca) * 60 + Math.sin(t * 0.1 + c) * 10, 30 + Math.sin(ca) * 50);
          ctx.stroke();
        }
      }

      // --- Draw necks and heads in world space ---
      ctx.save();
      ctx.translate(-b.x, -b.y);
      for (let h = 0; h < 3; h++) {
        const neck = b.necks[h];
        const head = heads[h];
        const segs = neck.segments;
        if (segs.length < 2) continue;
        const isAlive = head.alive;
        const isRegen = !isAlive && head.regenTimer > 0;
        const neckAlpha = isAlive ? 1.0 : (isRegen ? 0.5 : 0.2);
        const isTelegraph = neck.attackState === 'TELEGRAPH';
        const segSprite = img[segSpriteKeys[h]];

        // Connecting tissue — dark body-colored spine along all segments
        ctx.globalCompositeOperation = 'source-over';
        const spineW = isAlive ? 12 : 6;
        ctx.strokeStyle = `rgba(${hColorRGB[h]}, ${neckAlpha * 0.4})`;
        ctx.lineWidth = spineW;
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(segs[0].x, segs[0].y);
        for (let s = 1; s < segs.length; s++) ctx.lineTo(segs[s].x, segs[s].y);
        ctx.stroke();
        // Darker inner spine
        ctx.strokeStyle = `rgba(0,0,0, ${neckAlpha * 0.2})`;
        ctx.lineWidth = spineW * 0.4;
        ctx.beginPath();
        ctx.moveTo(segs[0].x, segs[0].y);
        for (let s = 1; s < segs.length; s++) ctx.lineTo(segs[s].x, segs[s].y);
        ctx.stroke();

        // Segment sprites — drawn tail-to-head so head overlaps
        for (let s = segs.length - 1; s >= 0; s--) {
          const seg = segs[s];
          const segScale = seg.r / 14; // sprites are 14px radius base
          const telFlicker = isTelegraph ? (0.85 + Math.sin(t * 0.25 + s * 0.7) * 0.15) : 1.0;
          ctx.save();
          ctx.translate(seg.x, seg.y);
          // Rotate segment to face next segment
          if (s < segs.length - 1) {
            const ns = segs[s + 1];
            ctx.rotate(Math.atan2(ns.y - seg.y, ns.x - seg.x));
          } else if (s > 0) {
            const ps = segs[s - 1];
            ctx.rotate(Math.atan2(seg.y - ps.y, seg.x - ps.x));
          }
          ctx.globalAlpha = neckAlpha * telFlicker;
          if (segSprite) {
            const drawR = 48 * segScale; // 50% larger for chunkier necks
            // Normal blend for segment detail
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(segSprite, -drawR / 2, -drawR / 2, drawR, drawR);
            // Mirror copy on opposite side for fuller neck
            ctx.save();
            ctx.scale(1, -1); // flip across the neck axis
            ctx.drawImage(segSprite, -drawR / 2, -drawR / 2, drawR, drawR);
            ctx.restore();
            // Additive glow pass for energy feel (both sides)
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = neckAlpha * 0.25 * telFlicker;
            ctx.drawImage(segSprite, -drawR / 2, -drawR / 2, drawR, drawR);
            ctx.save();
            ctx.scale(1, -1);
            ctx.drawImage(segSprite, -drawR / 2, -drawR / 2, drawR, drawR);
            ctx.restore();
            ctx.globalCompositeOperation = 'source-over';
          } else {
            ctx.fillStyle = hColors[h];
            ctx.beginPath(); ctx.arc(0, 0, seg.r, 0, Math.PI * 2); ctx.fill();
          }
          ctx.globalAlpha = 1;
          ctx.restore();
        }

        // --- Draw head ---
        const hx = neck.headX, hy = neck.headY;
        const headSprite = img[headSpriteKeys[h]];
        if (isAlive) {
          const hpPct = head.hp / head.maxHp;
          const glowSize = 24 + (head.regenCount * 3);
          const headDrawSize = glowSize * 3.5;

          // Outer glow aura
          ctx.globalCompositeOperation = 'lighter';
          const hGrad = ctx.createRadialGradient(hx, hy, 0, hx, hy, glowSize * 1.5);
          hGrad.addColorStop(0, `rgba(${hColorRGB[h]}, 0.25)`);
          hGrad.addColorStop(0.5, `rgba(${hColorRGB[h]}, 0.08)`);
          hGrad.addColorStop(1, `rgba(${hColorRGB[h]}, 0)`);
          ctx.fillStyle = hGrad;
          ctx.beginPath(); ctx.arc(hx, hy, glowSize * 1.5, 0, Math.PI * 2); ctx.fill();

          // Head sprite — rotated to face player
          const headAngle = Math.atan2(player.y - hy, player.x - hx);
          ctx.save();
          ctx.translate(hx, hy);
          ctx.rotate(headAngle - Math.PI / 2); // sprite faces "down" naturally, rotate to face player
          if (headSprite) {
            // Normal blend: grokEdgeFade made black pixels transparent,
            // so dragon head detail renders opaquely (scales, teeth, eyes)
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
            ctx.drawImage(headSprite, -headDrawSize / 2, -headDrawSize / 2, headDrawSize, headDrawSize);
            // Additive glow pass for energy highlights
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.2;
            ctx.drawImage(headSprite, -headDrawSize / 2, -headDrawSize / 2, headDrawSize, headDrawSize);
            ctx.globalAlpha = 1;
          } else {
            // Fallback glow
            ctx.fillStyle = hColors[h];
            ctx.beginPath(); ctx.arc(0, 0, glowSize * 0.7, 0, Math.PI * 2); ctx.fill();
          }
          ctx.restore();

          // Telegraph charge-up effect
          if (isTelegraph) {
            const chargePct = Math.min(1, neck.attackTimer / (head.attackType === 'beam' ? 90 : head.attackType === 'breath' ? 60 : 50));
            const chargeR = glowSize + chargePct * 18;
            ctx.globalCompositeOperation = 'lighter';
            // Spinning charge particles
            for (let cp = 0; cp < 6; cp++) {
              const cpa = (cp / 6) * Math.PI * 2 + t * 0.15 * (1 + chargePct);
              const cpDist = chargeR * (1 - chargePct * 0.4);
              const cpx = hx + Math.cos(cpa) * cpDist;
              const cpy = hy + Math.sin(cpa) * cpDist;
              ctx.fillStyle = `rgba(255,255,255,${chargePct * 0.4})`;
              ctx.beginPath(); ctx.arc(cpx, cpy, 1.5 + chargePct * 1.5, 0, Math.PI * 2); ctx.fill();
            }
            // Growing energy ring
            ctx.strokeStyle = `rgba(${hColorRGB[h]}, ${chargePct * 0.5})`;
            ctx.lineWidth = 1.5 + chargePct * 2;
            ctx.beginPath(); ctx.arc(hx, hy, chargeR, 0, Math.PI * 2); ctx.stroke();

            // Beam telegraph: dashed aim line with pulsing glow
            if (head.attackType === 'beam') {
              const aimAngle = angleToward({ x: hx, y: hy }, player);
              ctx.globalCompositeOperation = 'source-over';
              ctx.strokeStyle = `rgba(255, 80, 80, ${0.3 + chargePct * 0.5})`;
              ctx.lineWidth = 1 + chargePct * 2;
              ctx.setLineDash([6, 8]);
              ctx.beginPath();
              ctx.moveTo(hx, hy);
              ctx.lineTo(hx + Math.cos(aimAngle) * 500, hy + Math.sin(aimAngle) * 500);
              ctx.stroke();
              ctx.setLineDash([]);
              // Glow along aim line
              ctx.globalCompositeOperation = 'lighter';
              ctx.strokeStyle = `rgba(255, 100, 80, ${chargePct * 0.15})`;
              ctx.lineWidth = 6 + chargePct * 8;
              ctx.beginPath();
              ctx.moveTo(hx, hy);
              ctx.lineTo(hx + Math.cos(aimAngle) * 200, hy + Math.sin(aimAngle) * 200);
              ctx.stroke();
            }
          }

          // Head HP bar
          ctx.globalCompositeOperation = 'source-over';
          const barW = 28, barH = 3;
          const barX = hx - barW / 2, barY = hy - glowSize - 10;
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
          ctx.fillStyle = hColors[h];
          ctx.fillRect(barX, barY, barW * hpPct, barH);
          // HP bar border
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(barX - 1, barY - 1, barW + 2, barH + 2);
        } else if (isRegen) {
          // Regenerating: growing stump with swirling particles
          const regenPct = 1 - head.regenTimer / 480;
          const stumpR = 6 + regenPct * 18;
          ctx.globalCompositeOperation = 'lighter';
          // Swirling regen particles
          for (let rp = 0; rp < 8; rp++) {
            const rpa = (rp / 8) * Math.PI * 2 + t * 0.1;
            const rpDist = stumpR * (0.5 + regenPct * 0.5);
            const rpx = hx + Math.cos(rpa) * rpDist;
            const rpy = hy + Math.sin(rpa) * rpDist;
            ctx.fillStyle = `rgba(255, 150, 255, ${0.2 + regenPct * 0.3})`;
            ctx.beginPath(); ctx.arc(rpx, rpy, 1 + regenPct * 1.5, 0, Math.PI * 2); ctx.fill();
          }
          // Core stump glow
          const sGrad = ctx.createRadialGradient(hx, hy, 0, hx, hy, stumpR);
          sGrad.addColorStop(0, `rgba(255, 180, 255, ${0.3 + regenPct * 0.3})`);
          sGrad.addColorStop(0.5, `rgba(${hColorRGB[h]}, ${0.2 * regenPct})`);
          sGrad.addColorStop(1, `rgba(${hColorRGB[h]}, 0)`);
          ctx.fillStyle = sGrad;
          ctx.beginPath(); ctx.arc(hx, hy, stumpR, 0, Math.PI * 2); ctx.fill();
          // Faint head sprite preview at high regen%
          if (regenPct > 0.6 && headSprite) {
            ctx.globalAlpha = (regenPct - 0.6) * 0.5;
            const prevSize = stumpR * 2.5;
            ctx.drawImage(headSprite, hx - prevSize / 2, hy - prevSize / 2, prevSize, prevSize);
            ctx.globalAlpha = 1;
          }
        } else {
          // Dead stump — dim ember
          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = `rgba(${hColorRGB[h]}, 0.08)`;
          ctx.beginPath(); ctx.arc(hx, hy, 8, 0, Math.PI * 2); ctx.fill();
        }
      }

      // --- Draw active beams (enhanced with edge particles) ---
      for (const beam of b.beams) {
        const bx = beam.x, by = beam.y;
        const beamLen = 600;
        const endX = bx + Math.cos(beam.angle) * beamLen;
        const endY = by + Math.sin(beam.angle) * beamLen;
        ctx.globalCompositeOperation = 'lighter';
        // Widest feathered outer glow
        ctx.strokeStyle = 'rgba(255, 30, 20, 0.1)';
        ctx.lineWidth = beam.width * 3;
        ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(endX, endY); ctx.stroke();
        // Outer glow
        ctx.strokeStyle = 'rgba(255, 80, 60, 0.35)';
        ctx.lineWidth = beam.width * 1.2;
        ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(endX, endY); ctx.stroke();
        // Core beam (bright white-pink)
        ctx.strokeStyle = 'rgba(255, 210, 200, 0.9)';
        ctx.lineWidth = beam.width * 0.35;
        ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(endX, endY); ctx.stroke();
        // Edge spark particles along beam
        const perp = beam.angle + Math.PI / 2;
        for (let sp = 0; sp < 8; sp++) {
          const dist = 30 + sp * 60 + Math.sin(t * 0.3 + sp) * 20;
          const side = (sp % 2 === 0 ? 1 : -1) * (beam.width * 0.5 + Math.random() * 4);
          const sx = bx + Math.cos(beam.angle) * dist + Math.cos(perp) * side;
          const sy = by + Math.sin(beam.angle) * dist + Math.sin(perp) * side;
          ctx.fillStyle = `rgba(255, ${150 + sp * 10}, ${100 + sp * 15}, ${0.5 - sp * 0.04})`;
          ctx.beginPath(); ctx.arc(sx, sy, 1 + Math.random() * 1.5, 0, Math.PI * 2); ctx.fill();
        }
        // Emitter flare at beam origin
        const emG = ctx.createRadialGradient(bx, by, 0, bx, by, beam.width * 1.5);
        emG.addColorStop(0, 'rgba(255,255,220,0.6)');
        emG.addColorStop(0.5, 'rgba(255,120,80,0.2)');
        emG.addColorStop(1, 'rgba(255,60,40,0)');
        ctx.fillStyle = emG;
        ctx.beginPath(); ctx.arc(bx, by, beam.width * 1.5, 0, Math.PI * 2); ctx.fill();
      }

      // --- Draw persistent globs (sprite-based with animated surface) ---
      for (const glob of b.globs) {
        const fadeAlpha = glob.timer < 60 ? glob.timer / 60 : 1;
        const pulseScale = 1 + Math.sin(t * 0.1 + glob.x * 0.1) * 0.15;
        const drawSize = 42 * pulseScale;
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = fadeAlpha;
        if (globSprite) {
          ctx.drawImage(globSprite, glob.x - drawSize / 2, glob.y - drawSize / 2, drawSize, drawSize);
          // Animated glow overlay
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = fadeAlpha * (0.15 + Math.sin(t * 0.15 + glob.y * 0.1) * 0.1);
          ctx.drawImage(globSprite, glob.x - drawSize / 2, glob.y - drawSize / 2, drawSize, drawSize);
        } else {
          const gGrad = ctx.createRadialGradient(glob.x, glob.y, 0, glob.x, glob.y, 18);
          gGrad.addColorStop(0, `rgba(180, 60, 255, ${0.5 * fadeAlpha})`);
          gGrad.addColorStop(0.6, `rgba(120, 30, 200, ${0.3 * fadeAlpha})`);
          gGrad.addColorStop(1, 'rgba(80, 20, 160, 0)');
          ctx.fillStyle = gGrad;
          ctx.beginPath(); ctx.arc(glob.x, glob.y, 18, 0, Math.PI * 2); ctx.fill();
        }
        // Animated rising bubbles
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = fadeAlpha;
        if (Math.random() < 0.5) {
          const bx2 = glob.x + (Math.random() - 0.5) * drawSize * 0.7;
          const by2 = glob.y - Math.random() * 8;
          const br2 = 1 + Math.random() * 2;
          const bg = ctx.createRadialGradient(bx2, by2, 0, bx2, by2, br2);
          bg.addColorStop(0, 'rgba(220,160,255,0.5)');
          bg.addColorStop(1, 'rgba(180,80,255,0)');
          ctx.fillStyle = bg;
          ctx.beginPath(); ctx.arc(bx2, by2, br2, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      ctx.restore(); // Restore from world-space transform
      ctx.globalCompositeOperation = 'source-over';
      break;
    }
  }
}

// Returns array of {x, y, r} circles defining the miniboss hittable area (world coordinates)
function getMinibossHitCircles(b) {
  switch (b.type) {
    case 4: // Jellyfish: bell dome — invulnerable when phased out
      if (b.phaseState === 'phased' || b.phaseState === 'fading') return []; // Can't be hit while phased
      return [{ x: b.x, y: b.y - 10, r: 35 }, { x: b.x, y: b.y + 25, r: 20 }];
    case 5: // Scarab: body + wings — smaller hitbox when charging (armored)
      if (b.charging) {
        return [{ x: b.x, y: b.y, r: 22, part: 'body', armored: true }]; // Folded wings = compact + armored
      }
      return [{ x: b.x, y: b.y, r: 28, part: 'body' }, { x: b.x - 22, y: b.y, r: 16, part: 'wing' }, { x: b.x + 22, y: b.y, r: 16, part: 'wing' }];
    case 6: // Moldorm serpent: head + all body segments
      const circles = [{ x: b.x, y: b.y, r: 30 }];
      for (const seg of b.segments) circles.push({ x: seg.x, y: seg.y, r: seg.r });
      return circles;
    case 7: { // Sentinel: core + alive shield orbs (tagged)
      const sc = [{ x: b.x, y: b.y, r: 30, part: 'core' }];
      for (let i = 0; i < b.orbCount; i++) {
        if (!b.shields[i].alive) continue;
        const oa = b.orbAngle + (i / b.orbCount) * Math.PI * 2;
        const orbR = 55;
        sc.push({ x: b.x + Math.cos(oa) * orbR, y: b.y + Math.sin(oa) * orbR, r: 12, part: 'shield', shieldIdx: i });
      }
      return sc;
    }
    case 8: { // Hydra: heads + neck segments (reduced dmg) + body when exposed
      const hc = [];
      let anyHead = false;
      for (let h = 0; h < 3; h++) {
        if (b.heads[h].alive) {
          // Head circle — full damage target
          hc.push({ x: b.headPositions[h].x, y: b.headPositions[h].y, r: 20, part: 'head', headIdx: h });
          anyHead = true;
          // Neck segments — reduced damage, skip first 2 segments (too close to body)
          const segs = b.necks[h].segments;
          for (let s = 2; s < segs.length; s++) {
            hc.push({ x: segs[s].x, y: segs[s].y, r: segs[s].r, part: 'neck', headIdx: h });
          }
        }
      }
      if (!anyHead) {
        hc.push({ x: b.x, y: b.y + 40, r: 50, part: 'body' });
      }
      return hc;
    }
    default: return [{ x: b.x, y: b.y, r: b.w / 2 }];
  }
}

function drawBoss(b) {
  ctx.save();
  ctx.translate(b.x, b.y);

  // Jellyfish phase-shift alpha — affects entire boss rendering
  if (b.type === 4) {
    let pa = 1.0;
    if (b.phaseState === 'fading') pa = 1.0 - b.phaseTimer / 30;
    else if (b.phaseState === 'phased') pa = 0.15 + Math.sin(globalTime * 0.1) * 0.05;
    else if (b.phaseState === 'appearing') pa = b.phaseTimer / 30;
    ctx.globalAlpha = pa;
  }

  const isFlash = b.flash > 0;
  if (isFlash) b.flash--;

  const sprite = img[b.spriteKey];
  const drawW = b.isMiniboss ? (b.renderW || b.w * 3.2) : b.w * 2.2;
  const drawH = b.isMiniboss ? (b.renderH || b.h * 3.2) : b.h * 2;
  const pulse = Math.sin(globalTime * 0.1) * 3;

  // Boss aura glow (skip for Hydra — body has its own glow in extras)
  if (b.type !== 8) {
    ctx.globalCompositeOperation = 'lighter';
    const auraR = drawW * 0.8 + pulse;
    const aGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, auraR);
    aGrad.addColorStop(0, b.color + '44');
    aGrad.addColorStop(0.5, b.color + '11');
    aGrad.addColorStop(1, b.color + '00');
    ctx.fillStyle = aGrad;
    ctx.fillRect(-auraR, -auraR, auraR * 2, auraR * 2);
    ctx.globalCompositeOperation = 'source-over';
  }

  // Draw miniboss-specific visual extras (body segments, tentacles, etc.)
  if (b.isMiniboss) drawMinibossExtras(b, drawW, drawH);

  // Skip default sprite for Hydra (type 8) — body rendered programmatically in extras
  if (sprite && b.type !== 8) {
    const wobble = Math.sin(globalTime * 0.08) * 0.05;
    // Serpent: rotate sprite to face heading direction (sprite art faces up, heading 0 = right)
    if (b.type === 6 && b.heading !== undefined) {
      ctx.rotate(b.heading + Math.PI / 2);
    } else {
      ctx.rotate(wobble);
    }
    if (b.isMiniboss) {
      // Sprite is luminance-keyed (dark bg = transparent). Draw normally, then additive glow pass.
      ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
      // Subtle additive glow pass for neon brightness boost
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.3;
      ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
      ctx.globalAlpha = 1;
      // Hit flash via offscreen canvas
      if (isFlash) {
        if (!b._fadeCanvas) {
          b._fadeCanvas = document.createElement('canvas');
          b._fadeCtx = b._fadeCanvas.getContext('2d');
        }
        const fc = b._fadeCanvas, fctx = b._fadeCtx;
        const fw = Math.ceil(drawW) + 2, fh = Math.ceil(drawH) + 2;
        if (fc.width !== fw || fc.height !== fh) { fc.width = fw; fc.height = fh; }
        fctx.clearRect(0, 0, fw, fh);
        fctx.drawImage(sprite, 1, 1, drawW, drawH);
        fctx.globalCompositeOperation = 'source-atop';
        fctx.fillStyle = 'rgba(255,255,255,0.7)';
        fctx.fillRect(0, 0, fw, fh);
        fctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(fc, -drawW / 2 - 1, -drawH / 2 - 1);
      }
      ctx.globalCompositeOperation = 'source-over';
    } else {
      ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
      if (isFlash) {
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillRect(-drawW / 2, -drawH / 2, drawW, drawH);
        ctx.globalCompositeOperation = 'source-over';
      }
    }
  } else if (b.type !== 8) {
    // Fallback: programmatic boss (skip for Hydra — body in extras)
    ctx.fillStyle = isFlash ? '#ffffff' : b.color;
    const s = b.w / 2;
    ctx.beginPath();
    ctx.moveTo(0, -s - 5); ctx.lineTo(s + 10, -s / 3); ctx.lineTo(s, s / 2);
    ctx.lineTo(s / 2, s + 5); ctx.lineTo(-s / 2, s + 5); ctx.lineTo(-s, s / 2); ctx.lineTo(-s - 10, -s / 3);
    ctx.closePath(); ctx.fill();
  }

  ctx.restore();

  // HP bar
  const hpFrac = b.hp / b.maxHp;
  if (b.isMiniboss) {
    if (b.type === 6 || b.type === 8) {
      // Serpent & Hydra: fixed HP bar at top (body near top edge)
      const mBarW = W - 120, mBarH = 5;
      const mBarX = 60, mBarY = 18;
      ctx.fillStyle = '#33333388';
      ctx.fillRect(mBarX, mBarY, mBarW, mBarH);
      const mGrad = ctx.createLinearGradient(mBarX, 0, mBarX + mBarW, 0);
      mGrad.addColorStop(0, b.color); mGrad.addColorStop(1, '#ffffff88');
      ctx.fillStyle = mGrad;
      ctx.fillRect(mBarX, mBarY, mBarW * hpFrac, mBarH);
      ctx.strokeStyle = '#ffffff33';
      ctx.strokeRect(mBarX, mBarY, mBarW, mBarH);
      ctx.fillStyle = '#ffffff';
      ctx.font = '10px "Courier New"';
      ctx.textAlign = 'center';
      ctx.fillText(b.name, W / 2, mBarY - 3);
    } else {
    // Miniboss: HP bar floating above the sprite image
    const rH = b.renderH || b.h * 3;
    const mBarW = Math.max(b.w * 1.8, 80), mBarH = 5;
    const mBarX = b.x - mBarW / 2, mBarY = b.y - rH / 2 - 15;
    ctx.fillStyle = '#33333388';
    ctx.fillRect(mBarX, mBarY, mBarW, mBarH);
    const mGrad = ctx.createLinearGradient(mBarX, 0, mBarX + mBarW, 0);
    mGrad.addColorStop(0, b.color); mGrad.addColorStop(1, '#ffffff88');
    ctx.fillStyle = mGrad;
    ctx.fillRect(mBarX, mBarY, mBarW * hpFrac, mBarH);
    ctx.strokeStyle = '#ffffff33';
    ctx.strokeRect(mBarX, mBarY, mBarW, mBarH);
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(b.name, b.x, mBarY - 3);
    }
  } else {
    // Full boss: wide HP bar at top of screen
    const barW = W - 80, barX = 40, barY = 20;
    ctx.fillStyle = '#333';
    ctx.fillRect(barX, barY, barW, 8);
    const hpGrad = ctx.createLinearGradient(barX, 0, barX + barW, 0);
    if (hpFrac > 0.5) {
      hpGrad.addColorStop(0, '#44ff44'); hpGrad.addColorStop(1, '#88ffaa');
    } else if (hpFrac > 0.25) {
      hpGrad.addColorStop(0, '#ffaa00'); hpGrad.addColorStop(1, '#ffcc44');
    } else {
      hpGrad.addColorStop(0, '#ff4444'); hpGrad.addColorStop(1, '#ff8844');
    }
    ctx.fillStyle = hpGrad;
    ctx.fillRect(barX, barY, barW * hpFrac, 8);
    ctx.strokeStyle = '#ffffff44';
    ctx.strokeRect(barX, barY, barW, 8);
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(b.name || 'BOSS', W / 2, barY - 4);
  }
}

// ---- DRAW ENEMY BULLET ----
function drawBullet(b) {
  ctx.save();
  ctx.translate(b.x, b.y);

  // Outer glow (additive)
  ctx.globalCompositeOperation = 'lighter';
  const glowR = b.size * 2.5;
  const gGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, glowR);
  gGrad.addColorStop(0, b.color + '66');
  gGrad.addColorStop(1, b.color + '00');
  ctx.fillStyle = gGrad;
  ctx.fillRect(-glowR, -glowR, glowR * 2, glowR * 2);
  ctx.globalCompositeOperation = 'source-over';

  ctx.fillStyle = b.color;
  if (b.type === 'rice') {
    ctx.rotate(Math.atan2(b.vy, b.vx));
    ctx.beginPath(); ctx.ellipse(0, 0, b.size, b.size / 2.5, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ffffffaa';
    ctx.beginPath(); ctx.ellipse(0, 0, b.size * 0.5, b.size / 4, 0, 0, Math.PI * 2); ctx.fill();
  } else {
    ctx.beginPath(); ctx.arc(0, 0, b.size, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ffffffaa';
    ctx.beginPath(); ctx.arc(0, 0, b.size * 0.5, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

// ---- DRAW PLAYER BULLET ----
function drawPlayerBullet(b) {
  ctx.save();
  ctx.translate(b.x, b.y);

  // Try to use laser sprite
  let sprite;
  if (b.type === 'main') sprite = img.laserBlue1;
  else if (b.type === 'side') sprite = img.laserBlue2;
  else if (b.type === 'wide') sprite = img.laserGreen1;
  else if (b.type === 'homing') sprite = img.laserRed1;

  if (sprite) {
    const rot = Math.atan2(b.vy, b.vx) + Math.PI / 2; // rotate to face direction
    ctx.rotate(rot);
    const sw = b.size * 3;
    const sh = b.size * 6;
    ctx.drawImage(sprite, -sw / 2, -sh / 2, sw, sh);
  } else {
    // Fallback
    ctx.fillStyle = b.color;
    ctx.fillRect(-1.5, -b.size * 2, 3, b.size * 4);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-0.5, -b.size * 1.5, 1, b.size * 3);
  }

  // Bullet glow
  ctx.globalCompositeOperation = 'lighter';
  const gR = b.size * 3;
  const gGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, gR);
  gGrad.addColorStop(0, (b.color || '#00ffff') + '44');
  gGrad.addColorStop(1, (b.color || '#00ffff') + '00');
  ctx.fillStyle = gGrad;
  ctx.fillRect(-gR, -gR, gR * 2, gR * 2);
  ctx.globalCompositeOperation = 'source-over';

  ctx.restore();
}

// ---- DRAW ITEM ----
function drawItem(item) {
  ctx.save();
  const bobY = Math.sin(globalTime * 0.15 + item.x) * 3;
  ctx.translate(item.x, item.y + bobY);

  let sprite;
  switch (item.type) {
    case 'power': sprite = img.pupPower; break;
    case 'score': sprite = img.pupScore; break;
    case 'bomb': sprite = img.pupBomb; break;
  }

  if (sprite) {
    const sz = 24;
    ctx.drawImage(sprite, -sz / 2, -sz / 2, sz, sz);
    // Item glow
    ctx.globalCompositeOperation = 'lighter';
    const gR = 16;
    const col = item.type === 'power' ? '#ff444444' : item.type === 'bomb' ? '#44ff4444' : '#4488ff44';
    const gGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, gR);
    gGrad.addColorStop(0, col);
    gGrad.addColorStop(1, col.slice(0, 7) + '00');
    ctx.fillStyle = gGrad;
    ctx.fillRect(-gR, -gR, gR * 2, gR * 2);
    ctx.globalCompositeOperation = 'source-over';
  } else {
    // Fallback
    ctx.fillStyle = item.type === 'power' ? COLORS.powerItem : item.type === 'bomb' ? COLORS.bombItem : COLORS.scoreItem;
    ctx.font = 'bold 14px "Courier New"'; ctx.textAlign = 'center';
    ctx.fillText(item.type === 'power' ? 'P' : item.type === 'bomb' ? 'B' : '*', 0, 5);
  }
  ctx.restore();
}

// ---- ROGUELIKE POWERUP RENDERING ----
function drawPowerupChoice(choice) {
  ctx.save();
  const bob = Math.sin(globalTime * 0.1 + choice.bobPhase) * 4;
  ctx.translate(choice.x, choice.y + bob);
  const rarity = choice.powerup.rarity;
  const pulse = 0.8 + Math.sin(globalTime * 0.15) * 0.2;

  // Outer glow
  ctx.globalCompositeOperation = 'lighter';
  const glowR = 28 * pulse;
  const gGrad = ctx.createRadialGradient(0, 0, 8, 0, 0, glowR);
  gGrad.addColorStop(0, rarity.color + '66');
  gGrad.addColorStop(0.6, rarity.color + '22');
  gGrad.addColorStop(1, rarity.color + '00');
  ctx.fillStyle = gGrad;
  ctx.fillRect(-glowR, -glowR, glowR * 2, glowR * 2);
  ctx.globalCompositeOperation = 'source-over';

  // Hexagonal shape
  const sz = 16;
  ctx.fillStyle = rarity.color + 'aa';
  ctx.strokeStyle = rarity.color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, -sz); ctx.lineTo(sz * 0.8, -sz * 0.3);
  ctx.lineTo(sz * 0.8, sz * 0.3); ctx.lineTo(0, sz);
  ctx.lineTo(-sz * 0.8, sz * 0.3); ctx.lineTo(-sz * 0.8, -sz * 0.3);
  ctx.closePath(); ctx.fill(); ctx.stroke();

  // Icon
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 10px "Courier New"';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(choice.powerup.icon, 0, 0);

  // Name above
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 8px "Courier New"';
  ctx.textBaseline = 'bottom';
  ctx.fillText(choice.powerup.name, 0, -sz - 4);

  // Desc below
  ctx.fillStyle = rarity.color;
  ctx.font = '7px "Courier New"';
  ctx.textBaseline = 'top';
  ctx.fillText(choice.powerup.desc, 0, sz + 4);

  // Legendary: orbiting stars
  if (rarity === RARITY.LEGENDARY) {
    ctx.globalCompositeOperation = 'lighter';
    for (let i = 0; i < 3; i++) {
      const a = globalTime * 0.05 + (i / 3) * Math.PI * 2;
      ctx.fillStyle = '#ffaa22';
      ctx.beginPath();
      ctx.arc(Math.cos(a) * 22, Math.sin(a) * 22, 2, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalCompositeOperation = 'source-over';
  }
  ctx.restore();
}

function drawPowerupHUD() {
  const entries = Object.entries(runPowerups.collected);
  if (entries.length === 0) return;
  ctx.save();
  const startX = 8;
  const startY = isMobile ? 48 : H - 80;
  const iconSz = 14;
  const gap = 2;
  for (let i = 0; i < entries.length; i++) {
    const [id, stacks] = entries[i];
    const def = ROGUELIKE_POWERUPS.find(p => p.id === id);
    if (!def) continue;
    const col = Math.floor(i / 4);
    const row = i % 4;
    const x = startX + col * (iconSz + gap + 14);
    const y = startY + row * (iconSz + gap);

    ctx.fillStyle = def.rarity.color + '55';
    ctx.fillRect(x, y, iconSz, iconSz);
    ctx.strokeStyle = def.rarity.color;
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, iconSz, iconSz);

    ctx.fillStyle = '#ffffff';
    ctx.font = '7px "Courier New"';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(def.icon.charAt(0), x + iconSz / 2, y + iconSz / 2);

    if (stacks > 1) {
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 7px "Courier New"';
      ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
      ctx.fillText('x' + stacks, x + iconSz, y + iconSz);
    }
  }
  ctx.restore();
}

function drawPowerupAnnouncement() {
  if (!powerupAnnouncement || powerupAnnouncement.timer <= 0) return;
  const a = powerupAnnouncement;
  a.timer--;
  const alpha = a.timer > 100 ? 1 : a.timer / 100;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = a.rarity.color + '33';
  ctx.fillRect(0, H / 2 - 35, W, 70);
  ctx.fillStyle = a.rarity.color;
  ctx.font = 'bold 18px "Courier New"';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(a.name, W / 2, H / 2 - 8);
  ctx.fillStyle = '#ffffffcc';
  ctx.font = '11px "Courier New"';
  ctx.fillText(a.desc, W / 2, H / 2 + 12);
  ctx.globalAlpha = 1;
  ctx.restore();
}

function drawOrbitalBlades() {
  if (resolvedMods.orbitalBlades <= 0 || !player.alive) return;
  const count = resolvedMods.orbitalBlades;
  const radius = 30;
  for (let i = 0; i < count; i++) {
    const angle = globalTime * 0.05 + (i / count) * Math.PI * 2;
    const bx = player.x + Math.cos(angle) * radius;
    const by = player.y + Math.sin(angle) * radius;
    ctx.save();
    ctx.translate(bx, by);
    ctx.rotate(angle + globalTime * 0.1);
    ctx.fillStyle = '#ffaa22';
    ctx.beginPath();
    ctx.moveTo(0, -8); ctx.lineTo(4, 0); ctx.lineTo(0, 8); ctx.lineTo(-4, 0);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(0, -4); ctx.lineTo(2, 0); ctx.lineTo(0, 4); ctx.lineTo(-2, 0);
    ctx.closePath(); ctx.fill();
    ctx.restore();
    if (globalTime % 3 === 0) spawnParticles(bx, by, '#ffaa22', 1, 1, 10, 1);
  }
}

// ---- DRAW FIRE SPRITE EXPLOSIONS ----
function drawFireSprites() {
  for (const f of fireSprites) {
    const fImg = img[f.key];
    if (!fImg) continue;
    ctx.save();
    ctx.globalAlpha = f.alpha;
    ctx.globalCompositeOperation = 'lighter';
    ctx.translate(f.x, f.y);
    ctx.rotate(f.rot);
    const sz = 32 * f.scale;
    ctx.drawImage(fImg, -sz / 2, -sz / 2, sz, sz);
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

// ---- DRAW SHIP SELECT SCREEN ----
// ---- MODE SELECT SCREEN ----
function drawModeSelectScreen() {
  ctx.save();
  ctx.fillStyle = '#0a0a15';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.textAlign = 'center';
  ctx.font = 'bold 32px "Courier New"';
  ctx.fillStyle = '#ffffff';
  ctx.fillText('SELECT MODE', W / 2, 80);

  selectAnim += 0.03;
  const panelW = 135, panelH = 280;
  const gap = 12;
  const modes = [
    { name: 'ENDLESS', desc: 'Classic arcade.\nPick a ship.\nSurvive infinite\nwaves.', color: '#7b68ee', icon: '\u221E' },
    { name: 'CAMPAIGN', desc: 'Structured levels.\nBeat bosses.\nEarn equipment.\nBuild your ship.', color: '#ff6ec7', icon: '\u2694' },
    { name: 'BOSS FIGHT', desc: 'Pick any boss.\nJump straight\ninto battle.\nGreat for practice.', color: '#ff4444', icon: '\u2620' },
  ];

  const totalW = modes.length * panelW + (modes.length - 1) * gap;
  const startX = (W - totalW) / 2;

  for (let i = 0; i < modes.length; i++) {
    const px = startX + i * (panelW + gap);
    const py = 140;
    const m = modes[i];
    const sel = i === modeSelectIndex;
    const glow = sel ? 0.6 + Math.sin(selectAnim * 3) * 0.3 : 0.15;

    // Panel bg
    ctx.fillStyle = `rgba(20,20,40,0.9)`;
    ctx.fillRect(px, py, panelW, panelH);

    // Border
    ctx.strokeStyle = sel ? m.color : '#333';
    ctx.lineWidth = sel ? 3 : 1;
    ctx.strokeRect(px, py, panelW, panelH);

    // Glow
    if (sel) {
      ctx.shadowColor = m.color;
      ctx.shadowBlur = 15;
      ctx.strokeRect(px, py, panelW, panelH);
      ctx.shadowBlur = 0;
    }

    // Icon
    ctx.font = 'bold 40px "Courier New"';
    ctx.fillStyle = m.color;
    ctx.globalAlpha = glow + 0.4;
    ctx.fillText(m.icon, px + panelW / 2, py + 65);
    ctx.globalAlpha = 1;

    // Name
    ctx.font = 'bold 14px "Courier New"';
    ctx.fillStyle = sel ? '#ffffff' : '#888';
    ctx.fillText(m.name, px + panelW / 2, py + 100);

    // Subtitle
    ctx.font = '9px "Courier New"';
    ctx.fillStyle = sel ? '#aaa' : '#666';
    ctx.fillText(i === 0 ? 'BALANCED' : i === 1 ? 'STORY' : 'PRACTICE', px + panelW / 2, py + 116);

    // Description
    ctx.font = '10px "Courier New"';
    ctx.fillStyle = '#aaa';
    const lines = m.desc.split('\n');
    for (let l = 0; l < lines.length; l++) {
      ctx.fillText(lines[l], px + panelW / 2, py + 145 + l * 17);
    }

    // Campaign progress
    if (i === 1) {
      const cleared = Object.values(saveData.levels).filter(l => l.cleared).length;
      const total = CAMPAIGN_CHAPTERS[1].levels.length;
      ctx.font = '11px "Courier New"';
      ctx.fillStyle = '#ff6ec7';
      ctx.fillText(`Chapter 1: ${cleared}/${total}`, px + panelW / 2, py + panelH - 20);
    }
  }

  // Bottom prompt
  ctx.font = '14px "Courier New"';
  ctx.fillStyle = '#00ffff';
  ctx.globalAlpha = 0.6 + Math.sin(selectAnim * 4) * 0.4;
  if (isMobile) {
    ctx.fillText('[ TAP TO SELECT ]', W / 2, H - 60);
  } else {
    ctx.fillText('[ LEFT/RIGHT + ENTER ]', W / 2, H - 60);
  }
  ctx.globalAlpha = 1;

  ctx.restore();
}

// ---- BOSS FIGHT SELECT SCREEN ----
function drawBossSelectScreen() {
  ctx.save();
  ctx.fillStyle = '#0a0a15';
  ctx.fillRect(0, 0, W, H);

  selectAnim += 0.03;

  // Title
  ctx.textAlign = 'center';
  ctx.font = 'bold 28px "Courier New"';
  ctx.fillStyle = '#ff4444';
  ctx.fillText('BOSS FIGHT', W / 2, 50);
  ctx.font = '11px "Courier New"';
  ctx.fillStyle = '#888';
  ctx.fillText('Pick a boss to battle', W / 2, 72);

  // Boss list
  const rowH = 72;
  const startY = 95;
  const listW = W - 60;
  const listX = 30;

  for (let i = 0; i < BOSS_FIGHT_LIST.length; i++) {
    const b = BOSS_FIGHT_LIST[i];
    const ry = startY + i * rowH;
    const sel = i === bossSelectIndex;

    // Row background
    ctx.fillStyle = sel ? 'rgba(40,20,20,0.95)' : 'rgba(15,15,30,0.8)';
    ctx.fillRect(listX, ry, listW, rowH - 6);

    // Border
    ctx.strokeStyle = sel ? b.color : '#222';
    ctx.lineWidth = sel ? 2 : 1;
    ctx.strokeRect(listX, ry, listW, rowH - 6);

    // Selection glow
    if (sel) {
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 10;
      ctx.strokeRect(listX, ry, listW, rowH - 6);
      ctx.shadowBlur = 0;
    }

    // Type badge (B for boss, M for miniboss)
    const badgeX = listX + 22;
    const badgeY = ry + (rowH - 6) / 2;
    ctx.fillStyle = b.icon === 'B' ? '#ff4444' : '#ffaa00';
    ctx.font = 'bold 12px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(b.icon === 'B' ? 'BOSS' : 'MINI', badgeX, badgeY - 8);
    // Color dot
    ctx.fillStyle = b.color;
    ctx.beginPath(); ctx.arc(badgeX, badgeY + 8, 6, 0, Math.PI * 2); ctx.fill();

    // Boss name
    ctx.textAlign = 'left';
    ctx.font = sel ? 'bold 14px "Courier New"' : '13px "Courier New"';
    ctx.fillStyle = sel ? '#ffffff' : '#aaa';
    ctx.fillText(b.name, listX + 55, ry + 26);

    // Description + HP
    ctx.font = '10px "Courier New"';
    ctx.fillStyle = '#888';
    ctx.fillText(b.desc, listX + 55, ry + 44);
    ctx.textAlign = 'right';
    ctx.fillStyle = '#666';
    ctx.fillText(`HP: ${b.hp}`, listX + listW - 12, ry + 26);

    // HP bar
    const hpBarW = 60, hpBarH = 4;
    const hpBarX = listX + listW - 12 - hpBarW;
    const hpBarY = ry + 38;
    ctx.fillStyle = '#222';
    ctx.fillRect(hpBarX, hpBarY, hpBarW, hpBarH);
    ctx.fillStyle = b.color;
    ctx.fillRect(hpBarX, hpBarY, hpBarW * Math.min(b.hp / 600, 1), hpBarH);
  }

  // Bottom prompt
  ctx.textAlign = 'center';
  ctx.font = '13px "Courier New"';
  ctx.fillStyle = '#00ffff';
  ctx.globalAlpha = 0.6 + Math.sin(selectAnim * 4) * 0.4;
  if (isMobile) {
    ctx.fillText('[ TAP TO SELECT ]', W / 2, H - 40);
  } else {
    ctx.fillText('[ UP/DOWN + ENTER ]', W / 2, H - 50);
    ctx.fillStyle = '#888';
    ctx.font = '10px "Courier New"';
    ctx.fillText('ESC to go back', W / 2, H - 30);
  }
  ctx.globalAlpha = 1;

  ctx.restore();
}

// ---- LEVEL SELECT SCREEN ----
function drawLevelSelectScreen() {
  ctx.save();
  ctx.fillStyle = '#0a0a15';
  ctx.fillRect(0, 0, W, H);

  const chapter = CAMPAIGN_CHAPTERS[1];

  // Chapter title
  ctx.textAlign = 'center';
  ctx.font = 'bold 24px "Courier New"';
  ctx.fillStyle = '#ff6ec7';
  ctx.fillText('CHAPTER 1', W / 2, 50);
  ctx.font = '14px "Courier New"';
  ctx.fillStyle = '#888';
  ctx.fillText(chapter.name, W / 2, 72);

  selectAnim += 0.03;

  // Level list
  const startY = 100;
  for (let i = 0; i < chapter.levels.length; i++) {
    const level = chapter.levels[i];
    const ly = startY + i * 75;
    const unlocked = isLevelUnlocked(level.id);
    const sel = i === levelSelectIndex;
    const progress = saveData.levels[level.id];
    const cleared = progress && progress.cleared;

    // Row background
    ctx.fillStyle = sel ? 'rgba(255,110,199,0.12)' : 'rgba(20,20,40,0.6)';
    ctx.fillRect(50, ly, W - 100, 65);

    // Border
    ctx.strokeStyle = sel ? '#ff6ec7' : (unlocked ? '#444' : '#222');
    ctx.lineWidth = sel ? 2 : 1;
    ctx.strokeRect(50, ly, W - 100, 65);

    ctx.textAlign = 'left';

    if (!unlocked) {
      // Locked
      ctx.font = 'bold 16px "Courier New"';
      ctx.fillStyle = '#333';
      ctx.fillText('\u{1F512} ' + level.id, 70, ly + 28);
      ctx.font = '12px "Courier New"';
      ctx.fillText('LOCKED', 70, ly + 48);
    } else {
      // Level ID + name
      ctx.font = 'bold 16px "Courier New"';
      ctx.fillStyle = sel ? '#ffffff' : '#ccc';
      ctx.fillText(level.id + '  ' + level.name, 70, ly + 28);

      // Info line
      ctx.font = '11px "Courier New"';
      ctx.fillStyle = '#888';
      const waveCount = level.waves.length;
      const hasBoss = level.boss || level.miniboss;
      ctx.fillText(`${waveCount} waves` + (hasBoss ? ' + BOSS' : ''), 70, ly + 48);

      // Stars
      if (cleared) {
        const stars = progress.stars || 0;
        ctx.textAlign = 'right';
        ctx.font = '16px "Courier New"';
        for (let s = 0; s < 3; s++) {
          ctx.fillStyle = s < stars ? '#ffaa00' : '#333';
          ctx.fillText('\u2605', W - 60 + s * 18, ly + 35);
        }
      }

      // Best score
      if (progress && progress.bestScore) {
        ctx.textAlign = 'right';
        ctx.font = '10px "Courier New"';
        ctx.fillStyle = '#666';
        ctx.fillText('BEST: ' + progress.bestScore, W - 60, ly + 55);
      }
    }
  }

  // Bottom buttons
  ctx.textAlign = 'center';

  // Ship View button
  ctx.fillStyle = 'rgba(20,20,40,0.8)';
  ctx.fillRect(40, 630, 190, 45);
  ctx.strokeStyle = '#4488ff';
  ctx.lineWidth = 1;
  ctx.strokeRect(40, 630, 190, 45);
  ctx.font = 'bold 14px "Courier New"';
  ctx.fillStyle = '#4488ff';
  ctx.fillText('SHIP & EQUIP [E]', 135, 657);

  // Back button
  ctx.fillStyle = 'rgba(20,20,40,0.8)';
  ctx.fillRect(250, 630, 190, 45);
  ctx.strokeStyle = '#888';
  ctx.strokeRect(250, 630, 190, 45);
  ctx.fillStyle = '#888';
  ctx.fillText('BACK [ESC]', 345, 657);

  // Enter prompt
  ctx.font = '12px "Courier New"';
  ctx.fillStyle = '#00ffff';
  ctx.globalAlpha = 0.6 + Math.sin(selectAnim * 4) * 0.4;
  ctx.fillText('[ ENTER TO PLAY ]', W / 2, 620);
  ctx.globalAlpha = 1;

  ctx.restore();
}

// ---- SHIP VIEW / EQUIPMENT SCREEN ----
const EQUIP_SLOT_LAYOUT = [
  { key: 'weapon1',    label: 'WEAPON 1',   x: 60,  y: 100 },
  { key: 'weapon2',    label: 'WEAPON 2',   x: 60,  y: 170 },
  { key: 'armor',      label: 'ARMOR',      x: 60,  y: 260 },
  { key: 'wings',      label: 'WINGS',      x: 60,  y: 330 },
  { key: 'engine',     label: 'ENGINE',     x: 60,  y: 400 },
  { key: 'accessory1', label: 'ACC. 1',     x: 60,  y: 490 },
  { key: 'accessory2', label: 'ACC. 2',     x: 60,  y: 560 },
];

function getSlotType(slotKey) {
  if (slotKey.startsWith('weapon')) return 'weapon';
  if (slotKey.startsWith('accessory')) return 'accessory';
  return slotKey;
}

function handleShipViewTap(cx, cy) {
  // Check slot taps (left side)
  for (const slot of EQUIP_SLOT_LAYOUT) {
    if (cx > slot.x - 10 && cx < slot.x + 160 && cy > slot.y - 5 && cy < slot.y + 55) {
      if (equipSelectSlot === slot.key) {
        // Unequip
        saveData.equipped[slot.key] = null;
        writeSave();
        equipSelectSlot = null;
      } else {
        equipSelectSlot = slot.key;
        equipSelectIndex = 0;
      }
      return;
    }
  }

  // Check inventory taps (right side)
  if (equipSelectSlot && cx > 240) {
    const slotType = getSlotType(equipSelectSlot);
    const compatible = saveData.inventory.filter(id => {
      const def = EQUIPMENT_DEFS[id];
      return def && def.slot === slotType;
    });
    const gridCols = 3;
    const itemW = 70, itemH = 55;
    const gridX = 250, gridY = 100;
    for (let i = 0; i < compatible.length; i++) {
      const col = i % gridCols;
      const row = Math.floor(i / gridCols);
      const ix = gridX + col * (itemW + 5);
      const iy = gridY + row * (itemH + 5);
      if (cx > ix && cx < ix + itemW && cy > iy && cy < iy + itemH) {
        saveData.equipped[equipSelectSlot] = compatible[i];
        writeSave();
        equipSelectSlot = null;
        return;
      }
    }
  }

  // Back button
  if (cy > 650 && cy < 700) {
    gameState = 'levelselect';
    equipSelectSlot = null;
  }
}

function drawShipViewScreen() {
  ctx.save();
  ctx.fillStyle = '#0a0a15';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';
  ctx.font = 'bold 22px "Courier New"';
  ctx.fillStyle = '#4488ff';
  ctx.fillText('SHIP & EQUIPMENT', W / 2, 40);

  // Ship name
  ctx.font = '14px "Courier New"';
  ctx.fillStyle = '#888';
  ctx.fillText(CAMPAIGN_SHIP.name + ' — ' + CAMPAIGN_SHIP.subtitle, W / 2, 65);

  // Equipment slots (left side)
  ctx.textAlign = 'left';
  for (const slot of EQUIP_SLOT_LAYOUT) {
    const equipped = saveData.equipped[slot.key];
    const def = equipped ? EQUIPMENT_DEFS[equipped] : null;
    const sel = equipSelectSlot === slot.key;

    // Slot background
    ctx.fillStyle = sel ? 'rgba(68,136,255,0.15)' : 'rgba(20,20,40,0.7)';
    ctx.fillRect(slot.x - 10, slot.y - 5, 170, 55);
    ctx.strokeStyle = sel ? '#4488ff' : '#333';
    ctx.lineWidth = sel ? 2 : 1;
    ctx.strokeRect(slot.x - 10, slot.y - 5, 170, 55);

    // Slot label
    ctx.font = '9px "Courier New"';
    ctx.fillStyle = '#666';
    ctx.fillText(slot.label, slot.x, slot.y + 10);

    if (def) {
      // Equipped item
      const rarityColor = EQUIP_RARITY[def.rarity].color;
      ctx.font = 'bold 12px "Courier New"';
      ctx.fillStyle = rarityColor;
      ctx.fillText(def.name, slot.x, slot.y + 28);
      ctx.font = '9px "Courier New"';
      ctx.fillStyle = '#888';
      ctx.fillText(def.desc, slot.x, slot.y + 42);
    } else {
      ctx.font = '12px "Courier New"';
      ctx.fillStyle = '#444';
      ctx.fillText('[ EMPTY ]', slot.x, slot.y + 30);
    }
  }

  // Inventory panel (right side) — only shows when a slot is selected
  if (equipSelectSlot) {
    const slotType = getSlotType(equipSelectSlot);
    const compatible = saveData.inventory.filter(id => {
      const def = EQUIPMENT_DEFS[id];
      return def && def.slot === slotType;
    });

    ctx.textAlign = 'center';
    ctx.font = 'bold 12px "Courier New"';
    ctx.fillStyle = '#4488ff';
    ctx.fillText('INVENTORY', 355, 88);

    if (compatible.length === 0) {
      ctx.font = '11px "Courier New"';
      ctx.fillStyle = '#555';
      ctx.fillText('No items', 355, 150);
    } else {
      const gridCols = 3;
      const itemW = 70, itemH = 55;
      const gridX = 250, gridY = 100;
      for (let i = 0; i < compatible.length; i++) {
        const def = EQUIPMENT_DEFS[compatible[i]];
        if (!def) continue;
        const col = i % gridCols;
        const row = Math.floor(i / gridCols);
        const ix = gridX + col * (itemW + 5);
        const iy = gridY + row * (itemH + 5);
        const rarityColor = EQUIP_RARITY[def.rarity].color;

        ctx.fillStyle = 'rgba(20,20,40,0.8)';
        ctx.fillRect(ix, iy, itemW, itemH);
        ctx.strokeStyle = rarityColor;
        ctx.lineWidth = 1;
        ctx.strokeRect(ix, iy, itemW, itemH);

        ctx.textAlign = 'center';
        ctx.font = 'bold 16px "Courier New"';
        ctx.fillStyle = rarityColor;
        ctx.fillText(def.icon, ix + itemW / 2, iy + 22);
        ctx.font = '8px "Courier New"';
        ctx.fillStyle = '#ccc';
        ctx.fillText(def.name.split(' ')[0], ix + itemW / 2, iy + 38);
        ctx.fillStyle = '#666';
        ctx.fillText(EQUIP_RARITY[def.rarity].name, ix + itemW / 2, iy + 50);
      }
    }
  } else {
    // Show computed stats
    ctx.textAlign = 'center';
    ctx.font = 'bold 12px "Courier New"';
    ctx.fillStyle = '#4488ff';
    ctx.fillText('SHIP STATS', 355, 120);

    // Calculate stats with equipment
    const tempMods = {
      damageMult: 1, shootDelayMult: 1, bulletSpeedMult: 1,
      speedMult: 1, maxHpBonus: 0, bombBonus: 0,
      extraStreams: 0, sideShots: 0, pierceCount: 0,
      hitboxShrink: 0, regenInterval: 0, reflectChance: 0,
      dropRateMult: 1, killHealChance: 0,
    };
    const baseCfg = CAMPAIGN_SHIP;
    for (const slotId of Object.values(saveData.equipped)) {
      if (!slotId) continue;
      const def = EQUIPMENT_DEFS[slotId];
      if (def && def.effect) def.effect(tempMods);
    }

    const stats = [
      { label: 'HP', val: baseCfg.hp + (tempMods.maxHpBonus || 0), color: '#ff4444' },
      { label: 'SPEED', val: Math.round(baseCfg.speed * (tempMods.speedMult || 1) * 10) / 10, color: '#44ff88' },
      { label: 'FIRE RATE', val: Math.round(baseCfg.shootDelay * (tempMods.shootDelayMult || 1) * 10) / 10, color: '#ffaa00' },
      { label: 'DAMAGE', val: Math.round((tempMods.damageMult || 1) * 100) + '%', color: '#ff6ec7' },
      { label: 'BOMBS', val: baseCfg.bombs + (tempMods.bombBonus || 0), color: '#44ff44' },
    ];

    ctx.textAlign = 'left';
    for (let i = 0; i < stats.length; i++) {
      const s = stats[i];
      const sy = 150 + i * 35;
      ctx.font = '11px "Courier New"';
      ctx.fillStyle = '#888';
      ctx.fillText(s.label, 270, sy);
      ctx.font = 'bold 14px "Courier New"';
      ctx.fillStyle = s.color;
      ctx.fillText(String(s.val), 380, sy);
    }
  }

  // Back button
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(20,20,40,0.8)';
  ctx.fillRect(W / 2 - 80, 655, 160, 35);
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1;
  ctx.strokeRect(W / 2 - 80, 655, 160, 35);
  ctx.font = 'bold 13px "Courier New"';
  ctx.fillStyle = '#888';
  ctx.fillText('BACK [ESC]', W / 2, 677);

  ctx.restore();
}

// ---- LEVEL DONE SCREEN ----
let lootDrop = null; // { itemId, x, y, collected }

function drawLevelDoneScreen() {
  levelDoneTimer++;
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.9)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  // Staggered reveal animation
  const t = levelDoneTimer;

  // Title (appears immediately)
  if (t > 10) {
    const a = Math.min(1, (t - 10) / 20);
    ctx.globalAlpha = a;
    ctx.font = 'bold 32px "Courier New"';
    ctx.fillStyle = '#44ff88';
    ctx.fillText('LEVEL CLEAR', W / 2, 80);
    ctx.font = '16px "Courier New"';
    ctx.fillStyle = '#ff6ec7';
    ctx.fillText(campaignLevel.id + ' \u2014 ' + campaignLevel.name, W / 2, 115);
  }

  // Stats (appear after short delay)
  if (t > 30) {
    const a = Math.min(1, (t - 30) / 20);
    ctx.globalAlpha = a;
    ctx.font = '14px "Courier New"';
    ctx.fillStyle = '#ccc';
    ctx.fillText('Score: ' + levelScore, W / 2, 175);
    ctx.fillText('Deaths: ' + levelDeaths, W / 2, 205);
    ctx.fillText('Damage Taken: ' + levelDamageTaken, W / 2, 235);
  }

  // Stars (appear with pop)
  if (t > 50) {
    const stars = levelDeaths === 0 && levelDamageTaken === 0 ? 3 :
                  levelDeaths === 0 ? 2 : 1;
    ctx.font = '36px "Courier New"';
    for (let i = 0; i < 3; i++) {
      const starDelay = 50 + i * 12;
      if (t > starDelay) {
        const sa = Math.min(1, (t - starDelay) / 15);
        const scale = 1 + Math.max(0, 1 - (t - starDelay) / 10) * 0.3;
        ctx.globalAlpha = sa;
        ctx.save();
        ctx.translate(W / 2 - 50 + i * 50, 300);
        ctx.scale(scale, scale);
        ctx.fillStyle = i < stars ? '#ffaa00' : '#333';
        ctx.fillText('\u2605', 0, 0);
        ctx.restore();
      }
    }
  }

  // Loot drop (appears after stars)
  if (t > 90 && lootDrop) {
    const def = EQUIPMENT_DEFS[lootDrop.itemId];
    if (def) {
      const a = Math.min(1, (t - 90) / 25);
      ctx.globalAlpha = a;
      const rarityColor = EQUIP_RARITY[def.rarity].color;
      ctx.font = 'bold 14px "Courier New"';
      ctx.fillStyle = '#ffffff';
      ctx.fillText('EQUIPMENT DROP', W / 2, 370);

      ctx.fillStyle = 'rgba(20,20,40,0.9)';
      ctx.fillRect(W / 2 - 120, 385, 240, 70);
      ctx.strokeStyle = rarityColor;
      ctx.lineWidth = 2;
      ctx.strokeRect(W / 2 - 120, 385, 240, 70);
      ctx.shadowColor = rarityColor;
      ctx.shadowBlur = 8;
      ctx.strokeRect(W / 2 - 120, 385, 240, 70);
      ctx.shadowBlur = 0;

      ctx.font = '20px "Courier New"';
      ctx.fillStyle = rarityColor;
      ctx.fillText(def.icon, W / 2 - 80, 428);
      ctx.font = 'bold 13px "Courier New"';
      ctx.fillStyle = rarityColor;
      ctx.fillText(def.name, W / 2 + 10, 415);
      ctx.font = '10px "Courier New"';
      ctx.fillStyle = '#aaa';
      ctx.fillText(def.desc, W / 2 + 10, 435);
      ctx.font = '9px "Courier New"';
      ctx.fillStyle = EQUIP_RARITY[def.rarity].color;
      ctx.fillText(EQUIP_RARITY[def.rarity].name, W / 2 + 10, 450);
    }
  }

  // Buttons (appear last, after everything settles)
  const btnReady = lootDrop ? 120 : 80;
  if (t > btnReady) {
    const a = Math.min(1, (t - btnReady) / 20);
    ctx.globalAlpha = a;

    const btnY = 500;
    const btnH = 50;
    const btnW = W / 2 - 50;
    const nextX = 40;
    const selX = W / 2 + 10;
    const hoverNext = levelDoneHover === 'next';
    const hoverSel = levelDoneHover === 'select';

    // Next Level button
    ctx.fillStyle = hoverNext ? 'rgba(68,255,136,0.15)' : 'rgba(20,20,40,0.8)';
    ctx.fillRect(nextX, btnY, btnW, btnH);
    ctx.strokeStyle = hoverNext ? '#88ffbb' : '#44ff88';
    ctx.lineWidth = hoverNext ? 2 : 1;
    ctx.strokeRect(nextX, btnY, btnW, btnH);
    ctx.font = 'bold 14px "Courier New"';
    ctx.fillStyle = hoverNext ? '#bbffdd' : '#44ff88';
    ctx.fillText('NEXT LEVEL', nextX + btnW / 2, btnY + btnH / 2 + 5);

    // Level Select button
    ctx.fillStyle = hoverSel ? 'rgba(136,136,255,0.15)' : 'rgba(20,20,40,0.8)';
    ctx.fillRect(selX, btnY, btnW, btnH);
    ctx.strokeStyle = hoverSel ? '#aaaaff' : '#6666aa';
    ctx.lineWidth = hoverSel ? 2 : 1;
    ctx.strokeRect(selX, btnY, btnW, btnH);
    ctx.fillStyle = hoverSel ? '#ccccff' : '#8888cc';
    ctx.fillText('LEVEL SELECT', selX + btnW / 2, btnY + btnH / 2 + 5);
  }

  ctx.globalAlpha = 1;
  ctx.restore();
}

function drawSelectScreen() {
  selectAnim++;
  ctx.save();

  // Dim overlay
  ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 24px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText('SELECT YOUR SHIP', W / 2, 50);

  const panelW = W / 3;
  const panelTop = 100;
  const panelH = 480;

  for (let i = 0; i < 3; i++) {
    const cfg = SHIP_CONFIGS[i];
    const cx = panelW * i + panelW / 2;
    const isSelected = i === selectedShip;

    // Panel background
    ctx.fillStyle = isSelected ? 'rgba(255,255,255,0.08)' : 'rgba(255,255,255,0.02)';
    ctx.fillRect(panelW * i + 6, panelTop, panelW - 12, panelH);

    // Selection border
    if (isSelected) {
      const pulse = 0.6 + Math.sin(selectAnim * 0.08) * 0.4;
      ctx.strokeStyle = cfg.color;
      ctx.globalAlpha = pulse;
      ctx.lineWidth = 2;
      ctx.strokeRect(panelW * i + 6, panelTop, panelW - 12, panelH);
      ctx.globalAlpha = 1;
    }

    // Ship sprite preview
    const shipY = panelTop + 90;
    const previewSize = 72;
    ctx.save();
    ctx.translate(cx, shipY);

    // Floating animation
    const float = Math.sin(selectAnim * 0.04 + i * 2) * 5;
    ctx.translate(0, float);

    if (cfg.drawType === 'foozle') {
      const spr = img.playerBase;
      if (spr) ctx.drawImage(spr, -previewSize / 2, -previewSize / 2, previewSize, previewSize);
    } else if (cfg.drawType === 'kenney2') {
      const spr = img.ship2Base;
      if (spr) ctx.drawImage(spr, -previewSize / 2, -previewSize / 2, previewSize, previewSize);
    } else {
      const spr = img.ship3Base;
      if (spr) ctx.drawImage(spr, -previewSize / 2, -previewSize / 2, previewSize, previewSize);
    }

    // Ship glow
    ctx.globalCompositeOperation = 'lighter';
    const gR = previewSize * 0.6;
    const gGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, gR);
    gGrad.addColorStop(0, cfg.color + '33');
    gGrad.addColorStop(1, cfg.color + '00');
    ctx.fillStyle = gGrad;
    ctx.fillRect(-gR, -gR, gR * 2, gR * 2);
    ctx.globalCompositeOperation = 'source-over';

    ctx.restore();

    // Ship name
    ctx.fillStyle = cfg.color;
    ctx.font = 'bold 16px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(cfg.name, cx, panelTop + 155);

    // Subtitle
    ctx.fillStyle = '#888';
    ctx.font = '10px "Courier New"';
    ctx.fillText(cfg.subtitle, cx, panelTop + 172);

    // Stat bars
    const statNames = ['HP', 'SPD', 'PWR', 'BMB'];
    const statKeys = ['hp', 'spd', 'pwr', 'bmb'];
    const statColors = ['#ff4444', '#44aaff', '#ffaa00', '#44ff44'];
    const barX = panelW * i + 24;
    const barStartY = panelTop + 200;

    for (let s = 0; s < 4; s++) {
      const sy = barStartY + s * 28;
      ctx.fillStyle = '#888';
      ctx.font = '10px "Courier New"';
      ctx.textAlign = 'left';
      ctx.fillText(statNames[s], barX, sy + 10);
      const barW = panelW - 70;
      const bx = barX + 30;
      ctx.fillStyle = '#222';
      ctx.fillRect(bx, sy, barW, 10);
      ctx.fillStyle = statColors[s];
      ctx.fillRect(bx, sy, barW * (cfg.stats[statKeys[s]] / 5), 10);
    }

    // Description
    ctx.fillStyle = '#aaa';
    ctx.font = '10px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(cfg.desc[0], cx, panelTop + 340);
    ctx.fillText(cfg.desc[1], cx, panelTop + 356);

    // Weapon/Bomb info
    ctx.fillStyle = '#666';
    ctx.font = '9px "Courier New"';
    if (i === 0) {
      ctx.fillText('WEAPON: Spread Shot', cx, panelTop + 390);
      ctx.fillText('BOMB: Full Clear', cx, panelTop + 406);
    } else if (i === 1) {
      ctx.fillText('WEAPON: Rapid Beam', cx, panelTop + 390);
      ctx.fillText('BOMB: Forward Cone', cx, panelTop + 406);
    } else {
      ctx.fillText('WEAPON: Wide Spread', cx, panelTop + 390);
      ctx.fillText('BOMB: Shield Bubble', cx, panelTop + 406);
    }
  }

  // Confirm prompt
  const confirmAlpha = 0.5 + Math.sin(selectAnim * 0.08) * 0.5;
  ctx.globalAlpha = confirmAlpha;
  ctx.fillStyle = '#00ffff';
  ctx.font = '14px "Courier New"';
  ctx.textAlign = 'center';
  if (isMobile) {
    ctx.fillText('[ TAP SHIP TO SELECT — TAP AGAIN TO LAUNCH ]', W / 2, H - 40);
  } else {
    ctx.fillText('[ LEFT/RIGHT TO SELECT — ENTER TO LAUNCH ]', W / 2, H - 40);
  }
  ctx.globalAlpha = 1;

  ctx.restore();
}

// ---- HUD ----
function drawPowerBar(x, y, w) {
  // Visual power progression: 4 segments showing current level & what's ahead
  const segW = (w - 6) / 4; // 4 segments with 2px gaps
  const segH = 8;
  const shipColor = (gameMode === 'campaign' ? CAMPAIGN_SHIP : SHIP_CONFIGS[selectedShip]).color;
  const labels = ['I', 'II', 'III', 'IV'];

  for (let i = 0; i < 4; i++) {
    const sx = x + i * (segW + 2);
    const filled = player.power >= i + 1;

    // Background
    ctx.fillStyle = '#222';
    ctx.fillRect(sx, y, segW, segH);

    if (filled) {
      // Filled segment with ship color gradient
      const grad = ctx.createLinearGradient(sx, y, sx + segW, y);
      grad.addColorStop(0, shipColor);
      grad.addColorStop(1, shipColor + 'aa');
      ctx.fillStyle = grad;
      ctx.fillRect(sx, y, segW, segH);

      // Bright edge
      ctx.fillStyle = '#ffffff55';
      ctx.fillRect(sx, y, segW, 1);
    } else {
      // Empty segment outline
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(sx, y, segW, segH);
    }

    // Level number below
    ctx.fillStyle = filled ? shipColor : '#555';
    ctx.font = '8px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(labels[i], sx + segW / 2, y + segH + 10);
  }

  // "PWR" label
  ctx.fillStyle = '#888';
  ctx.font = '9px "Courier New"';
  ctx.textAlign = 'left';
  ctx.fillText('PWR', x, y - 3);
}

function drawHUD() {
  ctx.fillStyle = '#ffffff'; ctx.font = '14px "Courier New"'; ctx.textAlign = 'left';
  const hudCfg = gameMode === 'campaign' ? CAMPAIGN_SHIP : SHIP_CONFIGS[selectedShip];
  const waveText = gameMode === 'campaign' && campaignLevel
    ? `${campaignLevel.id} W${wave}/${campaignTotalWaves}`
    : `WAVE ${wave}`;

  if (isMobile) {
    // ---- MOBILE HUD LAYOUT ----
    // Top bar: ship name + wave + status
    ctx.fillStyle = hudCfg.color;
    ctx.font = 'bold 12px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(hudCfg.name, W / 2, 15);

    ctx.fillStyle = '#7b68ee'; ctx.textAlign = 'right';
    ctx.font = '12px "Courier New"';
    ctx.fillText(waveText, W - 10, 15);

    ctx.fillStyle = '#555'; ctx.textAlign = 'left';
    ctx.font = '10px "Courier New"';
    ctx.fillText(`${enemyBullets.length} BULLETS`, 10, 15);

    // Second row: HP hearts + bomb stars
    ctx.fillStyle = '#ff4444';
    ctx.font = '14px "Courier New"'; ctx.textAlign = 'left';
    for (let i = 0; i < player.hp; i++) {
      ctx.fillText('\u2665', 10 + i * 15, 35);
    }
    // Bomb stars after hearts with a gap
    const bombStartX = 10 + player.maxHp * 15 + 10;
    ctx.fillStyle = '#44ff44';
    for (let i = 0; i < player.bombs; i++) {
      ctx.fillText('*', bombStartX + i * 14, 35);
    }

    // Power bar on right side of second row
    drawPowerBar(W - 130, 26, 120);

    // Bottom left: score + graze (safe from buttons)
    ctx.fillStyle = '#ffffff'; ctx.font = '14px "Courier New"'; ctx.textAlign = 'left';
    ctx.fillText(`SCORE: ${score.toString().padStart(8, '0')}`, 10, H - 15);
    ctx.fillStyle = '#888';
    ctx.fillText(`HI: ${hiScore.toString().padStart(8, '0')}`, 10, H - 33);
    ctx.fillStyle = '#888';
    ctx.font = '12px "Courier New"';
    ctx.fillText(`GRAZE: ${graze}`, 10, H - 51);

  } else {
    // ---- DESKTOP HUD LAYOUT ----
    // Top bar: bullets / ship name / wave
    ctx.fillStyle = '#555';
    ctx.fillText(`BULLETS: ${enemyBullets.length}`, 10, 15);

    ctx.fillStyle = hudCfg.color;
    ctx.textAlign = 'center';
    ctx.fillText(hudCfg.name, W / 2, 15);

    ctx.fillStyle = '#7b68ee'; ctx.textAlign = 'right';
    ctx.fillText(waveText, W - 10, 15);

    // Bottom left: score / hi / graze
    ctx.textAlign = 'left';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`SCORE: ${score.toString().padStart(8, '0')}`, 10, H - 10);
    ctx.fillStyle = '#888';
    ctx.fillText(`HI: ${hiScore.toString().padStart(8, '0')}`, 10, H - 28);
    ctx.fillStyle = '#888';
    ctx.fillText(`GRAZE: ${graze}`, 10, H - 46);

    // Bottom right: HP hearts / bomb stars / power bar
    ctx.fillStyle = '#ff4444'; ctx.textAlign = 'left';
    for (let i = 0; i < player.hp; i++) ctx.fillText('\u2665', W - 140 + i * 16, H - 10);

    ctx.fillStyle = '#44ff44';
    for (let i = 0; i < player.bombs; i++) ctx.fillText('*', W - 140 + i * 16, H - 28);

    // Power bar
    drawPowerBar(W - 140, H - 58, 130);
  }
}

// ============================================================
//  MAIN UPDATE
// ============================================================
function update() {
  globalTime++;
  if (bombCooldown > 0) bombCooldown--;

  const dt = slowmoTimer > 0 ? 0.5 : 1;
  if (slowmoTimer > 0) slowmoTimer--;

  // Scroll background
  bgScrollY += 1.0 * dt;

  // Parallax stars
  for (const s of bgStars) {
    s.y += s.speed * dt;
    if (s.y > H) { s.y = -2; s.x = Math.random() * W; }
  }

  // Meteors
  for (const m of bgMeteors) {
    m.y += m.speed * dt;
    m.rot += m.rotSpeed * dt;
    if (m.y > H + 20) { m.y = -20; m.x = Math.random() * W; }
  }

  // Fire sprites
  for (const f of fireSprites) {
    f.x += f.vx * dt;
    f.y += f.vy * dt;
    f.alpha -= f.decay;
    f.rot += f.rotSpeed;
    f.scale *= 1.02;
  }
  fireSprites = fireSprites.filter(f => f.alpha > 0);

  if (gameState !== 'playing') return;

  const p = player;
  if (!p.alive) {
    p.deathAnim++;
    if (p.deathAnim > 90) {
      if (p.hp > 0) {
        p.alive = true; p.deathAnim = 0; p.invincible = 180 + resolvedMods.invincBonus;
        p.x = W / 2; p.y = H - 80;
        enemyBullets = enemyBullets.filter(b => dist(b, p) > 100);
      } else if (resolvedMods.secondWind && !runPowerups.secondWindUsed) {
        runPowerups.secondWindUsed = true;
        p.hp = 2; p.alive = true; p.deathAnim = 0; p.invincible = 300;
        p.x = W / 2; p.y = H - 80;
        enemyBullets = [];
        spawnParticles(p.x, p.y, '#ffaa22', 60, 8, 40, 4);
        shakeTimer = 20; shakeIntensity = 8;
        powerupAnnouncement = { name: 'SECOND WIND', desc: 'Revived!', rarity: RARITY.LEGENDARY, timer: 120 };
      } else {
        if (gameMode === 'campaign') {
          // Campaign: return to level select
          if (isMobile) { touchControls.classList.remove('active'); autoFireIndicator.style.display = 'none'; }
          showLevelSelect();
        } else {
          gameState = 'gameover';
          document.getElementById('game-over').style.display = 'flex';
          if (isMobile) touchControls.classList.remove('active');
          if (gameMode === 'bossfight') {
            const entry = BOSS_FIGHT_LIST.find(b => b.type === bossFightType);
            document.getElementById('final-score').textContent = `DEFEATED BY`;
            document.getElementById('final-wave').textContent = entry ? entry.name : 'BOSS';
          } else {
            document.getElementById('final-score').textContent = `SCORE: ${score.toString().padStart(8, '0')}`;
            document.getElementById('final-wave').textContent = `REACHED WAVE ${wave}`;
          }
          if (score > hiScore) { hiScore = score; localStorage.setItem('stellarHiScore', hiScore); }
        }
      }
    }
    return;
  }

  // Player movement
  const focused = isFocused();
  const baseSpd = focused ? p.focusSpeed * resolvedMods.focusSpeedMult : p.speed;
  const spd = baseSpd * resolvedMods.speedMult * dt;

  let mx = 0, my = 0;
  if (keys['arrowleft'] || keys['a']) mx -= 1;
  if (keys['arrowright'] || keys['d']) mx += 1;
  if (keys['arrowup'] || keys['w']) my -= 1;
  if (keys['arrowdown'] || keys['s']) my += 1;
  const mag = Math.hypot(mx, my);
  if (mag > 1) { mx /= mag; my /= mag; }
  p.x += mx * spd;
  p.y += my * spd;

  // Touch: apply accumulated 1:1 drag delta directly
  if (touch.dx !== 0 || touch.dy !== 0) {
    p.x += touch.dx;
    p.y += touch.dy;
    touch.dx = 0;
    touch.dy = 0;
  }

  p.x = Math.max(14, Math.min(W - 14, p.x));
  p.y = Math.max(14, Math.min(H - 14, p.y));

  // Options
  if (p.power >= 4) {
    const optCount = selectedShip === 2 ? 3 : 2;
    if (p.options.length < optCount) {
      p.options = [];
      for (let i = 0; i < optCount; i++) {
        p.options.push({ x: p.x, y: p.y + 5 });
      }
    }
    const optDist = focused ? 15 : 30;
    if (optCount === 2) {
      p.options[0].x = lerp(p.options[0].x, p.x - optDist, 0.1);
      p.options[0].y = lerp(p.options[0].y, p.y + 5, 0.1);
      p.options[1].x = lerp(p.options[1].x, p.x + optDist, 0.1);
      p.options[1].y = lerp(p.options[1].y, p.y + 5, 0.1);
    } else {
      // 3 options: left, right, and behind
      p.options[0].x = lerp(p.options[0].x, p.x - optDist, 0.1);
      p.options[0].y = lerp(p.options[0].y, p.y + 3, 0.1);
      p.options[1].x = lerp(p.options[1].x, p.x + optDist, 0.1);
      p.options[1].y = lerp(p.options[1].y, p.y + 3, 0.1);
      p.options[2].x = lerp(p.options[2].x, p.x, 0.1);
      p.options[2].y = lerp(p.options[2].y, p.y + 20, 0.1);
    }
  }

  // Shooting
  const wantShoot = keys[' '] || keys['z'] || isMobile;
  if (wantShoot) {
    p.shootTimer++;
    const effectiveDelay = Math.max(2, p.shootDelay * resolvedMods.shootDelayMult);
    if (p.shootTimer >= effectiveDelay) {
      p.shootTimer = 0;
      playerShoot();
      // Backfire streams
      if (resolvedMods.backfireStreams > 0) {
        const streams = resolvedMods.backfireStreams;
        const spreadAngle = 0.3;
        for (let i = 0; i < streams; i++) {
          const angle = Math.PI / 2 + (i - (streams - 1) / 2) * spreadAngle;
          createPlayerBullet({ x: p.x, y: p.y + 10, vx: Math.cos(angle) * 6, vy: Math.sin(angle) * 6, damage: 1, size: 2, color: '#ffaa44', type: 'back' });
        }
      }
    }
  }

  // Bomb
  if (keys['x'] || touch.bomb) {
    keys['x'] = false;
    touch.bomb = false;
    useBomb();
  }

  // Player bullets
  for (const b of playerBullets) {
    // Homing steering
    if (b.homing && b.homing > 0) {
      const target = findNearestEnemy(b.x, b.y);
      if (target) {
        const desired = angleToward(b, target);
        const current = Math.atan2(b.vy, b.vx);
        let diff = desired - current;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        const turn = Math.sign(diff) * Math.min(Math.abs(diff), b.homing);
        const newAngle = current + turn;
        const s = Math.hypot(b.vx, b.vy);
        b.vx = Math.cos(newAngle) * s;
        b.vy = Math.sin(newAngle) * s;
      }
    }
    b.x += b.vx * dt; b.y += b.vy * dt;
  }
  playerBullets = playerBullets.filter(b => b.y > -20 && b.y < H + 20 && b.x > -20 && b.x < W + 20);

  // Enemy bullets
  for (const b of enemyBullets) {
    if (b.delay && b.delay > 0) { b.delay--; continue; }
    b.x += b.vx * dt; b.y += b.vy * dt;
    // Hydra glob landing: convert to persistent pool when near target
    if (b.isGlob && b.globOwner && Math.hypot(b.x - b.globTargetX, b.y - b.globTargetY) < 20) {
      b.globOwner.globs.push({ x: b.x, y: b.y, timer: b.globDuration, maxTimer: b.globDuration, pulseTimer: 60 });
      spawnParticles(b.x, b.y, '#bb55ff', 8, 3, 15, 2);
      shakeTimer = 3; shakeIntensity = 2;
      b.x = -999; // Remove bullet
    }
  }
  enemyBullets = enemyBullets.filter(b => b.x > -30 && b.x < W + 30 && b.y > -30 && b.y < H + 30);

  for (const e of enemies) { if (e.alive) updateEnemyAI(e); }
  for (const b of bosses) { if (b.alive) updateBossAI(b); }

  // Collision: player bullets -> enemies
  for (const b of playerBullets) {
    for (const e of enemies) {
      if (!e.alive) continue;
      if (Math.abs(b.x - e.x) < e.w / 2 + 4 && Math.abs(b.y - e.y) < e.h / 2 + 4) {
        e.hp -= b.damage; e.flash = 3;
        // Pierce handling
        if (b.pierce && b.pierceRemaining !== undefined) {
          b.pierceRemaining--;
          if (b.pierceRemaining <= 0) b.pierce = false;
        } else if (!b.pierce) {
          // Split shot on hit
          if (resolvedMods.splitOnHit && b.type === 'main' && !b.hasSplit) {
            const bAngle = Math.atan2(b.vy, b.vx);
            playerBullets.push({ x: b.x, y: b.y, vx: Math.cos(bAngle - 0.7) * 8, vy: Math.sin(bAngle - 0.7) * 8, damage: b.damage * 0.4, size: 2, color: '#aaffff', type: 'split', hasSplit: true });
            playerBullets.push({ x: b.x, y: b.y, vx: Math.cos(bAngle + 0.7) * 8, vy: Math.sin(bAngle + 0.7) * 8, damage: b.damage * 0.4, size: 2, color: '#aaffff', type: 'split', hasSplit: true });
          }
          b.y = -999;
        }
        spawnParticles(b.x, b.y, e.color, 2, 2, 10, 2);
        if (e.hp <= 0) {
          e.alive = false; score += Math.floor(e.value * resolvedMods.scoreKillMult);
          spawnExplosion(e.x, e.y, e.color, e.type === 'tank');
          if (Math.random() < 0.3) spawnItem(e.x, e.y, 'power');
          if (Math.random() < 0.2) spawnItem(e.x + rand(-10, 10), e.y, 'score');
          if (Math.random() < 0.05) spawnItem(e.x, e.y, 'bomb');
          // Chain Lightning
          if (resolvedMods.chainTargets > 0) {
            const chainDmg = (e.maxHp || 10) * resolvedMods.chainDamagePct;
            const targets = enemies.filter(e2 => e2.alive && e2 !== e)
              .sort((a2, b2) => dist(a2, e) - dist(b2, e))
              .slice(0, resolvedMods.chainTargets);
            for (const t of targets) {
              t.hp -= chainDmg; t.flash = 5;
              spawnParticles(t.x, t.y, '#88ccff', 4, 3, 12, 2);
              if (t.hp <= 0) {
                t.alive = false; score += Math.floor(t.value * resolvedMods.scoreKillMult);
                spawnExplosion(t.x, t.y, t.color, false);
              }
            }
          }
        }
      }
    }
    for (const boss of bosses) {
      if (!boss.alive) continue;
      // Sentinel shield blocking — check if bullet is blocked by a shield arc before core hit
      if (boss.type === 7 && boss.shieldsAlive > 0) {
        const distFromCore = Math.hypot(b.x - boss.x, b.y - boss.y);
        // Only check blocking if bullet is near the shield orbit ring (±18px of orbit radius 55)
        if (distFromCore > 37 && distFromCore < 73) {
          const bulletAngle = Math.atan2(b.y - boss.y, b.x - boss.x);
          let blocked = false;
          for (let si = 0; si < boss.orbCount; si++) {
            if (!boss.shields[si].alive) continue;
            const shieldAngle = boss.orbAngle + (si / boss.orbCount) * Math.PI * 2;
            let angleDiff = bulletAngle - shieldAngle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            if (Math.abs(angleDiff) < Math.PI / 8) { // 22.5 degrees each side = 45 degree arc
              // Bullet hits shield!
              boss.shields[si].hp -= b.damage;
              boss.shields[si].flash = 3;
              if (boss.shields[si].hp <= 0) {
                boss.shields[si].alive = false;
                boss.shields[si].hp = 0;
                const sAngle = shieldAngle;
                const sx = boss.x + Math.cos(sAngle) * 55;
                const sy = boss.y + Math.sin(sAngle) * 55;
                spawnExplosion(sx, sy, '#4488ff', false);
                shakeTimer = 6; shakeIntensity = 3;
                // Counterattack: ring burst from boss
                fireCircle(boss.x, boss.y, 8, 2.5, '#4488ff', Math.random() * Math.PI * 2);
                // Retreat dash to opposite side
                boss.retreatTimer = 30;
                boss.targetX = boss.x < W / 2 ? W - 80 - Math.random() * 60 : 80 + Math.random() * 60;
              }
              spawnParticles(b.x, b.y, '#4488ff', 2, 2, 8, 2);
              b.y = -999; // Destroy bullet
              blocked = true;
              break;
            }
          }
          if (blocked) continue;
        }
      }
      // Multi-circle hitbox for minibosses, AABB for regular bosses
      let bossHit = false;
      let hitCircle = null;
      if (boss.isMiniboss) {
        const circles = getMinibossHitCircles(boss);
        for (const c of circles) {
          if (Math.hypot(b.x - c.x, b.y - c.y) < c.r + b.size) { bossHit = true; hitCircle = c; break; }
        }
      } else {
        bossHit = Math.abs(b.x - boss.x) < boss.w / 2 + 4 && Math.abs(b.y - boss.y) < boss.h / 2 + 4;
      }
      if (bossHit) {
        // Sentinel: route damage to shield orbs or core
        if (boss.type === 7 && hitCircle && hitCircle.part === 'shield') {
          const shield = boss.shields[hitCircle.shieldIdx];
          shield.hp -= b.damage;
          if (shield.hp <= 0) {
            shield.alive = false;
            shield.hp = 0;
            spawnExplosion(hitCircle.x, hitCircle.y, '#4488ff', false);
            shakeTimer = 6; shakeIntensity = 3;
            fireCircle(boss.x, boss.y, 8, 2.5, '#4488ff', Math.random() * Math.PI * 2);
            boss.retreatTimer = 30;
            boss.targetX = boss.x < W / 2 ? W - 80 - Math.random() * 60 : 80 + Math.random() * 60;
          }
          boss.flash = 2;
        } else if (boss.type === 7 && hitCircle && hitCircle.part === 'core') {
          // Core hit — 1.5x damage when 0 shields
          const coreMult = boss.shieldsAlive === 0 ? 1.5 : 1.0;
          boss.hp -= b.damage * coreMult;
          boss.flash = 2;
          if (boss.vulnerabilityActive) boss.vulnerabilityDmgAccum += b.damage;
        // Hydra: route damage to heads, necks (reduced), or body
        } else if (boss.type === 8 && hitCircle && hitCircle.part === 'head') {
          const head = boss.heads[hitCircle.headIdx];
          head.hp -= b.damage;
          boss.hp -= b.damage * 0.5;
          if (head.hp <= 0 && head.alive) {
            head.alive = false;
            head.hp = 0;
            head.regenTimer = 480;
            boss.lastSeverTimes[hitCircle.headIdx] = globalTime;
            const hp = boss.headPositions[hitCircle.headIdx];
            spawnExplosion(hp.x, hp.y, hitCircle.headIdx === 0 ? '#ff4444' : hitCircle.headIdx === 1 ? '#4488ff' : '#cc44ff', false);
            shakeTimer = 8; shakeIntensity = 4;
            for (let oh = 0; oh < 3; oh++) {
              if (boss.heads[oh].alive) {
                const ohp = boss.headPositions[oh];
                fireCircle(ohp.x, ohp.y, 8, 2.5, ['#ff4444','#4488ff','#cc44ff'][oh], Math.random() * Math.PI * 2);
              }
            }
          }
          boss.flash = 2;
        } else if (boss.type === 8 && hitCircle && hitCircle.part === 'neck') {
          // Neck hit: 25% damage to head, 10% to body — necks are tough
          const head = boss.heads[hitCircle.headIdx];
          if (head.alive) {
            head.hp -= b.damage * 0.25;
            // Neck damage can sever a head too
            if (head.hp <= 0) {
              head.alive = false; head.hp = 0;
              head.regenTimer = 480;
              boss.lastSeverTimes[hitCircle.headIdx] = globalTime;
              const shp = boss.headPositions[hitCircle.headIdx];
              spawnExplosion(shp.x, shp.y, ['#ff4444','#4488ff','#cc44ff'][hitCircle.headIdx], false);
              shakeTimer = 6; shakeIntensity = 3;
            }
          }
          boss.hp -= b.damage * 0.1;
          boss.flash = 1;
        } else if (boss.type === 8) {
          const dmgMult = boss.exposedActive ? 3.0 : 1.0;
          boss.hp -= b.damage * dmgMult; boss.flash = 2;
        } else if (boss.type === 5) {
          // Scarab: 50% armor when charging (wings folded)
          const scarabMult = boss.charging ? 0.5 : 1.0;
          boss.hp -= b.damage * scarabMult; boss.flash = 2;
        } else {
          boss.hp -= b.damage; boss.flash = 2;
        }
        if (b.pierce && b.pierceRemaining !== undefined) {
          b.pierceRemaining--;
          if (b.pierceRemaining <= 0) b.pierce = false;
        } else if (!b.pierce) {
          if (resolvedMods.splitOnHit && b.type === 'main' && !b.hasSplit) {
            const bAngle = Math.atan2(b.vy, b.vx);
            playerBullets.push({ x: b.x, y: b.y, vx: Math.cos(bAngle - 0.7) * 8, vy: Math.sin(bAngle - 0.7) * 8, damage: b.damage * 0.4, size: 2, color: '#aaffff', type: 'split', hasSplit: true });
            playerBullets.push({ x: b.x, y: b.y, vx: Math.cos(bAngle + 0.7) * 8, vy: Math.sin(bAngle + 0.7) * 8, damage: b.damage * 0.4, size: 2, color: '#aaffff', type: 'split', hasSplit: true });
          }
          b.y = -999;
        }
        spawnParticles(b.x, b.y, boss.color, 1, 2, 8, 2);
        if (boss.hp <= 0) {
          boss.alive = false; score += boss.value;
          spawnExplosion(boss.x, boss.y, boss.color, true);
          if (boss.isMiniboss) {
            // Miniboss: smaller explosion, fewer drops
            shakeTimer = 15; shakeIntensity = 6;
            for (let i = 0; i < 4; i++) spawnItem(boss.x + rand(-30, 30), boss.y + rand(-15, 15), 'score');
            spawnItem(boss.x + rand(-20, 20), boss.y, 'power');
          } else {
            // Full boss: big explosion
            spawnExplosion(boss.x - 20, boss.y + 10, '#ffaa00', true);
            spawnExplosion(boss.x + 20, boss.y - 10, '#ffffff', true);
            shakeTimer = 30; shakeIntensity = 12;
            for (let i = 0; i < 8; i++) spawnItem(boss.x + rand(-40, 40), boss.y + rand(-20, 20), 'score');
            for (let i = 0; i < 3; i++) spawnItem(boss.x + rand(-30, 30), boss.y + rand(-10, 10), 'power');
            spawnItem(boss.x, boss.y, 'bomb');
          }
          // Spawn roguelike powerup choices (skip in boss fight mode)
          if (gameMode !== 'bossfight') spawnPowerupChoices(boss.x, boss.y);
          // Campaign loot drop
          if (gameMode === 'campaign' && campaignLevel) {
            const lootType = boss.isMiniboss ? 'miniboss' : 'boss';
            const lootId = rollLoot(lootType, campaignLevel.id);
            if (lootId) {
              lootDrop = { itemId: lootId };
              saveData.inventory.push(lootId);
              writeSave();
            }
          }
        }
      }
    }
  }

  // Orbital blades collision
  if (resolvedMods.orbitalBlades > 0 && p.alive) {
    const bladeCount = resolvedMods.orbitalBlades;
    const orbitRadius = 30;
    for (let i = 0; i < bladeCount; i++) {
      const angle = globalTime * 0.05 + (i / bladeCount) * Math.PI * 2;
      const bx = p.x + Math.cos(angle) * orbitRadius;
      const by = p.y + Math.sin(angle) * orbitRadius;
      for (const e of enemies) {
        if (!e.alive) continue;
        if (Math.hypot(bx - e.x, by - e.y) < e.w / 2 + 8) {
          e.hp -= 2; e.flash = 3;
          if (e.hp <= 0) { e.alive = false; score += Math.floor(e.value * resolvedMods.scoreKillMult); spawnExplosion(e.x, e.y, e.color, false); }
        }
      }
      for (const boss of bosses) {
        if (!boss.alive) continue;
        let bladeHit = false;
        if (boss.isMiniboss) {
          for (const c of getMinibossHitCircles(boss)) {
            if (Math.hypot(bx - c.x, by - c.y) < c.r + 8) { bladeHit = true; break; }
          }
        } else {
          bladeHit = Math.hypot(bx - boss.x, by - boss.y) < boss.w / 2 + 8;
        }
        if (bladeHit) { boss.hp -= 2; boss.flash = 2; }
      }
    }
  }

  // Powerup choices update
  if (powerupSelectActive && powerupChoices.length > 0) {
    for (const choice of powerupChoices) {
      choice.vy += choice.gravity;
      choice.vy = Math.min(choice.vy, 1.0);
      choice.y += choice.vy * dt;
      choice.life--;
      // Rarity particle trail
      if (globalTime % 8 === 0) spawnParticles(choice.x, choice.y, choice.powerup.rarity.color, 1, 1, 20, 1.5);
      // Collision with player
      if (!powerupCollectedThisBoss && dist(choice, p) < 30) {
        choice.collected = true;
        collectPowerup(choice.powerup);
        for (const other of powerupChoices) {
          if (!other.collected) { other.collected = true; spawnParticles(other.x, other.y, '#ffffff', 8, 3, 20, 2); }
        }
      }
      // Gentle attraction when near
      if (dist(choice, p) < 60) {
        const a = angleToward(choice, p);
        choice.x += Math.cos(a) * 1.5; choice.y += Math.sin(a) * 1.5;
      }
      choice.x = Math.max(20, Math.min(W - 20, choice.x));
      choice.y = Math.min(H - 40, choice.y);
    }
    powerupChoices = powerupChoices.filter(c => !c.collected && c.life > 0);
    if (powerupChoices.length === 0) powerupSelectActive = false;
  }

  // Shield bomb update (Bastion)
  if (shieldBombActive) {
    shieldBombTimer--;
    if (shieldBombTimer <= 0) {
      shieldBombActive = false;
    } else {
      const newBullets = [];
      for (const b of enemyBullets) {
        const d = dist(b, p);
        if (d < shieldBombRadius) {
          // Convert bullet to score item
          score += 20;
          spawnParticles(b.x, b.y, '#44ff88', 2, 1, 10, 1);
        } else {
          newBullets.push(b);
        }
      }
      enemyBullets = newBullets;
    }
  }

  // Collision: enemy bullets -> player
  if (p.invincible > 0) p.invincible--;
  for (const b of enemyBullets) {
    const d = dist(b, p);
    const grazeRange = 20 + resolvedMods.grazeRadiusBonus;
    if (d < grazeRange && d > p.hitboxRadius + b.size && !b.grazed) {
      b.grazed = true; graze++; score += Math.floor(50 * resolvedMods.grazeScoreMult);
      spawnParticles(b.x, b.y, '#ffffff', 2, 1, 8, 1);
      // Bullet Eater
      if (resolvedMods.bulletEatChance > 0 && Math.random() < resolvedMods.bulletEatChance) {
        b.y = -999;
        p.hp = Math.min(p.hp + 1, p.maxHp);
        spawnParticles(b.x, b.y, '#44ff88', 5, 2, 15, 2);
      }
    }
    if (d < p.hitboxRadius + b.size) {
      if (p.invincible <= 0) {
        // Auto Bomb
        if (resolvedMods.autoBomb && p.bombs > 0) {
          useBomb(); p.invincible = 60;
          break;
        }
        p.hp--; p.alive = false; p.deathAnim = 0;
        levelDamageTaken++; levelDeaths++;
        shakeTimer = 20; shakeIntensity = 10;
        spawnExplosion(p.x, p.y, '#00ffff', true);
        spawnExplosion(p.x, p.y, '#ffffff', true);
        enemyBullets = [];
        break;
      }
    }
  }

  // Collision: Hydra beams -> player
  if (p.alive && p.invincible <= 0) {
    for (const boss of bosses) {
      if (!boss.alive || boss.type !== 8) continue;
      for (const beam of boss.beams) {
        // Point-to-line distance from player to beam
        const cosA = Math.cos(beam.angle), sinA = Math.sin(beam.angle);
        const dx = p.x - beam.x, dy = p.y - beam.y;
        const proj = dx * cosA + dy * sinA; // Projection along beam direction
        if (proj < 0) continue; // Behind the beam origin
        const perpDist = Math.abs(dx * sinA - dy * cosA);
        if (perpDist < beam.width / 2 + p.hitboxRadius) {
          p.hp--; p.alive = false; p.deathAnim = 0;
          levelDamageTaken++; levelDeaths++;
          shakeTimer = 20; shakeIntensity = 10;
          spawnExplosion(p.x, p.y, '#ff4444', true);
          enemyBullets = [];
          break;
        }
      }
    }
  }

  // Collision: Hydra glob pools -> player
  if (p.alive && p.invincible <= 0) {
    for (const boss of bosses) {
      if (!boss.alive || boss.type !== 8) continue;
      for (const glob of boss.globs) {
        if (dist(glob, p) < 16 + p.hitboxRadius) {
          p.hp--; p.alive = false; p.deathAnim = 0;
          levelDamageTaken++; levelDeaths++;
          shakeTimer = 15; shakeIntensity = 6;
          spawnExplosion(p.x, p.y, '#bb55ff', true);
          enemyBullets = [];
          break;
        }
      }
    }
  }

  // Collision: enemies -> player
  for (const e of enemies) {
    if (!e.alive) continue;
    if (Math.abs(p.x - e.x) < e.w / 2 + p.hitboxRadius && Math.abs(p.y - e.y) < e.h / 2 + p.hitboxRadius) {
      if (p.invincible <= 0) {
        p.hp--; p.alive = false; p.deathAnim = 0;
        levelDamageTaken++; levelDeaths++;
        shakeTimer = 20; shakeIntensity = 10;
        spawnExplosion(p.x, p.y, '#00ffff', true);
        e.hp -= 5; if (e.hp <= 0) e.alive = false;
        break;
      }
    }
  }

  // Items
  const collectDist = (isFocused() ? 80 : 25) * resolvedMods.collectRadiusMult;
  for (const item of items) {
    item.vy += item.gravity; item.vy = Math.min(item.vy, 2);
    item.y += item.vy * dt; item.life--;
    if (dist(item, p) < collectDist) {
      item.collected = true;
      switch (item.type) {
        case 'power': player.power = Math.min(4, player.power + 1); score += 100; break;
        case 'score': score += 500; break;
        case 'bomb': player.bombs = Math.min(5, player.bombs + 1); break;
      }
      spawnParticles(item.x, item.y, '#ffffff', 5, 2, 15, 2);
    }
    if (p.y < H * 0.3 || dist(item, p) < 60) {
      const a = angleToward(item, p);
      item.x += Math.cos(a) * 4; item.y += Math.sin(a) * 4; item.vy = 0;
    }
  }
  items = items.filter(i => !i.collected && i.life > 0 && i.y < H + 20);

  // Particles
  for (const p2 of particles) { p2.x += p2.vx * dt; p2.y += p2.vy * dt; p2.vx *= 0.97; p2.vy *= 0.97; p2.life--; }
  particles = particles.filter(p2 => p2.life > 0);

  enemies = enemies.filter(e => e.alive);
  bosses = bosses.filter(b => b.alive);

  waveTimer++;
  if (enemies.length === 0 && bosses.length === 0 && waveTimer > 120) {
    if (gameMode === 'bossfight') {
      // Boss fight mode: spawn boss on first wave, victory after it dies
      if (wave === 0) {
        wave = 1; waveTimer = 0;
        const boss = createBoss(bossFightType);
        // Use campaign HP values from BOSS_FIGHT_LIST
        const entry = BOSS_FIGHT_LIST.find(b => b.type === bossFightType);
        if (entry) { boss.hp = entry.hp; boss.maxHp = entry.hp; }
        bosses.push(boss);
      } else {
        // Boss defeated — victory!
        gameState = 'gameover';
        document.getElementById('game-over').style.display = 'flex';
        if (isMobile) touchControls.classList.remove('active');
        const entry = BOSS_FIGHT_LIST.find(b => b.type === bossFightType);
        document.getElementById('final-score').textContent = `VICTORY!`;
        document.getElementById('final-wave').textContent = `${entry ? entry.name : 'BOSS'} DEFEATED`;
      }
    } else if (gameMode === 'campaign') {
      if (campaignWaveIndex >= campaignTotalWaves) {
        completeCampaignLevel();
      } else {
        spawnCampaignWave();
      }
    } else {
      spawnWave();
    }
  }
}

// ============================================================
//  RENDER with post-processing
// ============================================================
function render() {
  ctx.save();

  // Screen shake
  if (shakeTimer > 0) {
    shakeTimer--;
    ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
    shakeIntensity *= 0.9;
  }

  // Draw background (tiled + parallax stars + meteors)
  drawBackground();

  // Game objects
  for (const item of items) drawItem(item);
  for (const choice of powerupChoices) drawPowerupChoice(choice);
  for (const e of enemies) drawEnemy(e);
  for (const b of bosses) drawBoss(b);

  for (const b of enemyBullets) {
    if (b.delay && b.delay > 0) continue;
    drawBullet(b);
  }

  for (const b of playerBullets) drawPlayerBullet(b);
  drawPlayer();
  drawOrbitalBlades();

  // Fire sprite explosions (drawn on top with additive blending)
  drawFireSprites();

  // Particles
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Death ring
  if (!player.alive && player.deathAnim > 0 && player.deathAnim < 30) {
    const da = player.deathAnim / 30;
    ctx.strokeStyle = `rgba(255, 255, 255, ${1 - da})`; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(player.x, player.y, da * 80, 0, Math.PI * 2); ctx.stroke();
  }

  if (gameState === 'playing') {
    drawHUD();
    drawPowerupHUD();
    drawPowerupAnnouncement();
    if (powerupSelectActive) {
      const alpha = 0.7 + Math.sin(globalTime * 0.1) * 0.3;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 14px "Courier New"';
      ctx.textAlign = 'center';
      ctx.fillText('CHOOSE A POWERUP', W / 2, 55);
      ctx.globalAlpha = 1;
    }
  }
  if (gameState === 'select') drawSelectScreen();
  if (gameState === 'modeselect') drawModeSelectScreen();
  if (gameState === 'bossselect') drawBossSelectScreen();
  if (gameState === 'levelselect') drawLevelSelectScreen();
  if (gameState === 'shipview') drawShipViewScreen();
  if (gameState === 'leveldone') drawLevelDoneScreen();

  // Wave announcement
  if (waveTimer < 60 && gameState === 'playing') {
    const alpha = waveTimer < 30 ? waveTimer / 30 : (60 - waveTimer) / 30;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#ffffff'; ctx.font = 'bold 28px "Courier New"'; ctx.textAlign = 'center';
    if (gameMode === 'bossfight') {
      const entry = BOSS_FIGHT_LIST.find(b => b.type === bossFightType);
      ctx.fillStyle = entry ? entry.color : '#ff4444';
      ctx.fillText(entry ? entry.name : 'BOSS FIGHT', W / 2, H / 3);
      ctx.fillStyle = '#ffffff'; ctx.font = 'bold 16px "Courier New"';
      ctx.fillText('FIGHT!', W / 2, H / 3 + 35);
    } else if (gameMode === 'campaign' && campaignLevel) {
      ctx.fillText(`${campaignLevel.id}  WAVE ${wave}/${campaignTotalWaves}`, W / 2, H / 3);
    } else {
      ctx.fillText(`WAVE ${wave}`, W / 2, H / 3);
    }
    if (bosses.length > 0 && gameMode !== 'bossfight') {
      ctx.fillStyle = '#ff4444'; ctx.font = 'bold 20px "Courier New"';
      ctx.fillText('WARNING: BOSS APPROACHING', W / 2, H / 3 + 35);
    }
    ctx.globalAlpha = 1;
  }

  // Invincibility overlay
  if (player.invincible > 100) {
    ctx.fillStyle = `rgba(123, 104, 238, ${Math.min(0.3, (player.invincible - 100) / 20 * 0.3)})`;
    ctx.fillRect(0, 0, W, H);
  }

  ctx.restore();

  // ---- BLOOM POST-PROCESSING ----
  // Lightweight bloom: draw a blurred, brightened copy on top
  bloomCtx.clearRect(0, 0, W, H);
  bloomCtx.filter = 'blur(6px) brightness(1.5)';
  bloomCtx.globalAlpha = 0.15;
  bloomCtx.drawImage(canvas, 0, 0);
  bloomCtx.filter = 'none';
  bloomCtx.globalAlpha = 1;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.drawImage(bloomCanvas, 0, 0);
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();
}

// ============================================================
//  GAME LOOP
// ============================================================
function gameLoop() {
  update();
  render();
  requestAnimationFrame(gameLoop);
}

function completeCampaignLevel() {
  if (!campaignLevel) return;
  levelScore = score;
  const stars = levelDeaths === 0 && levelDamageTaken === 0 ? 3 :
                levelDeaths === 0 ? 2 : 1;

  // Save progress
  const prev = saveData.levels[campaignLevel.id] || {};
  saveData.levels[campaignLevel.id] = {
    cleared: true,
    bestScore: Math.max(prev.bestScore || 0, levelScore),
    stars: Math.max(prev.stars || 0, stars),
  };
  writeSave();

  // Clean up gameplay state
  powerupSelectActive = false;
  powerupChoices = [];
  enemyBullets = [];

  // Hide mobile controls
  if (isMobile) {
    touchControls.classList.remove('active');
    autoFireIndicator.style.display = 'none';
  }

  levelDoneTimer = 0;
  gameState = 'leveldone';
}

function startGame() {
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';
  gameState = 'playing';
  resetTouchState();

  if (isMobile) {
    touchControls.classList.add('active');
    autoFireIndicator.style.display = 'block';
  }

  // Pick ship config: campaign uses CAMPAIGN_SHIP, endless uses selected ship
  const cfg = gameMode === 'campaign' ? CAMPAIGN_SHIP : SHIP_CONFIGS[selectedShip];
  score = 0; wave = 0; waveTimer = 100; graze = 0; globalTime = 0;
  player.x = W / 2; player.y = H - 80;
  player.hp = cfg.hp; player.maxHp = cfg.maxHp; player.alive = true;
  player.invincible = 120; player.power = 1; player.bombs = cfg.bombs;
  player.speed = cfg.speed; player.focusSpeed = cfg.focusSpeed;
  player.hitboxRadius = cfg.hitboxRadius; player.shootDelay = cfg.shootDelay;
  player.shootTimer = 0; player.deathAnim = 0; player.options = [];
  player.engineFrame = 0; player.engineTimer = 0;

  // Reset shield bomb
  shieldBombActive = false; shieldBombTimer = 0;

  // Reset roguelike state
  runPowerups.collected = {};
  runPowerups.secondWindUsed = false;
  runPowerups.bossesDefeated = 0;
  powerupChoices = [];
  powerupSelectActive = false;
  powerupCollectedThisBoss = false;
  powerupAnnouncement = null;

  // Apply equipment modifiers for campaign mode
  resolveModifiers();

  // Apply equipment bonuses to starting stats
  if (gameMode === 'campaign') {
    player.maxHp += resolvedMods.maxHpBonus;
    player.hp = player.maxHp;
    player.bombs += (resolvedMods.bombBonus || 0);
  }

  playerBullets = []; enemies = []; enemyBullets = [];
  particles = []; items = []; bosses = []; fireSprites = [];
  lootDrop = null;
}

// ---- INIT: Load assets then show title ----
async function init() {
  initBackground();
  await loadAllAssets();
  preprocessMinibossSprites();
  generateHydraSprites();
  assetsLoaded = true;
  document.getElementById('loading-screen').style.display = 'none';
  document.getElementById('title-screen').style.display = 'flex';
  gameState = 'title';
  gameLoop();
}

init();
</script>
</body>
</html>
